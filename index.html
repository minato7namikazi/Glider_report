
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>likelihood PoC</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0b11;
            --container-bg: #1a1b26;
            --text-color: #a9b1d6;
            --header-color: #4cdcbc;
            --link-color: #7dcfff;
            --code-bg: #24283b;
            --border-color: #414868;
            --highlight-color: #43307f;
        }

        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 0;
        }

        .logo-container {
            text-align: center;
            padding: 20px 0 10px; /* Reduced bottom padding from 20px to 10px */
        }

        .logo-container img {
            max-width: 200px;
            height: auto;
        }

        .title {
            text-align: center;
            margin-bottom: 10px; /* Reduced from 20px to 10px */
        }

        .title h1 {
            margin-top: 0; /* Add this line to remove any default top margin */
            font-size: 3em;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #93e2fa, #7831a5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: titleGlow 3s ease-in-out infinite;
            display: inline-block;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            background-color: var(--container-bg);
            border-radius: 10px;
            margin-top: 20px;
            margin-bottom: 40px;
        }

        h2, h3, h4, h5, h6 {
            color: var(--header-color);
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 700;
        }

        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 10px rgba(122, 162, 247, 0.5); }
            50% { text-shadow: 0 0 20px rgb(95 64 130 / 80%); }
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        a:hover {
            color: var(--highlight-color);
            text-decoration: underline;
        }

        code {
            background-color: #3a242b;
            color: #f4305d;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 4px;
        }

        pre {
            background-color: var(--code-bg);
            color: var(--text-color);
            padding: 1em;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 0.9em;
        }

        blockquote {
            border-left: 4px solid var(--highlight-color);
            padding-left: 1em;
            margin-left: 0;
            font-style: italic;
            background-color: rgba(255,158,100,0.1);
            border-radius: 0 8px 8px 0;
        }

        hr {
            border: none;
            border-top: 2px solid var(--border-color);
            margin: 2em 0;
        }

        .contract-info {
            background-color: rgba(66,73,104,0.3);
            padding: 1em;
            border-radius: 8px;
            margin-bottom: 1em;
            border: 1px solid var(--border-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .contract-info:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .instruction {
            font-weight: bold;
            color: red;
            background-color: rgba(255,0,0,0.1);
            padding: 10px;
            border-radius: 8px;
            display: inline-block;
            margin-top: 10px;
        }

        .p code {
            background-color: #3a242b;
            color: #fd003a;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 4px;
        }

        /* Dracula theme for Prism.js */
        code[class*="language-"],
        pre[class*="language-"] {
            color: #f8f8f2;
            background: none;
            text-shadow: 0 1px rgba(0, 0, 0, 0.3);
            font-family: 'JetBrains Mono', monospace;
            text-align: left;
            white-space: pre;
            word-spacing: normal;
            word-break: normal;
            word-wrap: normal;
            line-height: 1.5;
            -moz-tab-size: 4;
            -o-tab-size: 4;
            tab-size: 4;
            -webkit-hyphens: none;
            -moz-hyphens: none;
            -ms-hyphens: none;
            hyphens: none;
        }
        pre[class*="language-"] {
            background: #282a36;
            border-radius: 0.3em;
            padding: 1em;
            margin: .5em 0;
            overflow: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        :not(pre) > code[class*="language-"] {
            padding: .1em;
            border-radius: .3em;
            white-space: normal;
        }
        .token.comment,
        .token.prolog,
        .token.doctype,
        .token.cdata {
            color: #6272a4;
        }
        .token.punctuation {
            color: #f8f8f2;
        }
        .namespace {
            opacity: .7;
        }
        .token.property,
        .token.tag,
        .token.constant,
        .token.symbol,
        .token.deleted {
            color: #ff79c6;
        }
        .token.boolean,
        .token.number {
            color: #bd93f9;
        }
        .token.selector,
        .token.attr-name,
        .token.string,
        .token.char,
        .token.builtin,
        .token.inserted {
            color: #50fa7b;
        }
        .token.operator,
        .token.entity,
        .token.url,
        .language-css .token.string,
        .style .token.string {
            color: #f8f8f2;
        }
        .token.atrule,
        .token.attr-value,
        .token.function,
        .token.class-name {
            color: #f1fa8c;
        }
        .token.keyword {
            color: #8be9fd;
        }
        .token.regex,
        .token.important {
            color: #ffb86c;
        }
        .token.important,
        .token.bold {
            font-weight: bold;
        }
        .token.italic {
            font-style: italic;
        }
        .token.entity {
            cursor: help;
        }
    </style>
</head>
<body>
    <div class="logo-container">
        <img src="https://i.ibb.co/NLFQR7d/immunefi-logo.png" alt="immunefi-logo">
    </div>
    <div class="title">
        <h1>likelihood PoC</h1>
    </div>
    <div class="container">
        
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8b747081cbda8c842bc3fbe1ae44600b4a66e785">0x8b747081cbda8c842bc3fbe1ae44600b4a66e785</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : testGameEngine</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa210aa164bfe631dc987842534b14f1f4f7fc8b6">0xa210aa164bfe631dc987842534b14f1f4f7fc8b6</a></p>
<pre><code class="language-solidity">function claimAndUnstake (bool claim,uint[] memory tokenAmount) external nonReentrant{

        for (uint i=0;i&lt;tokenAmount.length;i++) {
            require(nftToken.tokenOwnerCall(tokenAmount[i]) == msg.sender, &quot;Caller not the owner&quot;);
            require(nftToken.ownerOf(tokenAmount[i]) == address(this),&quot;Contract not the owner&quot;);
            require(isStaked[tokenAmount[i]] = true, &quot;Not Staked&quot;);
            require (stakeTime[tokenAmount[i]]+ tokenToRandomHourInStake[tokenAmount[i]]&lt;= block.timestamp,&quot;Be Patient&quot;);
            if (claim == true) {
                claimStake(tokenAmount[i]);
            }
            else {
                bool isBurnt = claimStake(tokenAmount[i]);
                if (isBurnt == false)
                {
                    unstakeNFT(tokenAmount[i]);
                    isStaked[tokenAmount[i]] = false;
                }

            }
            nftToken.setTimeStamp(tokenAmount[i]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x41a763efe09af772ddbd1e97cabf5b51a383deb8">0x41a763efe09af772ddbd1e97cabf5b51a383deb8</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : HoloNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x499da62084b0b6fc67fd44601d16a3e30f32f828">0x499da62084b0b6fc67fd44601d16a3e30f32f828</a></p>
<pre><code class="language-solidity">function lazyMintTo(
        address payable to,
        uint256 tokenId,
        address payable creator,
        uint16 creatorFee,
        bool allowSignature,
        bytes32 creatorSignature,
        bytes32 buyerSignature,
        uint16 publisherFee
    ) public onlyPartnerMarketAndOwner nonReentrant {

        mintToLogic(to, tokenId, creator, creatorFee, allowSignature, creatorSignature, publisherFee);
        if (allowSignature == true){
            tokens[tokenId].tokenSignature = abi.encodePacked(tokens[tokenId].tokenSignature, to, buyerSignature);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>allowSignature == true</code></p>
<hr />
<h3>Contract : Balladr</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa1af5bab0563f1435238b808d66d6babf5a6d776">0xa1af5bab0563f1435238b808d66d6babf5a6d776</a></p>
<pre><code class="language-solidity">function mintWrapper(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        string memory targetUri,
        uint256 maxSupply,
        bool isFrozen,
        uint256 collectionId,
        bytes memory data
    ) public {
        // Only an Authorized Contract can use this function.
        require(authorizedContracts[msg.sender] == true, &quot;Not Authorized&quot;);

        // Minting is only allowed in an opened collection
        require(isCollectionClosed[collectionId] == false, &quot;Collection is closed&quot;);

        // If Collection Owner is set, only the owner should be able to mint.
        if (collectionOwner[collectionId] != address(0)) {
          require(from == collectionOwner[collectionId], &quot;Minter is not the owner of the Collection&quot;);
        }

        // Froze the supply the first time a tokenId is minted
        if (tokenMaxSupply[id] == 0) {
            tokenMaxSupply[id] = maxSupply;
        }

        // The amount of token requested to be minted should be less than the total available supply
        require(
            (tokenMinteds[id] + amount) &lt;= tokenMaxSupply[id],
            &quot;Not enough supply&quot;
        );

        // Minting process

        // The tokenUri is set the first time the minting function is called for a given tokenId.
        if (bytes(_tokenUris[id]).length == 0) {
            _tokenUris[id] = targetUri;
        }

        // Set whether the tokenUri is frozen or not
        if (isFrozen == true) {
            if (isTokenUriFrozen[id] == false) {
                isTokenUriFrozen[id] = true;
                emit PermanentURI(targetUri, id);
            }
        }

        // Assign every Token to a CollectionId - Once per Token
        if (tokenIdToCollectionId[id] == 0) {
          tokenIdToCollectionId[id] = collectionId;
          // The first minted token from a Collection should set the Collection Owner
          if (collectionOwner[collectionId] == address(0)) {
            collectionOwner[collectionId] = from;
          }
        }

        // Increment the current minted supply
        tokenMinteds[id] += amount;

        // Call original ERC1155 function from the original token creator
        _mint(from, id, amount, data);

        // Emit the minting event
        emit Minted(from, id, amount);

        // Transfer the token from the creator the buyer
        _safeTransferFrom(from, to, id, amount, data);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isFrozen == true</code></p>
<hr />
<h3>Contract : PVCShares</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4ba75b11417faf69585c6cb403424983241aa1ee">0x4ba75b11417faf69585c6cb403424983241aa1ee</a></p>
<pre><code class="language-solidity">function mint(uint256 _amount, bool _usdc) external {
        require(_amount &gt;= MIN_MINT_PER_TX, &quot;Amount is too small&quot;);
        require(_amount &lt;= MAX_MINT_PER_TX, &quot;Amount is too large&quot;);
        require(totalSupply() + _amount &lt;= MAX_SUPPLY, &quot;Amount exceeds max supply&quot;);
        uint256 estimatedPrice = _calculatePrice(totalSupply() - INITIAL_SUPPLY);
        uint256 estimatedAmount = (_amount * estimatedPrice) / 1000;
        if (_usdc == true) {
            ERC20(USDC).transferFrom(msg.sender, OWNER, estimatedAmount);
        }
        if (_usdc == false) {
            ERC20(USDT).safeTransferFrom(msg.sender, OWNER, estimatedAmount);
        }
        _mint(msg.sender, _amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_usdc == true</code></p>
<hr />
<h3>Contract : MSCEVote</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xeca6f09d8570b5bc9f3fe77bc2a0e41d23983c00">0xeca6f09d8570b5bc9f3fe77bc2a0e41d23983c00</a></p>
<pre><code class="language-solidity">function voteXId(uint256 _id, bool _agree) onlyVotingRight public{
        Vote storage vote = votes[_id];
        uint256 rate = 100;
        if(vote.name == &quot;FREEZE&quot;)
        {
            rate = 30;
        }else if(vote.name == &quot;DESTROY&quot;)
        {
            rate = 51;
        }
        else{
            rate = 80;
        }
        if(now &gt; vote.endTime){
            vote.isActivated = false;
            votes[_id] = vote;
        }
        require(vote.isActivated == true, &quot;The vote ended&quot;);
        if(_agree == true){
            vote.agreeSupply = vote.agreeSupply.add(balances[msg.sender]);
        }
        else{
            vote.disagreeSupply = vote.disagreeSupply.add(balances[msg.sender]);
        }

        if (vote.agreeSupply &gt;= soldSupply * (rate/100)){
            executeVote(_id);
        }else if (vote.disagreeSupply &gt;= soldSupply * ((100-rate)/100)) {
            vote.isActivated = false;
            votes[_id] = vote;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_agree == true</code></p>
<hr />
<h3>Contract : MarsGenesisWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1371fa4c5b3487547a1190374b17df909dc366dc">0x1371fa4c5b3487547a1190374b17df909dc366dc</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : Presale</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde970926d20cc7ad6fa07f5a842f51ec38a06ed0">0xde970926d20cc7ad6fa07f5a842f51ec38a06ed0</a></p>
<pre><code class="language-solidity">function buy(
        address _token,
        uint256 _amount,
        address _onBehalfOf,
        address _refWallet,
        bool _stakeIt
    ) public payable nonReentrant returns (uint256) {
        require(presaleOpen, &quot;presale is closed&quot;);
        require(_token != address(0), &quot;Invalid _token address&quot;);
        require(_onBehalfOf != address(0), &quot;Invalid onBehalfOf address&quot;);
        require(_amount &gt; 0, &quot;Amount should be more than 0&quot;);
        require(_refWallet != address(0), &quot;Invalid refWallet address&quot;);
        require(_refWallet != _onBehalfOf, &quot;buyer can not refer themself&quot;);

        AggregatorV3Interface priceFeed;
        bool found = false;
        uint256 decimals;
        for (uint i = 0; i &lt; paymentTokens.length; i++) {
            if (paymentTokens[i].token == _token) {
                priceFeed = paymentTokens[i].priceFeed;
                decimals = paymentTokens[i].decimals;
                found = true;
                break;
            }
        }
        require(found, &quot;Payment token not supported&quot;);

        uint256 amountInUSD = convertPaymentTokenToUsd(
            _amount,
            priceFeed,
            decimals
        );

        if (_token == eth) {
            require(_amount == msg.value, &quot;Amount does not match&quot;);
            (bool sent, ) = treasury.call{value: _amount}(&quot;&quot;);
            require(sent, &quot;Failed to send Ether&quot;);
        } else {
            require(
                IERC20(_token).transferFrom(msg.sender, treasury, _amount),
                &quot;Transfer failed 1&quot;
            );
        }

        uint256 tokens = (amountInUSD * (10 ** 18)) / tokenPriceUSD;
        balances[_onBehalfOf] += tokens;
        totalBoughtTokens += tokens;

        uint256 refAmount = (tokens * refPercentage) / 100;
        referrals[_refWallet] += refAmount;
        totalReferralTokens += refAmount;

        if (_stakeIt == true) {
            _stake(_onBehalfOf, tokens);
        }

        emit PurchaseMade(
            _token,
            _amount,
            _onBehalfOf,
            tokens,
            _refWallet,
            _stakeIt
        );

        return tokens;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_stakeIt == true</code></p>
<hr />
<h3>Contract : ArbitrationX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x628c5da8b27ffdb08675a7037cd7727bf92dc7f2">0x628c5da8b27ffdb08675a7037cd7727bf92dc7f2</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        /* require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true); */
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4dfe96efa39d21165c732d7afe0becbdd40cc19e">0x4dfe96efa39d21165c732d7afe0becbdd40cc19e</a></p>
<pre><code class="language-solidity">function setIsSatellitePool(address pool, bool state) public {
        require(msg.sender == coreDev, &quot;Liquidation::setIsSatellitePool:caller is not coreDev&quot;);
        if(isSatellitePool[pool] != state) {
            isSatellitePool[pool] = state;
            if (state == true) {
                satellitePools.push(pool);
            } else {
                for (uint i=0; i &lt; satellitePools.length; i++) {
                    if (satellitePools[i] == pool) {
                        satellitePools[i] = satellitePools[satellitePools.length];
                        satellitePools.pop();
                    }
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>state == true</code></p>
<hr />
<h3>Contract : SoulzStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0a66d125a26019c2dfa2e49260476a75cb62cd40">0x0a66d125a26019c2dfa2e49260476a75cb62cd40</a></p>
<pre><code class="language-solidity">function endStaking(bool _isEnded) public onlyRole(DEFAULT_ADMIN_ROLE) {
        hasEnded = _isEnded;
        endTimestamp = _isEnded == true ? block.timestamp : 0;
        emit StakingEnded(endTimestamp);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>endTimestamp = _isEnded == true ? block.timestamp : 0</code></p>
<hr />
<h3>Contract : AgileCycle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xeb2870b37f998abe55ed1517b631256a55718d37">0xeb2870b37f998abe55ed1517b631256a55718d37</a></p>
<pre><code class="language-solidity">function approveCycle(bool _approved) public {
        require(cycleApproved != true &amp;&amp; roundFailedToStart != true);
        require(msg.sender == juryOperator);
        if (_approved == true) {
            cycleApproved = true;
        } else {
            roundFailedToStart = true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approved == true</code></p>
<hr />
<h3>Contract : AgileArbitration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xeb2870b37f998abe55ed1517b631256a55718d37">0xeb2870b37f998abe55ed1517b631256a55718d37</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : SMCRHIMagnesita</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde42dc3bcc797d2ed10d4d3a4967ad9f242c2100">0xde42dc3bcc797d2ed10d4d3a4967ad9f242c2100</a></p>
<pre><code class="language-solidity">function approveTechnicalMeasurement(
        string memory _label,
        bool _decision,
        bytes32 _technicalJustificative
    ) public measurementIsOpen(_label) canBeTechnicallyApproved(_label, _decision) {
        uint256 measurementId = getMeasurementId(_label);

        eventMeasurementType[measurementId] = MeasurementType.TECHNICAL;
        eventUser[measurementId] = msg.sender;

        if (_decision == true) {
            eventAction[measurementId] = Action.APPROVAL;
            measurementStatus[measurementId] = MeasurementStatus.TECHNICALLY_APPROVED;
        } else if (_decision == false) {
            eventAction[measurementId] = Action.DISSAPROVAL;
            measurementStatus[measurementId] = MeasurementStatus.TECHNICALLY_DISAPPROVED;
        }
        else {
            revert(&quot;Decision not boolean&quot;); // não sei se precisa
        }

        eventVariables[measurementId][uint256(Variables.TECHNICAL_JUSTIFICATIVE)] = _technicalJustificative;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_decision == true</code></p>
<hr />
<h3>Contract : SMCRHIMagnesita</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde42dc3bcc797d2ed10d4d3a4967ad9f242c2100">0xde42dc3bcc797d2ed10d4d3a4967ad9f242c2100</a></p>
<pre><code class="language-solidity">function registerCommercialMeasurement(
        string memory _label,
        int256 _producedSteel,
        int256 _totalInvoicedMaterial,
        bytes32 _commercialNotes,
        bytes32 _commercialFiles,
        bool _updateAdminVariables,
        int256 _stopLimit,
        int256 _contractedValueRatio,
        int256 _coefficient
    )
        public
        canBeCommerciallyMeasured(_label)
    {
        uint256 measurementId = getMeasurementId(_label);
        eventUser[measurementId] = msg.sender;
        eventMeasurementType[measurementId] = MeasurementType.COMMERCIAL;

        if (msg.sender == arbiter) {
            eventAction[measurementId] = Action.ARBITER_MEASURE;

            measurementVariables[measurementId][uint256(Variables.IS_OPEN)] = FALSE;
            measurementStatus[measurementId] = MeasurementStatus.COMMERCIALLY_APPROVED;
            setFinancialMeasurement(measurementId);
        } else {
            eventAction[measurementId] = Action.MEASURE;

            if (msg.sender == contractorCommercial) {
                measurementStatus[measurementId] = MeasurementStatus.WAITING_HIRED_COMMERCIAL;
            } else {
                measurementStatus[measurementId] = MeasurementStatus.WAITING_CONTRACTOR_COMMERCIAL;
            }
        }

        financialVariables[measurementId][uint256(Variables.PRODUCED_STEEL)] = _producedSteel;
        financialVariables[measurementId][uint256(Variables.TOTAL_INVOICED_MATERIAL)] = _totalInvoicedMaterial;

        if (_updateAdminVariables == true) {
            financialVariables[measurementId][uint256(Variables.STOP_LIMIT)] = _stopLimit;
            financialVariables[measurementId][uint256(Variables.CONTRACTED_VALUE_RATIO)] = _contractedValueRatio;
            financialVariables[measurementId][uint256(Variables.COEFFICIENT)] = _coefficient;

            stopLimit = _stopLimit;
            contractedValueRatio = _contractedValueRatio;
            coefficient = _coefficient;
        }


        eventVariables[measurementId][uint256(Variables.COMMERCIAL_NOTES)] = _commercialNotes;
        eventVariables[measurementId][uint256(Variables.COMMERCIAL_FILES)] = _commercialFiles;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_updateAdminVariables == true</code></p>
<hr />
<h3>Contract : SMCRHIMagnesita</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde42dc3bcc797d2ed10d4d3a4967ad9f242c2100">0xde42dc3bcc797d2ed10d4d3a4967ad9f242c2100</a></p>
<pre><code class="language-solidity">function approveCommercialMeasurement(
        string memory _label,
        bool _decision,
        bytes32 _commercialJustificative
    ) public measurementIsOpen(_label) canBeCommerciallyApproved(_label, _decision) {
        uint256 measurementId = getMeasurementId(_label);

        eventMeasurementType[measurementId] = MeasurementType.COMMERCIAL;
        eventUser[measurementId] = msg.sender;
        if (_decision == true) {
            eventAction[measurementId] = Action.APPROVAL;
            measurementStatus[measurementId] = MeasurementStatus.COMMERCIALLY_APPROVED;
            measurementVariables[measurementId][uint256(Variables.IS_OPEN)] = FALSE;
            setFinancialMeasurement(measurementId);
        } else {
            eventAction[measurementId] = Action.DISSAPROVAL;
            measurementStatus[measurementId] = MeasurementStatus.COMMERCIALLY_DISAPPROVED;
        }


        eventVariables[measurementId][uint256(Variables.COMMERCIAL_JUSTIFICATIVE)] = _commercialJustificative;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_decision == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x91950a9c89766afbf150f75c57f23113e0489b5e">0x91950a9c89766afbf150f75c57f23113e0489b5e</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x91950a9c89766afbf150f75c57f23113e0489b5e">0x91950a9c89766afbf150f75c57f23113e0489b5e</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : DaoStructs</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd7a4f012ead240691a98144cb488e483aefef724">0xd7a4f012ead240691a98144cb488e483aefef724</a></p>
<pre><code class="language-solidity">function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)
        external
        view
        returns (address[] memory _voters, uint256 _length)
    {
        uint256 _n = _allUsers.length;
        uint256 i;
        _length = 0;
        _voters = new address[](_n);
        if (_vote == true) {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.yesVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        } else {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.noVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : PopCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x12d3f81a4ad87fdb50de2412e362e780ec1d7b28">0x12d3f81a4ad87fdb50de2412e362e780ec1d7b28</a></p>
<pre><code class="language-solidity">function whitelistMint(
    uint256 _mintAmount,
    bool _isUSDC,
    bytes32[] calldata merkleProof
  )
    external
    payable
    whenNotPaused
    mintCompliance(_mintAmount)
    isValidMerkleProof(merkleProof, whitelistMerkleRoot)
  {
    require(isWhitelistSaleOpen, &quot;The whitelist sale is not enabled!&quot;);
    require(
      whitelistTokenCount + _mintAmount &lt;= maxWhitelistTokens,
      &quot;Max whitelist tokens exceeded&quot;
    );

    if (_isUSDC == true) {
      usdcAddress.transferFrom(
        msg.sender,
        treasuryWallet,
        (_mintAmount * (whitelistUSDCCost * 10**6))
      );
    } else {
      require(
        msg.value &gt;= (whitelistEtherCost * _mintAmount),
        &quot;Not enough ether!&quot;
      );
      (bool os, ) = payable(treasuryWallet).call{value: address(this).balance}(
        &quot;&quot;
      );
    }

    _mint(msg.sender, _mintAmount);
    whitelistMintCounts[msg.sender] += _mintAmount;
    whitelistTokenCount += _mintAmount;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isUSDC == true</code></p>
<hr />
<h3>Contract : PopCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x12d3f81a4ad87fdb50de2412e362e780ec1d7b28">0x12d3f81a4ad87fdb50de2412e362e780ec1d7b28</a></p>
<pre><code class="language-solidity">function publicMint(uint256 _mintAmount, bool _isUSDC)
    external
    payable
    whenNotPaused
    mintCompliance(_mintAmount)
  {
    require(isPublicSaleOpen, &quot;The public sale is not open!&quot;);

    if (_isUSDC == true) {
      usdcAddress.transferFrom(
        msg.sender,
        treasuryWallet,
        (_mintAmount * (publicUSDCCost * 10**6))
      );
    } else {
      require(
        msg.value &gt;= (publicEtherCost * _mintAmount),
        &quot;Not enough ether!&quot;
      );
      (bool os, ) = payable(treasuryWallet).call{value: address(this).balance}(
        &quot;&quot;
      );
    }

    _mint(msg.sender, _mintAmount);
    publicMintCounts[msg.sender] += _mintAmount;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isUSDC == true</code></p>
<hr />
<h3>Contract : Distributioner</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb759ada88724583a329deed6eec395e974985ed2">0xb759ada88724583a329deed6eec395e974985ed2</a></p>
<pre><code class="language-solidity">function claimRewardToken(address[] memory holders, address[] memory marketTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; marketTokens.length; i++) {
            bool isListed = ComptrollerInterface(comptroller).isMarketListed(marketTokens[i]);
            require(isListed, &quot;market must be listed&quot;);

            MarketTokenInterface marketToken = MarketTokenInterface(marketTokens[i]);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: marketToken.borrowIndex()});
                updateRewardTokenBorrowIndex(address(marketToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerRewardToken(address(marketToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateRewardTokenSupplyIndex(address(marketToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierRewardToken(address(marketToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            rewardAccrued[holders[j]] = grantRewardTokenInternal(holders[j], rewardAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Distributioner</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb759ada88724583a329deed6eec395e974985ed2">0xb759ada88724583a329deed6eec395e974985ed2</a></p>
<pre><code class="language-solidity">function claimRewardToken(address[] memory holders, address[] memory marketTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; marketTokens.length; i++) {
            bool isListed = ComptrollerInterface(comptroller).isMarketListed(marketTokens[i]);
            require(isListed, &quot;market must be listed&quot;);

            MarketTokenInterface marketToken = MarketTokenInterface(marketTokens[i]);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: marketToken.borrowIndex()});
                updateRewardTokenBorrowIndex(address(marketToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerRewardToken(address(marketToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateRewardTokenSupplyIndex(address(marketToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierRewardToken(address(marketToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            rewardAccrued[holders[j]] = grantRewardTokenInternal(holders[j], rewardAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Distributioner</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb759ada88724583a329deed6eec395e974985ed2">0xb759ada88724583a329deed6eec395e974985ed2</a></p>
<pre><code class="language-solidity">function claimRewardToken(address[] memory holders, address[] memory marketTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; marketTokens.length; i++) {
            bool isListed = ComptrollerInterface(comptroller).isMarketListed(marketTokens[i]);
            require(isListed, &quot;market must be listed&quot;);

            MarketTokenInterface marketToken = MarketTokenInterface(marketTokens[i]);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: marketToken.borrowIndex()});
                updateRewardTokenBorrowIndex(address(marketToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerRewardToken(address(marketToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateRewardTokenSupplyIndex(address(marketToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierRewardToken(address(marketToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            rewardAccrued[holders[j]] = grantRewardTokenInternal(holders[j], rewardAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Distributioner</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb759ada88724583a329deed6eec395e974985ed2">0xb759ada88724583a329deed6eec395e974985ed2</a></p>
<pre><code class="language-solidity">function claimRewardToken(address[] memory holders, address[] memory marketTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; marketTokens.length; i++) {
            bool isListed = ComptrollerInterface(comptroller).isMarketListed(marketTokens[i]);
            require(isListed, &quot;market must be listed&quot;);

            MarketTokenInterface marketToken = MarketTokenInterface(marketTokens[i]);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: marketToken.borrowIndex()});
                updateRewardTokenBorrowIndex(address(marketToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerRewardToken(address(marketToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateRewardTokenSupplyIndex(address(marketToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierRewardToken(address(marketToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            rewardAccrued[holders[j]] = grantRewardTokenInternal(holders[j], rewardAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : MQFShares</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5d5917adf85153176798b5ff28f4773865acf7e3">0x5d5917adf85153176798b5ff28f4773865acf7e3</a></p>
<pre><code class="language-solidity">function mint(uint256 _amount, bool _usdc) public {
        require(_amount &gt;= MIN_MINT_PER_TX, &quot;Amount is too small&quot;);
        require(_amount &lt;= MAX_MINT_PER_TX, &quot;Amount is too large&quot;);
        require(totalSupply() + _amount &lt;= MAX_SUPPLY, &quot;Amount exceeds max supply&quot;);
        if (_usdc == true) {
            ERC20(USDC).transferFrom(msg.sender, OWNER, _amount);
        }
        if (_usdc == false) {
            ERC20(USDT).safeTransferFrom(msg.sender, OWNER, _amount);
        }
        _mint(msg.sender, _amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_usdc == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x488605b301840801f636d2a0a7a16eb83d298268">0x488605b301840801f636d2a0a7a16eb83d298268</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function
        require(safetyMode == false, &quot;Safety Mode enabled, wait for new strategy deployment&quot;);

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x488605b301840801f636d2a0a7a16eb83d298268">0x488605b301840801f636d2a0a7a16eb83d298268</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        require(safetyMode == false, &quot;Safety Mode enabled, wait for new strategy deployment&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                uint256 buyID = getCheapestCurveToken();
                (uint256 sellID, ) = withdrawTokenReservesID(); // These may often be the same tokens
                checkAndSwapTokens(address(0), sellID, buyID);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyETHArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcd99e0ecfa5fe1f4abd7f855a661542c43f5ec61">0xcd99e0ecfa5fe1f4abd7f855a661542c43f5ec61</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyETHArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcd99e0ecfa5fe1f4abd7f855a661542c43f5ec61">0xcd99e0ecfa5fe1f4abd7f855a661542c43f5ec61</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0));
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35ae171dda486a77693f8b7c7898867c2f95f4a8">0x35ae171dda486a77693f8b7c7898867c2f95f4a8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35ae171dda486a77693f8b7c7898867c2f95f4a8">0x35ae171dda486a77693f8b7c7898867c2f95f4a8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35ae171dda486a77693f8b7c7898867c2f95f4a8">0x35ae171dda486a77693f8b7c7898867c2f95f4a8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35ae171dda486a77693f8b7c7898867c2f95f4a8">0x35ae171dda486a77693f8b7c7898867c2f95f4a8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35ae171dda486a77693f8b7c7898867c2f95f4a8">0x35ae171dda486a77693f8b7c7898867c2f95f4a8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35ae171dda486a77693f8b7c7898867c2f95f4a8">0x35ae171dda486a77693f8b7c7898867c2f95f4a8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35ae171dda486a77693f8b7c7898867c2f95f4a8">0x35ae171dda486a77693f8b7c7898867c2f95f4a8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35ae171dda486a77693f8b7c7898867c2f95f4a8">0x35ae171dda486a77693f8b7c7898867c2f95f4a8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : FairyOwnership</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6d80a462a40b39da0a0d0f7101ec97f52a9ef24">0xb6d80a462a40b39da0a0d0f7101ec97f52a9ef24</a></p>
<pre><code class="language-solidity">function setApprovalForAll(address operator, bool isApproved) whenServiceRunning whenNotBlocked external {
        // 주소 오용 차단
        require(operator != msg.sender);
        require(checkAddressMisused(operator) != true);

        if (isApproved == true) {
            masterToOperatorToIsApprovedForAll[msg.sender][operator] = true;
        } else {
            delete masterToOperatorToIsApprovedForAll[msg.sender][operator];
        }

        emit ApprovalForAll(msg.sender, operator, isApproved);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isApproved == true</code></p>
<hr />
<h3>Contract : FairyPayToUpgrade</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6d80a462a40b39da0a0d0f7101ec97f52a9ef24">0xb6d80a462a40b39da0a0d0f7101ec97f52a9ef24</a></p>
<pre><code class="language-solidity">function setApprovalForAll(address operator, bool isApproved) whenServiceRunning whenNotBlocked external {
        // 주소 오용 차단
        require(operator != msg.sender);
        require(checkAddressMisused(operator) != true);

        if (isApproved == true) {
            masterToOperatorToIsApprovedForAll[msg.sender][operator] = true;
        } else {
            delete masterToOperatorToIsApprovedForAll[msg.sender][operator];
        }

        emit ApprovalForAll(msg.sender, operator, isApproved);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isApproved == true</code></p>
<hr />
<h3>Contract : FairyMaster</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6d80a462a40b39da0a0d0f7101ec97f52a9ef24">0xb6d80a462a40b39da0a0d0f7101ec97f52a9ef24</a></p>
<pre><code class="language-solidity">function setApprovalForAll(address operator, bool isApproved) whenServiceRunning whenNotBlocked external {
        // 주소 오용 차단
        require(operator != msg.sender);
        require(checkAddressMisused(operator) != true);

        if (isApproved == true) {
            masterToOperatorToIsApprovedForAll[msg.sender][operator] = true;
        } else {
            delete masterToOperatorToIsApprovedForAll[msg.sender][operator];
        }

        emit ApprovalForAll(msg.sender, operator, isApproved);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isApproved == true</code></p>
<hr />
<h3>Contract : EtherFairy</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6d80a462a40b39da0a0d0f7101ec97f52a9ef24">0xb6d80a462a40b39da0a0d0f7101ec97f52a9ef24</a></p>
<pre><code class="language-solidity">function setApprovalForAll(address operator, bool isApproved) whenServiceRunning whenNotBlocked external {
        // 주소 오용 차단
        require(operator != msg.sender);
        require(checkAddressMisused(operator) != true);

        if (isApproved == true) {
            masterToOperatorToIsApprovedForAll[msg.sender][operator] = true;
        } else {
            delete masterToOperatorToIsApprovedForAll[msg.sender][operator];
        }

        emit ApprovalForAll(msg.sender, operator, isApproved);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isApproved == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea86a02ab9f43198f1bdfcff35ce16dedfdfa">0xcafea86a02ab9f43198f1bdfcff35ce16dedfdfa</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1ac95a41fa4ea6e3c7252d83bc72c95094f7958e">0x1ac95a41fa4ea6e3c7252d83bc72c95094f7958e</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // First the interest earned since the last call will be calculated
        // Some will sent to a strategy vault to be later processed when it becomes large enough
        calculateAndStoreInterest(); // This function will also call an update to lastATokenBalance

        // Then convert deposited stablecoins into their aToken equivalents and updates lastATokenBalance
        convertAllToAaveTokens();

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1ac95a41fa4ea6e3c7252d83bc72c95094f7958e">0x1ac95a41fa4ea6e3c7252d83bc72c95094f7958e</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // First the interest earned since the last call will be calculated and sent to vault
        calculateAndStoreInterest();

        // This is in case there are some leftover raw tokens
        convertAllToAaveTokens();

        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0)); // This will also not call calculateAndHold due to 0 address
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : Zapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5fee3467bc3a761ab20e96750b898a4132abdeb1">0x5fee3467bc3a761ab20e96750b898a4132abdeb1</a></p>
<pre><code class="language-solidity">function zapIn(
        uint256 stableCoinAmount,
        uint256 cycles,
        uint256 archMinAmount,
        uint256 ousdMinAmount,
        uint16 maxSlippageAllowed,
        address addressBaseStable,
        bool useUserArch
    ) external returns (uint256) {
        // Whats needs to happen?
        // -1) validate input
        // 0) transfer funds from user to this address
        // 1) figure out how much of stable goes to collateral and how much to pay as arch tokens
        // 2) exchange stable for Arch/ Take from user wallet
        // 3) exchange stable for OUSD
        // 4) open position
        // 5) return NFT to user

        // get a base line of how much stable is under management on conract - should be zero but creating a new base line
        /// validate input
        require(stableCoinAmount &gt; 0, &quot;err:stableCoinAmount==0&quot;);
        require(maxSlippageAllowed &lt; 1000, &quot;err:slippage&gt;999&quot;);
        require(maxSlippageAllowed &gt; 959, &quot;err:slippage&lt;960&quot;);

        // Now we apply slippage. We reduce the min of OUSD
        // This is because we need to always have enough Arch to pay so better to have a bit less OUSD and more Arch than
        // the other way around
        ousdMinAmount = (ousdMinAmount * maxSlippageAllowed) / 1000;

        /// transfer base stable coin from user to this address
        _transferFromSender(addressBaseStable, stableCoinAmount);

        /// Setup
        address[] memory path = _getPath(addressBaseStable);
        uint256 collateralInBaseStableAmount = stableCoinAmount;
        uint256 ousdAmount;

        if (useUserArch == false) {
            // Need to buy Arch tokens. We already know how much Arch tokens we want. We still need to know the Max in stable that
            // we are willing to pay. For that, we're running the splitEstimate again and adding a small buffer
            uint256 coinsToPayForArchAmount;
            (collateralInBaseStableAmount, coinsToPayForArchAmount) = _splitStableCoinAmount(stableCoinAmount, cycles, path, addressBaseStable);
            /// since we basivally add a buffer for max stable to take, its actually a built in limit on how much slippage is allowed.
            /// In this case up to 5%
            uint256 maxStableToPayForArch = (coinsToPayForArchAmount * 1000) / maxSlippageAllowed;
            // Now swap exact archMinAmount for a maximum of maxStableToPayForArch in stable coin
            uint256 stableUsedForArch = _uniswapRouter.swapTokensForExactTokens(
                archMinAmount,
                maxStableToPayForArch,
                path,
                address(this),
                block.timestamp + 1 minutes
            )[0];

            /// Exchange OUSD from any of the 3CRV. Will revert if didn't get min amount sent (2nd parameter)
            // Now spend all the remainign stable to buy OUSD
            ousdAmount = _exchangeToOUSD(stableCoinAmount - stableUsedForArch, ousdMinAmount, addressBaseStable);
        }

        // Check if we are using existing arch tokens owned by user or buying new ones
        if (useUserArch == true) {
            // First, exchange ALL stable coin to OUSD
            ousdAmount = _exchangeToOUSD(stableCoinAmount, ousdMinAmount, addressBaseStable);
            // We are using owners arch tokens, transfer from msg.sender to address(this)
            uint256 archToTransfer = _getArchAmountToTransferFromUser(ousdAmount, cycles);
            require(_archToken.balanceOf(msg.sender) &gt;= archToTransfer, &quot;err:insuf user arch&quot;);
            require(_archToken.allowance(msg.sender, address(this)) &gt;= archToTransfer, &quot;err:insuf approval arch&quot;);
            _transferFromSender(address(_archToken), archToTransfer);
        }

        // calculate min position leverage allowed
        uint256 minLeverageOUSD = (_paramStore.getAllowedLeverageForPosition(ousdAmount, cycles) * maxSlippageAllowed) / 1000;
        // create position
        uint256 tokenId = _levEngine.createLeveragedPositionFromZapper(
            ousdAmount,
            cycles,
            _archToken.balanceOf(address(this)),
            msg.sender,
            minLeverageOUSD
        );

        /// Return all remaining dust/tokens to user
        _archToken.safeTransfer(msg.sender, _archToken.balanceOf(address(this)));

        emit ZapIn(tokenId, stableCoinAmount, addressBaseStable, useUserArch);

        return tokenId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>useUserArch == true</code></p>
<hr />
<h3>Contract : BasicVote</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7511576ab7adbcb466366c8cd3529fe2e4833c6e">0x7511576ab7adbcb466366c8cd3529fe2e4833c6e</a></p>
<pre><code class="language-solidity">function vote(bool _option) public{
        if (_option == true) {
            emit VoteCast(&quot;missionStatementA&quot;);
        } else {
            emit VoteCast(&quot;missionStatementB&quot;);
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_option == true</code></p>
<hr />
<h3>Contract : BabyGrok</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1120e820f5168dc22a565fab8451713b112adec1">0x1120e820f5168dc22a565fab8451713b112adec1</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            staker[msg.sender].stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }

        staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(
            _amount
        );
        staker[msg.sender].lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
            return;
        }

        staker[msg.sender].unstakeStartTime = block.timestamp;
        staker[msg.sender].pendingAmount =
            staker[msg.sender].pendingAmount +
            outAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : BabyGrok</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1120e820f5168dc22a565fab8451713b112adec1">0x1120e820f5168dc22a565fab8451713b112adec1</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            staker[msg.sender].stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }

        staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(
            _amount
        );
        staker[msg.sender].lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
            return;
        }

        staker[msg.sender].unstakeStartTime = block.timestamp;
        staker[msg.sender].pendingAmount =
            staker[msg.sender].pendingAmount +
            outAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb1dd690cc9af7bb1a906a9b5a94f94191cc553ce">0xb1dd690cc9af7bb1a906a9b5a94f94191cc553ce</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : AVEC</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb89b742942eda3e107e8ac2ef953b41982998bdd">0xb89b742942eda3e107e8ac2ef953b41982998bdd</a></p>
<pre><code class="language-solidity">function createEscrow(
        bytes32 _PropertyID, 
        address payable _recipientOfFunds, 
        bytes32 _recipientName, 
        uint8 _escrowAgreementNumber,
        bool _override,
        bool _escrowCompleted,
        uint256 _milestonePriceOfEscrowInETH, 
        uint256 _tokensAvailableTotal,
        uint256 _propertyIncrease
        )
        public {
            requireUserPrivilegeLevel(3, msg.sender);
            uint8 _localEscrowAgreementNumber;
            if(Properties[_PropertyID].firstEscrowSet != true){
                _localEscrowAgreementNumber = 0;
                Properties[_PropertyID].currentEscrowAgreementNumber = 0;
                Properties[_PropertyID].firstEscrowSet = true;
            } else {
                _localEscrowAgreementNumber = uint8(Properties[_PropertyID].currentEscrowAgreementNumber++); 
            }
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].PropertyID = _PropertyID;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientOfFunds = _recipientOfFunds;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientName = _recipientName;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH = _milestonePriceOfEscrowInETH;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableTotal = _tokensAvailableTotal;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableCurrent = _tokensAvailableTotal;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].ethPerToken = (_milestonePriceOfEscrowInETH / _tokensAvailableTotal);
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowCompleted = _escrowCompleted;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].propertyIncrease = _propertyIncrease;
            ETHERESCROWED += GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH;
            if(_override == true){
               GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _escrowAgreementNumber; 
            } else {
                GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _localEscrowAgreementNumber;
            }
            Properties[_PropertyID].escrowAgreementNumber.push(GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber);
            bytes32 prop = _PropertyID;
            emit EscrowCreated(msg.sender, _recipientOfFunds,  _recipientName, _milestonePriceOfEscrowInETH, _tokensAvailableTotal, prop, _localEscrowAgreementNumber);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_override == true</code></p>
<hr />
<h3>Contract : AVEC</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb89b742942eda3e107e8ac2ef953b41982998bdd">0xb89b742942eda3e107e8ac2ef953b41982998bdd</a></p>
<pre><code class="language-solidity">function createEscrow(
        bytes32 _PropertyID, 
        address payable _recipientOfFunds, 
        bytes32 _recipientName, 
        uint8 _escrowAgreementNumber,
        bool _override,
        bool _escrowCompleted,
        uint256 _milestonePriceOfEscrowInETH, 
        uint256 _tokensAvailableTotal,
        uint256 _propertyIncrease
        )
        public {
            requireUserPrivilegeLevel(3, msg.sender);
            uint8 _localEscrowAgreementNumber;
            if(Properties[_PropertyID].firstEscrowSet != true){
                _localEscrowAgreementNumber = 0;
                Properties[_PropertyID].currentEscrowAgreementNumber = 0;
                Properties[_PropertyID].firstEscrowSet = true;
            } else {
                _localEscrowAgreementNumber = uint8(Properties[_PropertyID].currentEscrowAgreementNumber++); 
            }
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].PropertyID = _PropertyID;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientOfFunds = _recipientOfFunds;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientName = _recipientName;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH = _milestonePriceOfEscrowInETH;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableTotal = _tokensAvailableTotal;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableCurrent = _tokensAvailableTotal;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].ethPerToken = (_milestonePriceOfEscrowInETH / _tokensAvailableTotal);
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowCompleted = _escrowCompleted;
            GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].propertyIncrease = _propertyIncrease;
            ETHERESCROWED += GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH;
            if(_override == true){
               GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _escrowAgreementNumber; 
            } else {
                GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _localEscrowAgreementNumber;
            }
            Properties[_PropertyID].escrowAgreementNumber.push(GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber);
            bytes32 prop = _PropertyID;
            emit EscrowCreated(msg.sender, _recipientOfFunds,  _recipientName, _milestonePriceOfEscrowInETH, _tokensAvailableTotal, prop, _localEscrowAgreementNumber);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_override == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf745b1e1b2f90014e6c626075b10e6af3867fe0c">0xf745b1e1b2f90014e6c626075b10e6af3867fe0c</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf745b1e1b2f90014e6c626075b10e6af3867fe0c">0xf745b1e1b2f90014e6c626075b10e6af3867fe0c</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc153decea18ebdfef35bdbf5309cfcceb66af634">0xc153decea18ebdfef35bdbf5309cfcceb66af634</a></p>
<pre><code class="language-solidity">function trade(bool _isUSDB) public returns(bool) {
        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));
        uint256 returnUSD = network.rateByPath(generatePath(_isUSDB, true), tradeValue);
        uint256 returnDAI = network.rateByPath(generatePath(_isUSDB, false), tradeValue);
        IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD;

        if(returnDAI &gt; tradeValue) {
            require((returnDAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            network.convert2(generatePath(_isUSDB, true), tradeValue, tradeValue, address(0), 0);
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenDAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient DAI balance.');
            network.convert2(generatePath(_isUSDB, false), tradeValue, tradeValue, address(0), 0);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : StabilizeStrategyFRAXArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd3db642ae29c5dc7bfcebe67fe3c8245d561d006">0xd3db642ae29c5dc7bfcebe67fe3c8245d561d006</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyFRAXArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd3db642ae29c5dc7bfcebe67fe3c8245d561d006">0xd3db642ae29c5dc7bfcebe67fe3c8245d561d006</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                uint256 targetID = getCheaperToken(false);
                checkAndSwapTokens(_depositor, targetID, false);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrder(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrder(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc07bf7c056b0cd78cfe68f05b1e332e9ae190365">0xc07bf7c056b0cd78cfe68f05b1e332e9ae190365</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc07bf7c056b0cd78cfe68f05b1e332e9ae190365">0xc07bf7c056b0cd78cfe68f05b1e332e9ae190365</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : AssetsAccountant</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8a237818ff887cd243a3391b6a2814239992bea3">0x8a237818ff887cd243a3391b6a2814239992bea3</a></p>
<pre><code class="language-solidity">function allowLiquidator(address liquidator, bool allow) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (liquidator == address(0)) {
            revert AssetsAccountant_zeroAddress();
        }

        isARegisteredHouse[liquidator] = allow;

        if (allow == true) {
            _grantRole(LIQUIDATOR_ROLE, liquidator);
            _grantRole(BURNER_ROLE, liquidator);
        } else {
            _revokeRole(LIQUIDATOR_ROLE, liquidator);
            _revokeRole(BURNER_ROLE, liquidator);
        }
        emit LiquidatorAllow(liquidator, allow);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>allow == true</code></p>
<hr />
<h3>Contract : AssetsAccountant</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8a237818ff887cd243a3391b6a2814239992bea3">0x8a237818ff887cd243a3391b6a2814239992bea3</a></p>
<pre><code class="language-solidity">function allowReserveFactory(address factory, bool allow) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (factory == address(0)) {
            revert AssetsAccountant_zeroAddress();
        }

        isAValidReserveFactory[factory] = allow;

        if (allow == true) {
            _grantRole(DEFAULT_ADMIN_ROLE, factory);
        } else {
            _revokeRole(DEFAULT_ADMIN_ROLE, factory);
        }
        emit ReserveFactoryAllow(factory, allow);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>allow == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfe71394c383cd181e9f27285efb88fee30874a54">0xfe71394c383cd181e9f27285efb88fee30874a54</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfe71394c383cd181e9f27285efb88fee30874a54">0xfe71394c383cd181e9f27285efb88fee30874a54</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfe71394c383cd181e9f27285efb88fee30874a54">0xfe71394c383cd181e9f27285efb88fee30874a54</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x26dba82495f6189dde7648ae88bead46c402f078">0x26dba82495f6189dde7648ae88bead46c402f078</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x26dba82495f6189dde7648ae88bead46c402f078">0x26dba82495f6189dde7648ae88bead46c402f078</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x26dba82495f6189dde7648ae88bead46c402f078">0x26dba82495f6189dde7648ae88bead46c402f078</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x26dba82495f6189dde7648ae88bead46c402f078">0x26dba82495f6189dde7648ae88bead46c402f078</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea8321b5109d22c53ac019d7a449c947701fb">0xcafea8321b5109d22c53ac019d7a449c947701fb</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : DaoStructs</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x24626fd95ad815bab2136d6f91ca10562161cda3">0x24626fd95ad815bab2136d6f91ca10562161cda3</a></p>
<pre><code class="language-solidity">function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)
        external
        view
        returns (address[] memory _voters, uint256 _length)
    {
        uint256 _n = _allUsers.length;
        uint256 i;
        _length = 0;
        _voters = new address[](_n);
        if (_vote == true) {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.yesVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        } else {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.noVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : NFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x301140638d6f420f6bdb0f521ba169f81b23e2d2">0x301140638d6f420f6bdb0f521ba169f81b23e2d2</a></p>
<pre><code class="language-solidity">function fromBoolToString(bool _data) public pure returns (string memory) {
        if (_data == true) {
            return &quot;true&quot;;
        } else {
            return &quot;false&quot;;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_data == true</code></p>
<hr />
<h3>Contract : NFTGatingLean</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x45c5193e36bb9efe72677ab33979553234ea0a84">0x45c5193e36bb9efe72677ab33979553234ea0a84</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6b001c37c184566e19b1d5b9a93cb47aea4f1098">0x6b001c37c184566e19b1d5b9a93cb47aea4f1098</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : Angel</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf172ee4bd1b09b8aa6159e6af14734fece4c066b">0xf172ee4bd1b09b8aa6159e6af14734fece4c066b</a></p>
<pre><code class="language-solidity">function fromBoolToString(bool _data) public pure returns (string memory) {
        if (_data == true) {
            return &quot;true&quot;;
        } else {
            return &quot;false&quot;;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_data == true</code></p>
<hr />
<h3>Contract : AbyssEth2Depositor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfa5f9eaa65ffb2a75de092eb7f3fc84fc86b5b18">0xfa5f9eaa65ffb2a75de092eb7f3fc84fc86b5b18</a></p>
<pre><code class="language-solidity">constructor(bool mainnet, address depositContract_) {
        if (mainnet == true) {
            depositContract = IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa);
        } else if (depositContract_ == 0x0000000000000000000000000000000000000000) {
            depositContract = IDepositContract(0x8c5fecdC472E27Bc447696F431E425D02dd46a8c);
        } else {
            depositContract = IDepositContract(depositContract_);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mainnet == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xabe66cd02f2c3534056648b037860bbf86c81917">0xabe66cd02f2c3534056648b037860bbf86c81917</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xabe66cd02f2c3534056648b037860bbf86c81917">0xabe66cd02f2c3534056648b037860bbf86c81917</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : PIKE</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x186ed770eecea82def7c92dcc077c4ba27acd5bd">0x186ed770eecea82def7c92dcc077c4ba27acd5bd</a></p>
<pre><code class="language-solidity">function transferTokens(
        address _tokenAddress,
        address _to,
        uint256 _tokens,
        bool _isErc20
    ) public onlySafe returns (bool success) {
        require(_tokens &gt; 0);
        if (_isErc20 == true) {
            ERC20Yes(_tokenAddress).transfer(_to, _tokens);
        } else {
            ERC20Not(_tokenAddress).transfer(_to, _tokens);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isErc20 == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2ac695f706e24bf3732851747cf7b0aae392dc8a">0x2ac695f706e24bf3732851747cf7b0aae392dc8a</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2ac695f706e24bf3732851747cf7b0aae392dc8a">0x2ac695f706e24bf3732851747cf7b0aae392dc8a</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2ac695f706e24bf3732851747cf7b0aae392dc8a">0x2ac695f706e24bf3732851747cf7b0aae392dc8a</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner())</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x020d06cf650d5e4004ae5454e3399df8548f2ba1">0x020d06cf650d5e4004ae5454e3399df8548f2ba1</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x020d06cf650d5e4004ae5454e3399df8548f2ba1">0x020d06cf650d5e4004ae5454e3399df8548f2ba1</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : CEther</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf635fdf9b36b557bd281aa02fdfaebec04cd084a">0xf635fdf9b36b557bd281aa02fdfaebec04cd084a</a></p>
<pre><code class="language-solidity">function mint(bool enterMarket) external payable {
        (uint err,) = mintInternal(msg.value);
        requireNoError(err, &quot;mint failed&quot;);
        //If the user wants to use assets as collateral, enter them into the relevant market
        if(enterMarket == true){
            address[] memory marketToEnter = new address[](1);
            marketToEnter[0] = address(this);
            comptroller.enterMarkets(marketToEnter, msg.sender);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>enterMarket == true</code></p>
<hr />
<h3>Contract : AnchorAccount</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x079dd15a6de7b160246aa317d43cf524721ad3dd">0x079dd15a6de7b160246aa317d43cf524721ad3dd</a></p>
<pre><code class="language-solidity">function finishDepositStable(bool _isCustodyEnabled) public onlyAuthSender checkFinish terraAddressSet {
        if (_isCustodyEnabled == true) {
            (bool success, bytes memory data) = address(this).delegatecall(abi.encodeWithSignature(&quot;finishDepositStableCustody()&quot;));
            require(success == true, string(data));
        }
        else {
            (bool success, bytes memory data) = address(this).delegatecall(abi.encodeWithSignature(&quot;finishDepositStable()&quot;));
            require(success == true, string(data));
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isCustodyEnabled == true</code></p>
<hr />
<h3>Contract : AnchorAccount</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x079dd15a6de7b160246aa317d43cf524721ad3dd">0x079dd15a6de7b160246aa317d43cf524721ad3dd</a></p>
<pre><code class="language-solidity">function initRedeemStable(uint256 amount, bool _isCustodyEnabled) public onlyAuthSender checkInit terraAddressSet {
        if (_isCustodyEnabled == true) {
            (bool success, bytes memory data) = address(this).delegatecall(abi.encodeWithSignature(&quot;initRedeemStableCustody(uint256)&quot;, amount));
            require(success == true, string(data));
        }
        else {
            (bool success, bytes memory data) = address(this).delegatecall(abi.encodeWithSignature(&quot;initRedeemStable(uint256)&quot;, amount));
            require(success == true, string(data));
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isCustodyEnabled == true</code></p>
<hr />
<h3>Contract : RugProofMaster</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf9124e7aa91df1cddcf61a5f43bc6e1f9afb050b">0xf9124e7aa91df1cddcf61a5f43bc6e1f9afb050b</a></p>
<pre><code class="language-solidity">function createNewTokenSale(
      address _contractAddress, uint256 _tokenAmount,
      uint256 _tokenRatio, uint32 _timestampEndSec,
      uint8 _liquidityLockPercent, uint256 _softcap, bool wantVerified) external payable {

        require(_contractAddress != address(0), &quot;CreateNewTokenSale: Cannot use the zero address&quot;);
        require(msg.sender != address(this), &quot;CreateNewTokenSale: Cannot call from this contract&quot;);
        require(_tokenAmount != 0, &quot;CreateNewTokenSale: Cannot sell zero tokens&quot;);
        require(_tokenRatio != 0, &quot;CreateNewTokenSale: Cannot have a zero ratio&quot;);
        require(_softcap != 0, &quot;CreateNewTokenSale: Cannot have a zero softcap&quot;);
        require(_timestampEndSec &gt; now, &quot;CreateNewTokenSale: Cannot start sale after end time&quot;);
        require(_liquidityLockPercent &lt;= 100, &quot;CreateNewTokenSale: Cannot have higher than 100% liquidity lock&quot;);

        if(wantVerified == true){
          require(msg.value == 2e18, &quot;createNewTokenSale::wantVerified: msg.value is must be 2 ETH&quot;);
          address(owner).toPayable().transfer(2e18);
        }

        // check how many tokens we receive
        // this is an important step to ensure we log proper amounts if this is a deflationary token
        // approve must be called before this function is executed. Need to approve this contract address to send the token amount
        uint256 tokenBalanceBeforeTransfer = IERC20(_contractAddress).balanceOf(address(this));
        IERC20(_contractAddress).transferFrom(address(msg.sender), address(this), _tokenAmount);
        uint256 tokensReceived = IERC20(_contractAddress).balanceOf(address(this)).sub(tokenBalanceBeforeTransfer);


        SaleInfo memory saleInfo = SaleInfo(
          _contractAddress, msg.sender, tokensReceived, _tokenRatio, 0, _softcap,
          0, uint32(now), _timestampEndSec, _liquidityLockPercent, false, false
          );

        tokenSales.push(saleInfo);
        emit LogCreateNewSale(_contractAddress, _tokenAmount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>wantVerified == true</code></p>
<hr />
<h3>Contract : MarsGenesisWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd0c0a7971ea77aab40f46f054a0abbdb2b7970b6">0xd0c0a7971ea77aab40f46f054a0abbdb2b7970b6</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : MarsGenesisMartiansWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x10235f2d820bdac032fdeea25f9a57eb0890c3e0">0x10235f2d820bdac032fdeea25f9a57eb0890c3e0</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfa0ed4cf54b7644cd4e9c19af3809ec35aed9ad9">0xfa0ed4cf54b7644cd4e9c19af3809ec35aed9ad9</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x509e82bde98272ed974764414528309e28872302">0x509e82bde98272ed974764414528309e28872302</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : UNDTISSUE</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbb068d536a1151ed1a5ade9b0da8f3252dfd2f81">0xbb068d536a1151ed1a5ade9b0da8f3252dfd2f81</a></p>
<pre><code class="language-solidity">function redeemNPA(uint256 _amount,address _token,bool _isReceiveToken) public returns (bool success) { 
        uint _value = safeDiv(safeMul(_amount , safePower(10,tokenDecimals[_token])) , safePower(10,decimals)) ;    
        require (_amount &gt; 0 &amp;&amp; !pauseRedeem) ;  
        require (isNPA[_token] == true) ;
        require (_amount &lt;= tokenSupply[_token]) ;  
        require (Token(tokenAddress).transferFrom(msg.sender,address(this),_amount));
        require(Token(tokenAddress).burn(_amount));    
        if(_isReceiveToken == true) {       
            if(isTransferFrom[_token]){
             require (Token(_token).transfer(msg.sender, _value));
            }else{  
                 TokenUSDT(_token).transfer(msg.sender, _value);                        
            }            
        }
        else{ tokens[_token][msg.sender] = safeAdd(tokens[_token][msg.sender], _value);}    
        tokenSupply[_token] = safeSub(tokenSupply[_token],_amount);                         
        totalSupply = safeSub(totalSupply,_amount);                                         
        return true;  
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isReceiveToken == true</code></p>
<hr />
<h3>Contract : ERC20Lean</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa53778c8d50546df1973d21f3729f7315dbe697d">0xa53778c8d50546df1973d21f3729f7315dbe697d</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyUSTFlashArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde358818b9f99aab9481fee675b2de3c4d36154a">0xde358818b9f99aab9481fee675b2de3c4d36154a</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyUSTFlashArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde358818b9f99aab9481fee675b2de3c4d36154a">0xde358818b9f99aab9481fee675b2de3c4d36154a</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrder(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrder(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategySGRArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4cacad7f3d66a24bd65b1bf897bd35a425e2cac6">0x4cacad7f3d66a24bd65b1bf897bd35a425e2cac6</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategySGRArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4cacad7f3d66a24bd65b1bf897bd35a425e2cac6">0x4cacad7f3d66a24bd65b1bf897bd35a425e2cac6</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : Bundles</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd1064084f27c1b2c5991f3acc13be8f9916b08cd">0xd1064084f27c1b2c5991f3acc13be8f9916b08cd</a></p>
<pre><code class="language-solidity">function updatebal(address _user,uint256 _bundleId,uint256 _reward,bool _isPositive) public returns(bool){
        require(msg.sender == owner,'Not Owner');
        require(_reward &lt;= 4000000,'Invalid Reward Percent');
        User storage us = user[_user];
        require(us.active == true,'Invalid User');
        UserBets storage u = bets[_user][_bundleId];
        require(u.claimed == false,'Already Claimed');
        if(_isPositive == true){
            updateFee(_reward,u.totalbet);
            uint256 temp = SafeMath.mul(_reward,90);
            uint256 reward = SafeMath.div(temp,100);
            uint256 a = SafeMath.mul(u.totalbet,reward);
            uint256 b = SafeMath.div(a,10**8);
            uint256 c = SafeMath.add(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        else{
            uint256 a = SafeMath.mul(u.totalbet,_reward);
            uint256 b = SafeMath.div(a,10**8);
            uint256 c = SafeMath.sub(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isPositive == true</code></p>
<hr />
<h3>Contract : EthFoundation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4e5534770f8cdf113f06b5fdbd9d5b1fdf4d7f8e">0x4e5534770f8cdf113f06b5fdbd9d5b1fdf4d7f8e</a></p>
<pre><code class="language-solidity">function lockUser(address ethAddress, bool isLock)  onlyAdmin {

        User user = userMapping[ethAddress];
        if(isLock == true){
            user.isLock = true;
            userMapping[user.ethAddress] =  user;
        }
        else if(isLock == false){
            user.isLock = false;
            userMapping[user.ethAddress] =  user;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isLock == true</code></p>
<hr />
<h3>Contract : RewardCampaign</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3300b3c4a4f733cc1bd3986ecbb4b397ab733dd2">0x3300b3c4a4f733cc1bd3986ecbb4b397ab733dd2</a></p>
<pre><code class="language-solidity">function setApprovedKYFInstance(
        address _kyfContract,
        bool _status
    )
        public
        onlyAdmin
    {
        if (_status == true) {
            kyfInstancesArray.push(_kyfContract);
            kyfInstances[_kyfContract] = true;
            emit KyfStatusUpdated(_kyfContract, true);
            return;
        }

        // Remove the kyfContract from the kyfInstancesArray array.
        for (uint i = 0; i &lt; kyfInstancesArray.length; i++) {
            if (address(kyfInstancesArray[i]) == _kyfContract) {
                delete kyfInstancesArray[i];
                kyfInstancesArray[i] = kyfInstancesArray[kyfInstancesArray.length - 1];

                // Decrease the size of the array by one.
                kyfInstancesArray.length--;
                break;
            }
        }

        // And remove it from the synths mapping
        delete kyfInstances[_kyfContract];
        emit KyfStatusUpdated(_kyfContract, false);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyAMPLArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xea2796d73e24591e61b27b21c13c4deb01a2cc3d">0xea2796d73e24591e61b27b21c13c4deb01a2cc3d</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : RisingStackersStakingCon</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x54b4396b0754416923dd5adce66e9e0a6b48d23d">0x54b4396b0754416923dd5adce66e9e0a6b48d23d</a></p>
<pre><code class="language-solidity">function stake(uint256 tokenId, bool _boost, uint256 _rank) public {
        uint256 _mulx = 0;
        require(_nft.ownerOf(tokenId) == msg.sender, &quot;It is not your NFT&quot;);
        require(stakingDetails[tokenId].tokenId == 0, &quot;Already Staked&quot;);
        totalStaked += 1;
        stakedNftPerAddress[msg.sender].push(tokenId);
        addStaker(msg.sender);
        if(_boost == true){
            if(_boostToken.balanceOf(msg.sender,legendaryPotion) &gt; 0){
                _boost = true;
                _mulx = 20;
            }else if(_boostToken.balanceOf(msg.sender,rarePotion) &gt; 0){
                _boost = true;
                _mulx = 15;
            }else if(_boostToken.balanceOf(msg.sender,commonPotion) &gt; 0){
                _boost = true;
                _mulx = 12;
            }else{
                _boost = false;
            }
        }
        _nft.transferFrom(msg.sender, address(this), tokenId);
        stakingDetails[tokenId] = Stake({
            owner: msg.sender,
            tokenId: uint256(tokenId),
            timestamp: uint256(block.timestamp),
            boost : _boost,
            mulx : _mulx,
            rank : _rank
        });
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_boost == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x504a7dff5eb2854be0b436da0ac2d3e0b789fe20">0x504a7dff5eb2854be0b436da0ac2d3e0b789fe20</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : N2MERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x186a4d2c3b599e887ebdcaed8485b9aa18498f16">0x186a4d2c3b599e887ebdcaed8485b9aa18498f16</a></p>
<pre><code class="language-solidity">function initialize(
        string memory tokenName,
        string memory tokenSymbol,
        uint256 iMintPrice,
        bytes32 baseURICIDHash,
        bytes32 placeholderImageCIDHash,
        RevenueAddress[] calldata revenueAddresses,
        address iErc20PaymentAddress,
        uint32 iTotalSupply,
        uint16 iRoyaltyFee,
        bool soulboundCollection,
        MintingType iMintingType
    ) public payable override initializer {
        __ERC721_init(tokenName, tokenSymbol);

        if (iTotalSupply == 0) revert TotalSupplyMustBeGreaterThanZero();
        if (baseURICIDHash != 0 &amp;&amp; placeholderImageCIDHash != 0) revert CantSetBaseURIAndPlaceholderAtTheSameTime();
        if (iRoyaltyFee &gt; 10_00) revert RoyaltyFeeTooHigh();

        _collectionSize = iTotalSupply;
        if (baseURICIDHash == 0) {
            if (placeholderImageCIDHash == 0) {
                if (iMintingType != MintingType.CUSTOM_URI)
                    revert NoBaseURINorPlaceholderSet();
            } else {
                _placeholderImageCIDHash = placeholderImageCIDHash;
            }
        } else {
            _baseURICIDHash = baseURICIDHash;
        }

        _mintPrice = iMintPrice;
        _royaltyFee = iRoyaltyFee;
        if (iMintingType != MintingType.SEQUENTIAL) {
            _mintingType = iMintingType;
        }
        if (iErc20PaymentAddress != address(0)) {
            _isERC20Payment = true;
            _erc20PaymentAddress = iErc20PaymentAddress;
        }
        if (soulboundCollection == true) {
            _soulboundCollection = true;
        }

        if (revenueAddresses.length &gt; 0) {
            uint256 revenuePercentageTotal;
            for (uint256 i; i &lt; revenueAddresses.length; ) {
                revenuePercentageTotal += revenueAddresses[i].percentage;
                unchecked {
                    ++i;
                }
            }
            _revenueInfo = revenueAddresses;
            if (revenuePercentageTotal &gt; 100_00 - N2M_FEE) revert InvalidRevenuePercentage();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>soulboundCollection == true</code></p>
<hr />
<h3>Contract : miniSUZUME</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x733209ec3d2201e8500cf373c5056770e817b08b">0x733209ec3d2201e8500cf373c5056770e817b08b</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x04ab1e8ca4050f583c7fd9794580ba0c4f618b1d">0x04ab1e8ca4050f583c7fd9794580ba0c4f618b1d</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x04ab1e8ca4050f583c7fd9794580ba0c4f618b1d">0x04ab1e8ca4050f583c7fd9794580ba0c4f618b1d</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x04ab1e8ca4050f583c7fd9794580ba0c4f618b1d">0x04ab1e8ca4050f583c7fd9794580ba0c4f618b1d</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x04ab1e8ca4050f583c7fd9794580ba0c4f618b1d">0x04ab1e8ca4050f583c7fd9794580ba0c4f618b1d</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : AssholeSBT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf067fe2481ec959ccb4d2bd5d0a58fcb238ded3d">0xf067fe2481ec959ccb4d2bd5d0a58fcb238ded3d</a></p>
<pre><code class="language-solidity">function changePrice(bool mintOrBurn, uint256 _newPrice) external {
        require(_admins[msg.sender], &quot;no perms&quot;);
        if (mintOrBurn == true) {
            contractData.mintPrice = _newPrice;
            emit PriceChange(&quot;mint&quot;, _newPrice);
        }
        if (mintOrBurn == false) {
            contractData.burnPrice = _newPrice;
            emit PriceChange(&quot;burn&quot;, _newPrice);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mintOrBurn == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x48934a0a78a9ce098458ef9e148d2dba519f4b20">0x48934a0a78a9ce098458ef9e148d2dba519f4b20</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x48934a0a78a9ce098458ef9e148d2dba519f4b20">0x48934a0a78a9ce098458ef9e148d2dba519f4b20</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x48934a0a78a9ce098458ef9e148d2dba519f4b20">0x48934a0a78a9ce098458ef9e148d2dba519f4b20</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x48934a0a78a9ce098458ef9e148d2dba519f4b20">0x48934a0a78a9ce098458ef9e148d2dba519f4b20</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2a3f6ef9aa381abebdd59029cd95d1b115322ef7">0x2a3f6ef9aa381abebdd59029cd95d1b115322ef7</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2a3f6ef9aa381abebdd59029cd95d1b115322ef7">0x2a3f6ef9aa381abebdd59029cd95d1b115322ef7</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2a3f6ef9aa381abebdd59029cd95d1b115322ef7">0x2a3f6ef9aa381abebdd59029cd95d1b115322ef7</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0d1ca6ec20b19cf30d7e32df62ff166a47ac5ecd">0x0d1ca6ec20b19cf30d7e32df62ff166a47ac5ecd</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external override moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                IModule(_module).init(address(this));
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xab243ed08e965f7e402897e36874081cfcebd69b">0xab243ed08e965f7e402897e36874081cfcebd69b</a></p>
<pre><code class="language-solidity">function updateSale(address _tokenAddress,uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) onlyAcceptedToken(_tokenAddress) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale      = true;
            sale.amount         = _amount;
            sale.price          = _price;
            sale.tokenAddress   = _tokenAddress;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : BaseCoin</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa46b3e109b176ecef4f76f173e4170cea660f454">0xa46b3e109b176ecef4f76f173e4170cea660f454</a></p>
<pre><code class="language-solidity">function setOpExecutorRole(
        address executor,
        bool bEnable
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(executor != address(0), &quot;executor couldn't be Zero address&quot;);
        bEnable == true
            ? _grantRole(ROLE_OP_EXECUTOR, executor)
            : _revokeRole(ROLE_OP_EXECUTOR, executor);

        emit evAddrSetted(address(0), executor, TAG_EXECUTOR, bEnable);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>bEnable == true
            ? _grantRole(ROLE_OP_EXECUTOR, executor)
            : _revokeRole(ROLE_OP_EXECUTOR, executor)</code></p>
<hr />
<h3>Contract : HNXCoin</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa46b3e109b176ecef4f76f173e4170cea660f454">0xa46b3e109b176ecef4f76f173e4170cea660f454</a></p>
<pre><code class="language-solidity">function setOpExecutorRole(
        address executor,
        bool bEnable
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(executor != address(0), &quot;executor couldn't be Zero address&quot;);
        bEnable == true
            ? _grantRole(ROLE_OP_EXECUTOR, executor)
            : _revokeRole(ROLE_OP_EXECUTOR, executor);

        emit evAddrSetted(address(0), executor, TAG_EXECUTOR, bEnable);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>bEnable == true
            ? _grantRole(ROLE_OP_EXECUTOR, executor)
            : _revokeRole(ROLE_OP_EXECUTOR, executor)</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x74316a600b3c02499a9921ec50802c1940c2b083">0x74316a600b3c02499a9921ec50802c1940c2b083</a></p>
<pre><code class="language-solidity">function updateSwapDurations(
        uint256 _duration,
        bool _is_supported
    ) external onlyGovernance() returns(bool){

        // get the initial value
        bool initialValue = swapDurations[_duration];

        // update the swapDurations mapping
        swapDurations[_duration] = _is_supported;

        // check if a swapDuration is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the swapDurationCount
            swapDurationCount = swapDurationCount.add(1);

        }

        // check if a swapDuration is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the swapDurationCount
            swapDurationCount = swapDurationCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == false &amp;&amp; _is_supported == true</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x74316a600b3c02499a9921ec50802c1940c2b083">0x74316a600b3c02499a9921ec50802c1940c2b083</a></p>
<pre><code class="language-solidity">function updateSwapDurations(
        uint256 _duration,
        bool _is_supported
    ) external onlyGovernance() returns(bool){

        // get the initial value
        bool initialValue = swapDurations[_duration];

        // update the swapDurations mapping
        swapDurations[_duration] = _is_supported;

        // check if a swapDuration is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the swapDurationCount
            swapDurationCount = swapDurationCount.add(1);

        }

        // check if a swapDuration is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the swapDurationCount
            swapDurationCount = swapDurationCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == true &amp;&amp; _is_supported == false</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x74316a600b3c02499a9921ec50802c1940c2b083">0x74316a600b3c02499a9921ec50802c1940c2b083</a></p>
<pre><code class="language-solidity">function updateProtocols(
        uint256 _protocol,
        bool _is_supported
    ) external onlyGovernance() returns(bool){

        // get the initial value
        bool initialValue = protocols[_protocol];

        // update the protocols mapping
        protocols[_protocol] = _is_supported;

        // check if a protocol is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the protocolCount
            protocolCount = protocolCount.add(1);

        }

        // check if a protocol is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the protocolCount
            protocolCount = protocolCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == false &amp;&amp; _is_supported == true</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x74316a600b3c02499a9921ec50802c1940c2b083">0x74316a600b3c02499a9921ec50802c1940c2b083</a></p>
<pre><code class="language-solidity">function updateProtocols(
        uint256 _protocol,
        bool _is_supported
    ) external onlyGovernance() returns(bool){

        // get the initial value
        bool initialValue = protocols[_protocol];

        // update the protocols mapping
        protocols[_protocol] = _is_supported;

        // check if a protocol is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the protocolCount
            protocolCount = protocolCount.add(1);

        }

        // check if a protocol is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the protocolCount
            protocolCount = protocolCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == true &amp;&amp; _is_supported == false</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x74316a600b3c02499a9921ec50802c1940c2b083">0x74316a600b3c02499a9921ec50802c1940c2b083</a></p>
<pre><code class="language-solidity">function updateProtocolMarkets(
        uint256 _protocol,
        address _market,
        bool _is_supported
    ) external onlyGovernance() returns(bool){

        // get the initial value
        bool initialValue = protocolMarkets[_protocol][_market];

        // update the protocolMarkets mapping
        protocolMarkets[_protocol][_market] = _is_supported;

        // check if a protocol market is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the protocolMarketCount
            protocolMarketCount = protocolMarketCount.add(1);

        }

        // check if a protocol market is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the protocolMarketCount
            protocolMarketCount = protocolMarketCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == false &amp;&amp; _is_supported == true</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x74316a600b3c02499a9921ec50802c1940c2b083">0x74316a600b3c02499a9921ec50802c1940c2b083</a></p>
<pre><code class="language-solidity">function updateProtocolMarkets(
        uint256 _protocol,
        address _market,
        bool _is_supported
    ) external onlyGovernance() returns(bool){

        // get the initial value
        bool initialValue = protocolMarkets[_protocol][_market];

        // update the protocolMarkets mapping
        protocolMarkets[_protocol][_market] = _is_supported;

        // check if a protocol market is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the protocolMarketCount
            protocolMarketCount = protocolMarketCount.add(1);

        }

        // check if a protocol market is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the protocolMarketCount
            protocolMarketCount = protocolMarketCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == true &amp;&amp; _is_supported == false</code></p>
<hr />
<h3>Contract : TreeETH</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc35997f9a8b890beb436255770644339e6230e4b">0xc35997f9a8b890beb436255770644339e6230e4b</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1_2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x01e3ffec88904c7af69579198a51ba5443c6662a">0x01e3ffec88904c7af69579198a51ba5443c6662a</a></p>
<pre><code class="language-solidity">function addorRemoveTokens(address[] memory _addresses, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            TokenAddresses[_addresses[i]] = _isAdded;
            if (_isAdded == true) {
                emit TokenAdded(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1_2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x01e3ffec88904c7af69579198a51ba5443c6662a">0x01e3ffec88904c7af69579198a51ba5443c6662a</a></p>
<pre><code class="language-solidity">function giveorRemoveSubscriptionTo(
        address[] memory _addresses,
        bool _isSubscriber
    ) external onlyRole(OPERATOR_ROLE, msg.sender) {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            Subscribers[_addresses[i]] = _isSubscriber;
            if (_isSubscriber == true) {
                emit GotSubscription(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSubscriber == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1_2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x01e3ffec88904c7af69579198a51ba5443c6662a">0x01e3ffec88904c7af69579198a51ba5443c6662a</a></p>
<pre><code class="language-solidity">function addTokenPayments(address[] memory _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        for (uint256 i = 0; i &lt; _address.length; i++) {
            TokenPaymentAddresses[_address[i]] = _isAdded;
            if (_isAdded == true) {
                emit AddedTokenPayment(_address[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : DaoStructs</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7a5d249029172904a8c0dbc7761dd9ae60436bed">0x7a5d249029172904a8c0dbc7761dd9ae60436bed</a></p>
<pre><code class="language-solidity">function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)
        external
        view
        returns (address[] memory _voters, uint256 _length)
    {
        uint256 _n = _allUsers.length;
        uint256 i;
        _length = 0;
        _voters = new address[](_n);
        if (_vote == true) {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.yesVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        } else {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.noVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : Token</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ed564445cdc47903b7edd636d61846d6d9ef111">0x5ed564445cdc47903b7edd636d61846d6d9ef111</a></p>
<pre><code class="language-solidity">function toggleTax(bool _state) external onlyRole(GOVERNOR_ROLE) {
    _state == true ? _taxon() : _taxoff();
    emit TaxStateUpdated({state: _state});
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_state == true ? _taxon() : _taxoff()</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function getOrderInfo(bool _isBuyOrder, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.buyOrders[_price][_number].client;
            _amount = sCVars.buyOrders[_price][_number].amount;
            _orderId = sCVars.buyOrders[_price][_number].orderId;
        }
        else {
            _address = sCVars.sellOrders[_price][_number].client;
            _amount = sCVars.sellOrders[_price][_number].amount;
            _orderId = sCVars.sellOrders[_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac805a5b0ebe11cafa0c16f16931248f99148af5">0xac805a5b0ebe11cafa0c16f16931248f99148af5</a></p>
<pre><code class="language-solidity">function getStockOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.stockBuyOrders[_node][_price][_number].client;
            _amount = sCVars.stockBuyOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockBuyOrders[_node][_price][_number].orderId;
        }
        else {
            _address = sCVars.stockSellOrders[_node][_price][_number].client;
            _amount = sCVars.stockSellOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockSellOrders[_node][_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : RebaserV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x358660c720cf0303e6210651ffbbb25fadd92c5e">0x358660c720cf0303e6210651ffbbb25fadd92c5e</a></p>
<pre><code class="language-solidity">function claimFee (uint256 amount, bool max, bool receiveFlip, uint256 operatorId) external {
        address manager;
        address feeRecipient;
        uint256 pendingFee = operators[operatorId].pendingFee;
        (manager,feeRecipient) = wrappedOutputProxy.getOperatorAddresses(operatorId);

        if (max == false &amp;&amp; amount &gt; pendingFee) revert ExcessiveFeeClaim();
        if (msg.sender != feeRecipient &amp;&amp; msg.sender != manager) revert NotFeeRecipientOrManager();

        uint256 amountToClaim = max ? pendingFee : amount;

        operators[operatorId].pendingFee -= SafeCast.toUint80(amountToClaim);
        totalOperatorPendingFee -= SafeCast.toUint80(amountToClaim);

        if (receiveFlip == true) {
            flip.transferFrom(address(wrappedOutputProxy), msg.sender, amountToClaim);
        } else {
            stflip.mint(msg.sender, amountToClaim);
        }

        emit FeeClaim(msg.sender, amountToClaim, receiveFlip, operatorId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>receiveFlip == true</code></p>
<hr />
<h3>Contract : RebaserV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x358660c720cf0303e6210651ffbbb25fadd92c5e">0x358660c720cf0303e6210651ffbbb25fadd92c5e</a></p>
<pre><code class="language-solidity">function claimFee (uint256 amount, bool max, bool receiveFlip, uint256 operatorId) external {
        address manager;
        address feeRecipient;
        uint256 pendingFee = operators[operatorId].pendingFee;
        (manager,feeRecipient) = wrappedOutputProxy.getOperatorAddresses(operatorId);

        if (max == false &amp;&amp; amount &gt; pendingFee) revert ExcessiveFeeClaim();
        if (msg.sender != feeRecipient &amp;&amp; msg.sender != manager) revert NotFeeRecipientOrManager();

        uint256 amountToClaim = max ? pendingFee : amount;

        operators[operatorId].pendingFee -= SafeCast.toUint80(amountToClaim);
        totalOperatorPendingFee -= SafeCast.toUint80(amountToClaim);

        if (receiveFlip == true) {
            flip.transferFrom(address(wrappedOutputProxy), msg.sender, amountToClaim);
        } else {
            stflip.mint(msg.sender, amountToClaim);
        }

        emit FeeClaim(msg.sender, amountToClaim, receiveFlip, operatorId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>receiveFlip == true</code></p>
<hr />
<h3>Contract : RebaserV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x358660c720cf0303e6210651ffbbb25fadd92c5e">0x358660c720cf0303e6210651ffbbb25fadd92c5e</a></p>
<pre><code class="language-solidity">function claimServiceFee(uint256 amount, bool max, bool receiveFlip) external onlyRole(FEE_RECIPIENT_ROLE) {
        if (max == false &amp;&amp; amount &gt; servicePendingFee) revert ExcessiveFeeClaim();

        uint256 amountToClaim = max ? servicePendingFee : amount;

        servicePendingFee -= SafeCast.toUint80(amountToClaim);

        if (receiveFlip == true) {
            flip.transferFrom(address(wrappedOutputProxy), msg.sender, amountToClaim);
        } else {
            stflip.mint(msg.sender, amountToClaim);
        }

        emit FeeClaim(msg.sender, amountToClaim, receiveFlip, 0); // consider putting service Fee under operator id zero. consider implications though since all validators will have operator id of zero by default. 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>receiveFlip == true</code></p>
<hr />
<h3>Contract : RebaserV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x358660c720cf0303e6210651ffbbb25fadd92c5e">0x358660c720cf0303e6210651ffbbb25fadd92c5e</a></p>
<pre><code class="language-solidity">function claimServiceFee(uint256 amount, bool max, bool receiveFlip) external onlyRole(FEE_RECIPIENT_ROLE) {
        if (max == false &amp;&amp; amount &gt; servicePendingFee) revert ExcessiveFeeClaim();

        uint256 amountToClaim = max ? servicePendingFee : amount;

        servicePendingFee -= SafeCast.toUint80(amountToClaim);

        if (receiveFlip == true) {
            flip.transferFrom(address(wrappedOutputProxy), msg.sender, amountToClaim);
        } else {
            stflip.mint(msg.sender, amountToClaim);
        }

        emit FeeClaim(msg.sender, amountToClaim, receiveFlip, 0); // consider putting service Fee under operator id zero. consider implications though since all validators will have operator id of zero by default. 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>receiveFlip == true</code></p>
<hr />
<h3>Contract : RafldexV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x77b5475c07c9d430eb81c0871d4de74d5e839d96">0x77b5475c07c9d430eb81c0871d4de74d5e839d96</a></p>
<pre><code class="language-solidity">function giveorRemoveSubscriptionTo(
        address[] memory _addresses,
        bool _isSubscriber
    ) external onlyRole(OPERATOR_ROLE, msg.sender) {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            Subscribers[_addresses[i]] = _isSubscriber;
            if (_isSubscriber == true) {
                emit GotSubscription(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSubscriber == true</code></p>
<hr />
<h3>Contract : RafldexV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x77b5475c07c9d430eb81c0871d4de74d5e839d96">0x77b5475c07c9d430eb81c0871d4de74d5e839d96</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : RafldexV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x77b5475c07c9d430eb81c0871d4de74d5e839d96">0x77b5475c07c9d430eb81c0871d4de74d5e839d96</a></p>
<pre><code class="language-solidity">function blacklistAddressOrNot(address _address, bool _isBlacklist)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        BlacklistAddresses[_address] = _isBlacklist;
        if (_isBlacklist == true) {
            emit UserBlacklisted(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBlacklist == true</code></p>
<hr />
<h3>Contract : MetaNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x038238c141dfe7ba37cae4d96eba7ee70f9288af">0x038238c141dfe7ba37cae4d96eba7ee70f9288af</a></p>
<pre><code class="language-solidity">function setIsWl(bool _flag) public  {
        isWl = _flag;
        if (_flag == true) {
            isSale = false;
        } else {
            isSale = true;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_flag == true</code></p>
<hr />
<h3>Contract : MetaNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x038238c141dfe7ba37cae4d96eba7ee70f9288af">0x038238c141dfe7ba37cae4d96eba7ee70f9288af</a></p>
<pre><code class="language-solidity">function setIsSale(bool _flag) public  {
         if (_flag == true) {
            isWl = false;
        } else {
            isWl = true;
        }
        isSale = _flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_flag == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa24783c07cdd995c56c1d33ce485e6ac39e0c018">0xa24783c07cdd995c56c1d33ce485e6ac39e0c018</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x395cb0c7bf2808a11200a9018c98b2839f45c6f9">0x395cb0c7bf2808a11200a9018c98b2839f45c6f9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x395cb0c7bf2808a11200a9018c98b2839f45c6f9">0x395cb0c7bf2808a11200a9018c98b2839f45c6f9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x395cb0c7bf2808a11200a9018c98b2839f45c6f9">0x395cb0c7bf2808a11200a9018c98b2839f45c6f9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x395cb0c7bf2808a11200a9018c98b2839f45c6f9">0x395cb0c7bf2808a11200a9018c98b2839f45c6f9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : MarsGenesisWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0041c57d18aa185bd25e8f323e2ed0f2cf84b02f">0x0041c57d18aa185bd25e8f323e2ed0f2cf84b02f</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : P2pEth2Depositor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x25eb1d95a12c1466ab1efae63730f1cb24faca0b">0x25eb1d95a12c1466ab1efae63730f1cb24faca0b</a></p>
<pre><code class="language-solidity">constructor(bool mainnet, address depositContract_) {
        if (mainnet == true) {
            depositContract = IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa);
        } else if (depositContract_ == 0x0000000000000000000000000000000000000000) {
            depositContract = IDepositContract(0x8c5fecdC472E27Bc447696F431E425D02dd46a8c);
        } else {
            depositContract = IDepositContract(depositContract_);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mainnet == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyFEIArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x987c2661d7f6928538aa1bf66d48d48539e6c13f">0x987c2661d7f6928538aa1bf66d48d48539e6c13f</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyFEIArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x987c2661d7f6928538aa1bf66d48d48539e6c13f">0x987c2661d7f6928538aa1bf66d48d48539e6c13f</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                uint256 buyID = getCheaperToken();
                checkAndSwapTokens(address(0), buyID, false);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrder(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrder(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : AVEC</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc2425d3017672ebef0aac0229efc20c8506f4089">0xc2425d3017672ebef0aac0229efc20c8506f4089</a></p>
<pre><code class="language-solidity">function founderDeveloperMintAVEC(uint256 _founderDeveloperFee, address _toAddress, address _holdOne, address _holdTwo, address _holdThree,

        uint256 _propertyValue, bytes32 _propertyUniqueID, bytes32 _mintingRequestUniqueid, bool _globalReplacement)

        public

        onlyFounderDevelopers(msg.sender)

    {

        uint256 _amountOfTokens 
        = (_propertyValue * 1e18) / 100;

        if(_propertyValue == propertyvalue_[propertyOwner_[_propertyUniqueID]][_propertyUniqueID] &amp;&amp; _globalReplacement == false){

        // data setup

            require(members_[_toAddress] == true 

            &amp;&amp; _founderDeveloperFee &gt;= 20001 

            &amp;&amp; _founderDeveloperFee &lt;= 100000 

            &amp;&amp; msg.sender != _toAddress 

            &amp;&amp; _propertyUniqueID == workingPropertyid_[msg.sender]

            &amp;&amp; _mintingRequestUniqueid == workingMintRequestid_[msg.sender]);

            // add tokens to the pool

            updateHoldsandSupply(_amountOfTokens);

            // add to burner stockpile

            tokenBalanceLedger_[whoaaddress_] 
            = tokenBalanceLedger_[whoaaddress_] + (_amountOfTokens / 50);

            // credit founder developer fee

            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][msg.sender] += (_amountOfTokens * 1000) / _founderDeveloperFee;

            tokenBalanceLedger_[msg.sender] 
            = tokenBalanceLedger_[msg.sender] + (_amountOfTokens * 1000) / _founderDeveloperFee;

            //credit Envelope Fee Shareholds

            creditFeeSharehold(_amountOfTokens, _toAddress, _holdOne, _holdTwo, _holdThree);

            // credit tech feeSharehold_    ;

            uint256 _techFee 
            = (_amountOfTokens * 100) / 25000;

            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][techaddress_] 
            += _techFee;

            propertyvalue_[whoaaddress_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] 
            += (_amountOfTokens * 100000000000) / 1111234581620;

            tokenBalanceLedger_[techaddress_] 
            = tokenBalanceLedger_[techaddress_] + _techFee;

            uint256 _whoaFees 
            = (_amountOfTokens * 100000000000000) / 2500000000000625;

            uint256 _fee 
            = (_amountOfTokens * (1000 * 100000)) / (_founderDeveloperFee * 100000);

            // add tokens to the _toAddress

            propertyBalanceLedger_[_propertyUniqueID][_toAddress] 
            = propertyBalanceLedger_[_propertyUniqueID][_toAddress] + ((_amountOfTokens - _whoaFees)- _fee);

            tokenBalanceLedger_[_toAddress] 
            = tokenBalanceLedger_[_toAddress] + ((_amountOfTokens - _whoaFees)- _fee);

            mintingDepositsOf_[_toAddress] 
            += ((_amountOfTokens - _whoaFees)- _fee);

            propertyGlobalBalance_[_propertyUniqueID] 
            = _whoaFees;

            // whoa fee

            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][whoaaddress_] 
            += _whoaFees - _techFee;

            // fire event

            emit Transfer(msg.sender, _toAddress, _amountOfTokens);

        } else if(_globalReplacement == true &amp;&amp; ceva_[msg.sender] == true){

            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][whoaaddress_] 
            += _amountOfTokens;

            propertyvalue_[whoaaddress_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] 
            += _amountOfTokens;

            tokenBalanceLedger_[whoaaddress_] 
            += _amountOfTokens;

            // fire event

            emit Transfer(msg.sender, whoaaddress_, _amountOfTokens);

        } else {

            // fire event

            _amountOfTokens 
            = 0;

            emit Transfer(msg.sender, _toAddress, _amountOfTokens);

        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_globalReplacement == true &amp;&amp; ceva_[msg.sender] == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2070538c8efdd3c003170f6fc6d26b4a58ab599e">0x2070538c8efdd3c003170f6fc6d26b4a58ab599e</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : SoulzStakingV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5e6f677bd716f46a2ebe3a3c06514e95bb43312c">0x5e6f677bd716f46a2ebe3a3c06514e95bb43312c</a></p>
<pre><code class="language-solidity">function endStaking(bool _isEnded) public onlyRole(DEFAULT_ADMIN_ROLE) {
        hasEnded = _isEnded;
        endTimestamp = _isEnded == true ? block.timestamp : 0;
        emit StakingEnded(endTimestamp);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>endTimestamp = _isEnded == true ? block.timestamp : 0</code></p>
<hr />
<h3>Contract : TeamAdmin</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x877e5dcd61e8f2ee72f268012484fe92ca1fff31">0x877e5dcd61e8f2ee72f268012484fe92ca1fff31</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev) public onlyDevs() {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : FMTAToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaa9d866666c2a3748d6b23ff69e63e52f08d9ab4">0xaa9d866666c2a3748d6b23ff69e63e52f08d9ab4</a></p>
<pre><code class="language-solidity">function setPaused(bool _paused) external {
        require(hasRole(_ADMIN, msg.sender),&quot;Fundamenta: Message Sender must be _ADMIN&quot;);
        paused = _paused;
        if (_paused == true) {
            emit ContractPaused (block.number, msg.sender);
        } else if (_paused == false) {
            emit ContractUnpaused (block.number, msg.sender);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_paused == true</code></p>
<hr />
<h3>Contract : FMTAToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaa9d866666c2a3748d6b23ff69e63e52f08d9ab4">0xaa9d866666c2a3748d6b23ff69e63e52f08d9ab4</a></p>
<pre><code class="language-solidity">function disableMint(bool _disableMinting) external {
        require(hasRole(_ADMIN, msg.sender),&quot;Fundamenta: Message Sender must be _ADMIN&quot;);
        mintDisabled = _disableMinting;
        if (_disableMinting == true){
            emit MintingDisabled (block.number, msg.sender);
        }  else if (_disableMinting == false) {
            emit MintingEnabled (block.number, msg.sender);
        }  
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_disableMinting == true</code></p>
<hr />
<h3>Contract : FMTAToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaa9d866666c2a3748d6b23ff69e63e52f08d9ab4">0xaa9d866666c2a3748d6b23ff69e63e52f08d9ab4</a></p>
<pre><code class="language-solidity">function disableMintTo(bool _disableMintTo) external {
        require(hasRole(_ADMIN, msg.sender),&quot;Fundamenta: Message Sender must be _ADMIN&quot;);
        mintToDisabled = _disableMintTo;
        if (_disableMintTo == true) {
            emit MintingToDisabled (block.number, msg.sender);
        } else if (_disableMintTo == false) {
            emit MintingToEnabled (block.number, msg.sender);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_disableMintTo == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x958fc0a91622a2c7ce8981d2f3f1f9d6d85055a7">0x958fc0a91622a2c7ce8981d2f3f1f9d6d85055a7</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x958fc0a91622a2c7ce8981d2f3f1f9d6d85055a7">0x958fc0a91622a2c7ce8981d2f3f1f9d6d85055a7</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : TrumpBet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xae4beca8513866e0fd8f7dc397a69155f0f97f82">0xae4beca8513866e0fd8f7dc397a69155f0f97f82</a></p>
<pre><code class="language-solidity">function betTrump(uint _amount, bool _opinion) public payable whenNotPaused{
        require(msg.value &gt;= _amount);
        require(_amount &gt;= minBet &amp;&amp; _amount &lt;= maxBet); 
        uint currentFactor = _calculateTimeFactor();
        if(PlayerIfBet[msg.sender] = false) {
            if(_opinion == true){
                Bet memory _bet = Bet({
                    posAmount: _amount,
                    negAmount: 0,
                    timestamp: currentFactor
                });
                PlayerToBet[msg.sender] = _bet;
            } else {
                Bet memory _bet = Bet({
                    posAmount: 0,
                    negAmount: _amount,
                    timestamp: currentFactor
                });
                PlayerToBet[msg.sender] = _bet;
            }
            TotalPlayers += 1;
            PlayerIfBet[msg.sender] = true;
            emit NewBetSuccess(msg.sender, _opinion, _amount, currentFactor);
        } else {
            Bet storage _bet = PlayerToBet[msg.sender];
            if(_opinion == true){
                _bet.posAmount += _amount;
            } else {
               _bet.negAmount += _amount;
            }
            _bet.timestamp = _calculateTimeFactor();
            emit BetAdjustSuccess(msg.sender, _bet.posAmount, _bet.negAmount, currentFactor);
        }
        TotalAmount += _amount;
        if(_opinion == true){
            TotalSupport += _amount;
        } else {
            TotalOppose += _amount;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_opinion == true</code></p>
<hr />
<h3>Contract : TrumpBet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xae4beca8513866e0fd8f7dc397a69155f0f97f82">0xae4beca8513866e0fd8f7dc397a69155f0f97f82</a></p>
<pre><code class="language-solidity">function betTrump(uint _amount, bool _opinion) public payable whenNotPaused{
        require(msg.value &gt;= _amount);
        require(_amount &gt;= minBet &amp;&amp; _amount &lt;= maxBet); 
        uint currentFactor = _calculateTimeFactor();
        if(PlayerIfBet[msg.sender] = false) {
            if(_opinion == true){
                Bet memory _bet = Bet({
                    posAmount: _amount,
                    negAmount: 0,
                    timestamp: currentFactor
                });
                PlayerToBet[msg.sender] = _bet;
            } else {
                Bet memory _bet = Bet({
                    posAmount: 0,
                    negAmount: _amount,
                    timestamp: currentFactor
                });
                PlayerToBet[msg.sender] = _bet;
            }
            TotalPlayers += 1;
            PlayerIfBet[msg.sender] = true;
            emit NewBetSuccess(msg.sender, _opinion, _amount, currentFactor);
        } else {
            Bet storage _bet = PlayerToBet[msg.sender];
            if(_opinion == true){
                _bet.posAmount += _amount;
            } else {
               _bet.negAmount += _amount;
            }
            _bet.timestamp = _calculateTimeFactor();
            emit BetAdjustSuccess(msg.sender, _bet.posAmount, _bet.negAmount, currentFactor);
        }
        TotalAmount += _amount;
        if(_opinion == true){
            TotalSupport += _amount;
        } else {
            TotalOppose += _amount;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_opinion == true</code></p>
<hr />
<h3>Contract : TrumpBet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xae4beca8513866e0fd8f7dc397a69155f0f97f82">0xae4beca8513866e0fd8f7dc397a69155f0f97f82</a></p>
<pre><code class="language-solidity">function betTrump(uint _amount, bool _opinion) public payable whenNotPaused{
        require(msg.value &gt;= _amount);
        require(_amount &gt;= minBet &amp;&amp; _amount &lt;= maxBet); 
        uint currentFactor = _calculateTimeFactor();
        if(PlayerIfBet[msg.sender] = false) {
            if(_opinion == true){
                Bet memory _bet = Bet({
                    posAmount: _amount,
                    negAmount: 0,
                    timestamp: currentFactor
                });
                PlayerToBet[msg.sender] = _bet;
            } else {
                Bet memory _bet = Bet({
                    posAmount: 0,
                    negAmount: _amount,
                    timestamp: currentFactor
                });
                PlayerToBet[msg.sender] = _bet;
            }
            TotalPlayers += 1;
            PlayerIfBet[msg.sender] = true;
            emit NewBetSuccess(msg.sender, _opinion, _amount, currentFactor);
        } else {
            Bet storage _bet = PlayerToBet[msg.sender];
            if(_opinion == true){
                _bet.posAmount += _amount;
            } else {
               _bet.negAmount += _amount;
            }
            _bet.timestamp = _calculateTimeFactor();
            emit BetAdjustSuccess(msg.sender, _bet.posAmount, _bet.negAmount, currentFactor);
        }
        TotalAmount += _amount;
        if(_opinion == true){
            TotalSupport += _amount;
        } else {
            TotalOppose += _amount;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_opinion == true</code></p>
<hr />
<h3>Contract : TrumpBet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xae4beca8513866e0fd8f7dc397a69155f0f97f82">0xae4beca8513866e0fd8f7dc397a69155f0f97f82</a></p>
<pre><code class="language-solidity">function offlineBet(uint _amount, bool _opinion) public whenNotPaused onlyAdmin {
        TotalAmount += _amount;
        TotalPlayers += 1;
        if(_opinion == true){
            TotalSupport += _amount;
        } else {
            TotalOppose += _amount;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_opinion == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaeb46c8e98179783cb11722be4fe221dffc9bb85">0xaeb46c8e98179783cb11722be4fe221dffc9bb85</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaeb46c8e98179783cb11722be4fe221dffc9bb85">0xaeb46c8e98179783cb11722be4fe221dffc9bb85</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea26dbaa52585c4bd454dc460c83681355a3c">0xcafea26dbaa52585c4bd454dc460c83681355a3c</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : RafldexV2_5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x98595a2d70fe2241260d9af89db59af150f044a7">0x98595a2d70fe2241260d9af89db59af150f044a7</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : INbusinesscard</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x551c9fdf1ee7468cc5a1eff341ae228d3a245eb2">0x551c9fdf1ee7468cc5a1eff341ae228d3a245eb2</a></p>
<pre><code class="language-solidity">function setApprovalForAll(address approvedAddr, bool _approved) external returns (bool) {
        require(approvedAddr != address(0),&quot;No delagating to 0!&quot;);
        if(_approved == true) {
            allApprovals[msg.sender][approvedAddr] = true;
        } else {
            if(allApprovals[msg.sender][approvedAddr] ) delete allApprovals[msg.sender][approvedAddr];
        }
        emit ApprovalForAll(msg.sender, approvedAddr, _approved);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approved == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd739a5fa926168aa57ff4a15aa2ad0655246c500">0xd739a5fa926168aa57ff4a15aa2ad0655246c500</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd739a5fa926168aa57ff4a15aa2ad0655246c500">0xd739a5fa926168aa57ff4a15aa2ad0655246c500</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Communis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a9780bfe63f3ec57f01b087cd65bd656c9034a8">0x5a9780bfe63f3ec57f01b087cd65bd656c9034a8</a></p>
<pre><code class="language-solidity">function getStartBonusPayout(uint256 stakedDays, uint256 lockedDay, uint256 maxPayout, uint256 stakesOriginalShareRate, uint256 currentDay, uint256 globalShareRate, bool applyRestakeBonus)
        public pure
        returns (uint256 payout)
    {
        uint256 bonusPercentage;

        if(applyRestakeBonus == true) {
            bonusPercentage = (((stakedDays - 365) * (10 ** 10)) / 5190);
            bonusPercentage = ((3 * (10 ** 10)) * bonusPercentage) / (10 ** 10);
            bonusPercentage = (5 * (10 ** 10)) - bonusPercentage;
        }
        else if (stakedDays &gt; 364) {
            bonusPercentage = ((stakedDays - 365) * (10 ** 10)) / 5190;
            bonusPercentage = ((6 * (10 ** 10)) * bonusPercentage) / (10 ** 10);
            bonusPercentage = (10 * (10 ** 10)) - bonusPercentage;
        }
        else {
            bonusPercentage = ((stakedDays - 180) * (10 ** 10)) / 185;
            bonusPercentage = ((10 * (10 ** 10)) * bonusPercentage) / (10 ** 10);
            bonusPercentage = (20 * (10 ** 10)) - bonusPercentage;
        }

        payout = (maxPayout * (10 ** 10)) / bonusPercentage;

        if(currentDay != lockedDay) {
            uint256 penalty = (stakesOriginalShareRate * (10 ** 15)) / globalShareRate;
            payout = (payout * penalty) / (10 ** 15);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>applyRestakeBonus == true</code></p>
<hr />
<h3>Contract : ResponsibleCrowdsale</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6c40878a5e53d893e979e5d45a64d9bbf884b31e">0x6c40878a5e53d893e979e5d45a64d9bbf884b31e</a></p>
<pre><code class="language-solidity">function solveDispute(bytes32 hash, address investor, bool investorWins) external onlyCluster {
        require(isMilestoneHasActiveDisputes(hash) == true, &quot;solveDispute: no active disputs available.&quot;);

        if (investorWins == true) {
            _milestoneDetails[hash].disputes.investorDispute[investor] = InvestorDisputeState.WINNED;
            _milestoneDetails[hash].disputes.winnedAddressList.push(investor);
        } else {
            _milestoneDetails[hash].disputes.investorDispute[investor] = InvestorDisputeState.CLOSED;
        }

        _milestoneDetails[hash].disputes.activeDisputes--;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>investorWins == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad250d4e6fda4679d59392650e646c366e2df616">0xad250d4e6fda4679d59392650e646c366e2df616</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            stakerStorage.getStaker(msg.sender).stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        // Calculate staking rewards
        uint256 stakingRewards = calcStakingRewards(msg.sender);

        // Only claim interest if staking rewards are less than or equal to the staking rewards pool
        if (stakingRewards &lt;= stakingRewardsPool) {
            _claimInterest();
        }

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }
        //get the current staker details
        MkongStaker.Staker memory currentStaker = stakerStorage.getStaker(
            msg.sender
        );
        currentStaker.stakedBalance = currentStaker.stakedBalance.sub(_amount);
        currentStaker.lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transferMkong(address(this), msg.sender, emerAmt);
            _burnMkong(msg.sender, fee);
            //save updated staker details
            stakerStorage.setStaker(msg.sender, currentStaker);
            totalStaked = totalStaked.sub(_amount);
            return;
        }

        currentStaker.unstakeStartTime = block.timestamp;
        currentStaker.pendingAmount = currentStaker.pendingAmount + outAmount;

        //save updated staker details
        stakerStorage.setStaker(msg.sender, currentStaker);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad250d4e6fda4679d59392650e646c366e2df616">0xad250d4e6fda4679d59392650e646c366e2df616</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            stakerStorage.getStaker(msg.sender).stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        // Calculate staking rewards
        uint256 stakingRewards = calcStakingRewards(msg.sender);

        // Only claim interest if staking rewards are less than or equal to the staking rewards pool
        if (stakingRewards &lt;= stakingRewardsPool) {
            _claimInterest();
        }

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }
        //get the current staker details
        MkongStaker.Staker memory currentStaker = stakerStorage.getStaker(
            msg.sender
        );
        currentStaker.stakedBalance = currentStaker.stakedBalance.sub(_amount);
        currentStaker.lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transferMkong(address(this), msg.sender, emerAmt);
            _burnMkong(msg.sender, fee);
            //save updated staker details
            stakerStorage.setStaker(msg.sender, currentStaker);
            totalStaked = totalStaked.sub(_amount);
            return;
        }

        currentStaker.unstakeStartTime = block.timestamp;
        currentStaker.pendingAmount = currentStaker.pendingAmount + outAmount;

        //save updated staker details
        stakerStorage.setStaker(msg.sender, currentStaker);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : LendingPoolConfigurator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d3e89b0c8b42be85fd9cf875579f72d03a0d93b">0x9d3e89b0c8b42be85fd9cf875579f72d03a0d93b</a></p>
<pre><code class="language-solidity">function enableReserveForInvoicePool(address _reserve, bool _enable) external onlyLendingPoolManager {
        require(_reserve != address(0x0), &quot;reserve address is invalid&quot;);
        if(_enable == true) {
            require(isInvoiceReserve[_reserve] == false, &quot;reserve is already been enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = true;
        } else {
            require(isInvoiceReserve[_reserve] == true, &quot;reserve is not enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enable == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xffab07b27cc8cb8a4aef9eb3a4b1be4484eeaa3c">0xffab07b27cc8cb8a4aef9eb3a4b1be4484eeaa3c</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + hightLightFee);
                } else {
                    require(msg.value == limitETHFee + hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xffab07b27cc8cb8a4aef9eb3a4b1be4484eeaa3c">0xffab07b27cc8cb8a4aef9eb3a4b1be4484eeaa3c</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x30ac79b557973771c931d8d765e0728261a742a0">0x30ac79b557973771c931d8d765e0728261a742a0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x30ac79b557973771c931d8d765e0728261a742a0">0x30ac79b557973771c931d8d765e0728261a742a0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x30ac79b557973771c931d8d765e0728261a742a0">0x30ac79b557973771c931d8d765e0728261a742a0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x30ac79b557973771c931d8d765e0728261a742a0">0x30ac79b557973771c931d8d765e0728261a742a0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe8e2c9eca840fc8b68f4df93b996368a13297748">0xe8e2c9eca840fc8b68f4df93b996368a13297748</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe8e2c9eca840fc8b68f4df93b996368a13297748">0xe8e2c9eca840fc8b68f4df93b996368a13297748</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function getOrderInfo(bool _isBuyOrder, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.buyOrders[_price][_number].client;
            _amount = sCVars.buyOrders[_price][_number].amount;
            _orderId = sCVars.buyOrders[_price][_number].orderId;
        }
        else {
            _address = sCVars.sellOrders[_price][_number].client;
            _amount = sCVars.sellOrders[_price][_number].amount;
            _orderId = sCVars.sellOrders[_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x13546361e6b7f65a1495a102f80a8a2e543cf10a">0x13546361e6b7f65a1495a102f80a8a2e543cf10a</a></p>
<pre><code class="language-solidity">function getStockOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.stockBuyOrders[_node][_price][_number].client;
            _amount = sCVars.stockBuyOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockBuyOrders[_node][_price][_number].orderId;
        }
        else {
            _address = sCVars.stockSellOrders[_node][_price][_number].client;
            _amount = sCVars.stockSellOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockSellOrders[_node][_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe12ea11795c5136db1c79d25d368100630337397">0xe12ea11795c5136db1c79d25d368100630337397</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + hightLightFee);
                } else {
                    require(msg.value == limitETHFee + hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe12ea11795c5136db1c79d25d368100630337397">0xe12ea11795c5136db1c79d25d368100630337397</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : subscription</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7a77313334e663f4fb4e9da04b66c0a1ab11e60d">0x7a77313334e663f4fb4e9da04b66c0a1ab11e60d</a></p>
<pre><code class="language-solidity">function payUSDC(string memory _id, bool _world ) external returns(bool) {
        address to;
        if (_world == true) {to = forward;} else if (_world == false) {to = forwardUSA;} else {revert();}
        IERC20(USDC).transferFrom(msg.sender, to, priceStable);
        emit Payment(&quot;USDC&quot;, priceStable, _id, msg.sender, to);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_world == true</code></p>
<hr />
<h3>Contract : subscription</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7a77313334e663f4fb4e9da04b66c0a1ab11e60d">0x7a77313334e663f4fb4e9da04b66c0a1ab11e60d</a></p>
<pre><code class="language-solidity">function payUSDT(string memory _id, bool _world) external returns(bool) {
        address to;
        if (_world == true) {to = forward;} else if (_world == false) {to = forwardUSA;} else {revert();}
        IERC20(USDT).transferFrom(msg.sender, to, priceStable);
        emit Payment(&quot;USDT&quot;, priceStable, _id, msg.sender, to);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_world == true</code></p>
<hr />
<h3>Contract : subscription</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7a77313334e663f4fb4e9da04b66c0a1ab11e60d">0x7a77313334e663f4fb4e9da04b66c0a1ab11e60d</a></p>
<pre><code class="language-solidity">function payETH(string memory _id, bool _world) external payable returns(bool) {
        address to;
        if (_world == true) {to = forward;} else if (_world == false) {to = forwardUSA;} else {revert();}
        require(msg.value &gt;= priceETH, &quot;Dev: invalid amount&quot;);
        (bool sent, bytes memory data) = to.call{value: msg.value}(&quot;&quot;);
        require(sent, &quot;Dev: Ether payment error&quot;);
        emit Payment(&quot;ETH&quot;, msg.value, _id, msg.sender, to);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_world == true</code></p>
<hr />
<h3>Contract : SingleAsssetAddLiquidity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x791ca4e3b1ddf69bb7635684e1fb50f0bc0fc917">0x791ca4e3b1ddf69bb7635684e1fb50f0bc0fc917</a></p>
<pre><code class="language-solidity">function withdrawSupplyAsOtherSingleAsset( address receiveToken , address liquidityToken ,address tokenA,address tokenB, address payable to,uint amount, address[] calldata path1, address[] calldata path2, bool toReceiveWNative,uint minOut) external {
      require(path1[path1.length - 1] == path2[path2.length -1] , 'Needs to be same token ');
      IERC20(liquidityToken).safeTransferFrom(msg.sender,address(this), amount);
      IERC20(liquidityToken).safeApprove(router, 0);  
      IERC20(liquidityToken).safeApprove(router, amount);      
      UnifiRouter(router).removeLiquidity(
          tokenA, 
          tokenB, 
          amount, 
          1, 
          1, 
          address(this), 
          now.add(1800)
        );
        _convertOtherToken(IERC20(tokenA).balanceOf(address(this)),path1, minOut);
        _convertOtherToken(IERC20(tokenB).balanceOf(address(this)),path2, minOut);           

        uint receivingTokenBalance = IERC20(receiveToken).balanceOf(address(this));
        if(address(receiveToken) == address(wETH) &amp;&amp; toReceiveWNative == true){
            IERC20(wETH).safeApprove(router,0 );
            IERC20(wETH).safeApprove(router,receivingTokenBalance );
              IWETH(wETH).withdraw(receivingTokenBalance);
                address(to).transfer(receivingTokenBalance);              
        }else{

        }
        IERC20(receiveToken).safeTransfer(address(to),receivingTokenBalance);       

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>address(receiveToken) == address(wETH) &amp;&amp; toReceiveWNative == true</code></p>
<hr />
<h3>Contract : AddressesGeneratorV1Vaults</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xce29d34c8e88a2e1edde10ad4eee4f3e379fc041">0xce29d34c8e88a2e1edde10ad4eee4f3e379fc041</a></p>
<pre><code class="language-solidity">function setAssetDeprecated(address assetAddress, bool newDeprecationStatus)
        public
        onlyManagers
    {
        bool currentDeprecationStatus = assetDeprecated[assetAddress];
        if (currentDeprecationStatus == newDeprecationStatus) {
            revert(&quot;Generator: Unable to change asset deprecation status&quot;);
        }
        if (newDeprecationStatus == true) {
            numberOfDeprecatedAssets++;
        } else {
            numberOfDeprecatedAssets--;
        }
        assetDeprecated[assetAddress] = newDeprecationStatus;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>newDeprecationStatus == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xafa331ecf4a3b8a83d36ad83dae69550c3ddb589">0xafa331ecf4a3b8a83d36ad83dae69550c3ddb589</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : APECULT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0552ebb8bc9f441f396a47c391ba9737eb883d06">0x0552ebb8bc9f441f396a47c391ba9737eb883d06</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : MultiSigWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xddd55deabc5451b32bab4a275226991388888888">0xddd55deabc5451b32bab4a275226991388888888</a></p>
<pre><code class="language-solidity">function signTransaction(uint transactionId, bool isCall) public isManager{
        Transaction storage transaction = transactions[transactionId];

        Transaction storage txn = transactions[transactionId];

        require(0x0 != transaction.from);
        require(msg.sender != transaction.from,&quot;sender  dont need&quot;);
        require(transaction.signatures[msg.sender]!=1,&quot;signed yet&quot;);
        transaction.signatures[msg.sender] = 1;
        transaction.signatureCount++;


        if(transaction.signatureCount &gt;= MIN_SIGNATURES &amp;&amp; isCall == false ){
            //require(address(this).balance &gt;= transaction.amount);
            //address(uint160((transaction.to))).transfer(transaction.amount);

            //bytes4 callid=bytes4(keccak256(&quot;transferFrom(address,address,uint256)&quot;));
            bytes4 callid=bytes4(keccak256(&quot;transfer(address,uint256)&quot;));
            transaction.token.call(callid,transaction.to,transaction.amount);

            emit TransferFunds(transaction.token,transaction.to, transaction.amount);
            transaction.executed=true;
        }


         if(transaction.signatureCount &gt;= MIN_SIGNATURES &amp;&amp; isCall == true ){

            if (external_call(txn.to, txn.amount, txn.data.length, txn.data)) {

            //if (transaction.to.call(bytes4(keccak256(txn.data)),transaction.from,transaction.amount)) {

                emit CallTransactions(transaction.from,transaction.amount, transaction.data);
                transaction.executed=true;
            }
            else {
                transaction.executed=false;

            }

            }


    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>transaction.signatureCount &gt;= MIN_SIGNATURES &amp;&amp; isCall == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x464904238b5cdbdce12722a7e6014ec1c0b66928">0x464904238b5cdbdce12722a7e6014ec1c0b66928</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : AssetsAccountant</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaa362fea5292988e4bfb4ffc9ec119fd2e1cc48d">0xaa362fea5292988e4bfb4ffc9ec119fd2e1cc48d</a></p>
<pre><code class="language-solidity">function allowLiquidator(address liquidator, bool allow) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (liquidator == address(0)) {
            revert AssetsAccountant_zeroAddress();
        }

        isARegisteredHouse[liquidator] = allow;

        if (allow == true) {
            _grantRole(LIQUIDATOR_ROLE, liquidator);
            _grantRole(BURNER_ROLE, liquidator);
        } else {
            _revokeRole(LIQUIDATOR_ROLE, liquidator);
            _revokeRole(BURNER_ROLE, liquidator);
        }
        emit LiquidatorAllow(liquidator, allow);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>allow == true</code></p>
<hr />
<h3>Contract : AssetsAccountant</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaa362fea5292988e4bfb4ffc9ec119fd2e1cc48d">0xaa362fea5292988e4bfb4ffc9ec119fd2e1cc48d</a></p>
<pre><code class="language-solidity">function allowReserveFactory(address factory, bool allow) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (factory == address(0)) {
            revert AssetsAccountant_zeroAddress();
        }

        isAValidReserveFactory[factory] = allow;

        if (allow == true) {
            _grantRole(DEFAULT_ADMIN_ROLE, factory);
        } else {
            _revokeRole(DEFAULT_ADMIN_ROLE, factory);
        }
        emit ReserveFactoryAllow(factory, allow);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>allow == true</code></p>
<hr />
<h3>Contract : PopCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6d6bf75c679fac718e99367b9e9015d68b8ee809">0x6d6bf75c679fac718e99367b9e9015d68b8ee809</a></p>
<pre><code class="language-solidity">function whitelistMint(
    uint256 _mintAmount,
    bool _isUSDC,
    bytes32[] calldata merkleProof
  )
    external
    payable
    whenNotPaused
    mintCompliance(_mintAmount)
    isValidMerkleProof(merkleProof, whitelistMerkleRoot)
  {
    require(isWhitelistSaleOpen, &quot;The whitelist sale is not enabled!&quot;);
    require(
      whitelistTokenCount + _mintAmount &lt;= maxWhitelistTokens,
      &quot;Max whitelist tokens exceeded&quot;
    );

    if (_isUSDC == true) {
      usdcAddress.transferFrom(
        msg.sender,
        treasuryWallet,
        (_mintAmount * (whitelistUSDCCost * 10**6))
      );
    } else {
      require(
        msg.value &gt;= (whitelistEtherCost * _mintAmount),
        &quot;Not enough ether!&quot;
      );
      (bool os, ) = payable(treasuryWallet).call{value: address(this).balance}(
        &quot;&quot;
      );
    }

    _mint(msg.sender, _mintAmount);
    whitelistMintCounts[msg.sender] += _mintAmount;
    whitelistTokenCount += _mintAmount;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isUSDC == true</code></p>
<hr />
<h3>Contract : PopCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6d6bf75c679fac718e99367b9e9015d68b8ee809">0x6d6bf75c679fac718e99367b9e9015d68b8ee809</a></p>
<pre><code class="language-solidity">function publicMint(uint256 _mintAmount, bool _isUSDC)
    external
    payable
    whenNotPaused
    mintCompliance(_mintAmount)
  {
    require(isPublicSaleOpen, &quot;The public sale is not open!&quot;);

    if (_isUSDC == true) {
      usdcAddress.transferFrom(
        msg.sender,
        treasuryWallet,
        (_mintAmount * (publicUSDCCost * 10**6))
      );
    } else {
      require(
        msg.value &gt;= (publicEtherCost * _mintAmount),
        &quot;Not enough ether!&quot;
      );
      (bool os, ) = payable(treasuryWallet).call{value: address(this).balance}(
        &quot;&quot;
      );
    }

    _mint(msg.sender, _mintAmount);
    publicMintCounts[msg.sender] += _mintAmount;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isUSDC == true</code></p>
<hr />
<h3>Contract : BabyDogger</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x26ccad2716e8ca562c1f17a495884091f44744b9">0x26ccad2716e8ca562c1f17a495884091f44744b9</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6035a65b3335fa03b1695535a1e4617731b8cff1">0x6035a65b3335fa03b1695535a1e4617731b8cff1</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6035a65b3335fa03b1695535a1e4617731b8cff1">0x6035a65b3335fa03b1695535a1e4617731b8cff1</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6035a65b3335fa03b1695535a1e4617731b8cff1">0x6035a65b3335fa03b1695535a1e4617731b8cff1</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6035a65b3335fa03b1695535a1e4617731b8cff1">0x6035a65b3335fa03b1695535a1e4617731b8cff1</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : CheckDotStakingProtocolContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe8f3f4c575c7a2c3383fa1ad570a8242c4a44e4e">0xe8f3f4c575c7a2c3383fa1ad570a8242c4a44e4e</a></p>
<pre><code class="language-solidity">function unStake(uint256 poolId, bool claim) public {
        Pool storage pool = _pools[poolId];
        Staking storage staker = pool._stakers[msg.sender];

        require(
            staker.WALLET == msg.sender,
            &quot;No stake&quot;
        );
        bool lockDurationIsExceeded = staker.START.add(86400 * pool.LOCK_DURATION_IN_DAY) &lt;= block.timestamp;
        require(
            staker.LOCKED == false || lockDurationIsExceeded,
            &quot;Stake locked&quot;
        );
        uint256 stakedAmount = pool.QUANTITY_OF_COIN_A_PER_SLOT.mul(staker.SLOTS);
        require(IERC20(pool.COIN_A).transfer(msg.sender, stakedAmount) == true,
            &quot;Balance Coin A empty&quot;
        );
        if (claim == true &amp;&amp; lockDurationIsExceeded) {
            uint256 rewardAmount = pool.QUANTITY_OF_COIN_B_REWARDABLE_PER_SLOT.mul(staker.SLOTS);

            require(IERC20(pool.COIN_B).transfer(msg.sender, rewardAmount) == true,
                &quot;Balance Coin A empty&quot;
            );
            pool.SLOTS_FINISHED += staker.SLOTS;
            pool.LIQUIDITY -= rewardAmount;
        }
        if (staker.LOCKED) {
            staker.LOCKED = false;
            pool.TVL -= stakedAmount;
        }
        pool.TSV -= stakedAmount;
        pool.SLOTS_USED -= staker.SLOTS;
        pool._stakersCount -= 1;
        staker.WALLET = 0x0000000000000000000000000000000000000000;
        staker.START = 0;
        staker.SLOTS = 0;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim == true &amp;&amp; lockDurationIsExceeded</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa2ab386ac40027b7f99e7f1e8b83b52bea6539a2">0xa2ab386ac40027b7f99e7f1e8b83b52bea6539a2</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa2ab386ac40027b7f99e7f1e8b83b52bea6539a2">0xa2ab386ac40027b7f99e7f1e8b83b52bea6539a2</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa2ab386ac40027b7f99e7f1e8b83b52bea6539a2">0xa2ab386ac40027b7f99e7f1e8b83b52bea6539a2</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : StabilizeStrategySGRArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd4b3f9ba5c576375ad48d7a75eb4b40a7c6aca63">0xd4b3f9ba5c576375ad48d7a75eb4b40a7c6aca63</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategySGRArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd4b3f9ba5c576375ad48d7a75eb4b40a7c6aca63">0xd4b3f9ba5c576375ad48d7a75eb4b40a7c6aca63</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a86742f85b513060cb72420aed38a08518915b3">0x5a86742f85b513060cb72420aed38a08518915b3</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a86742f85b513060cb72420aed38a08518915b3">0x5a86742f85b513060cb72420aed38a08518915b3</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : FigmentEth2Depositor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb4e2e925d75793c33f5f94cd652f6c464665c76b">0xb4e2e925d75793c33f5f94cd652f6c464665c76b</a></p>
<pre><code class="language-solidity">constructor(bool mainnet, address depositContract_) {
        if (mainnet == true) {
            depositContract = IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa);
        } else if (depositContract_ == 0x0000000000000000000000000000000000000000) {
            depositContract = IDepositContract(0x8c5fecdC472E27Bc447696F431E425D02dd46a8c);
        } else {
            depositContract = IDepositContract(depositContract_);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mainnet == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x060c4c34dda5b84496648c05dd2433a5f2c6ad8b">0x060c4c34dda5b84496648c05dd2433a5f2c6ad8b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x060c4c34dda5b84496648c05dd2433a5f2c6ad8b">0x060c4c34dda5b84496648c05dd2433a5f2c6ad8b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x060c4c34dda5b84496648c05dd2433a5f2c6ad8b">0x060c4c34dda5b84496648c05dd2433a5f2c6ad8b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x060c4c34dda5b84496648c05dd2433a5f2c6ad8b">0x060c4c34dda5b84496648c05dd2433a5f2c6ad8b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Balladr</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x28f26294187d5f6ce9217c56635976272a81c8e5">0x28f26294187d5f6ce9217c56635976272a81c8e5</a></p>
<pre><code class="language-solidity">function mintWrapper(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        string memory targetUri,
        uint256 maxSupply,
        bool isFrozen,
        uint256 collectionId,
        bytes memory data
    ) public {
        // Only an Authorized Contract can use this function.
        require(authorizedContracts[msg.sender] == true, &quot;Not Authorized&quot;);

        // Minting is only allowed in an opened collection
        require(isCollectionClosed[collectionId] == false, &quot;Collection is closed&quot;);

        // If Collection Owner is set, only the owner should be able to mint.
        if (collectionOwner[collectionId] != address(0)) {
          require(from == collectionOwner[collectionId], &quot;Minter is not the owner of the Collection&quot;);
        }

        // Froze the supply the first time a tokenId is minted
        if (tokenMaxSupply[id] == 0) {
            tokenMaxSupply[id] = maxSupply;
        }

        // The amount of token requested to be minted should be less than the total available supply
        require(
            (tokenMinteds[id] + amount) &lt;= tokenMaxSupply[id],
            &quot;Not enough supply&quot;
        );

        // Minting process

        // The tokenUri is set the first time the minting function is called for a given tokenId.
        if (bytes(_tokenUris[id]).length == 0) {
            _tokenUris[id] = targetUri;
        }

        // Set whether the tokenUri is frozen or not
        if (isFrozen == true) {
            if (isTokenUriFrozen[id] == false) {
                isTokenUriFrozen[id] = true;
                emit PermanentURI(targetUri, id);
            }
        }

        // Assign every Token to a CollectionId - Once per Token
        if (tokenIdToCollectionId[id] == 0) {
          tokenIdToCollectionId[id] = collectionId;
          // The first minted token from a Collection should set the Collection Owner
          if (collectionOwner[collectionId] == address(0)) {
            collectionOwner[collectionId] = from;
          }
        }

        // Increment the current minted supply
        tokenMinteds[id] += amount;

        // Call original ERC1155 function from the original token creator
        _mint(from, id, amount, data);

        // Emit the minting event
        emit Minted(from, id, amount);

        // Transfer the token from the creator the buyer
        _safeTransferFrom(from, to, id, amount, data);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isFrozen == true</code></p>
<hr />
<h3>Contract : AVEC</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa3f146632faaa92fe6dcd6b403362308bf0fca9a">0xa3f146632faaa92fe6dcd6b403362308bf0fca9a</a></p>
<pre><code class="language-solidity">function founderDeveloperMintAVEC(uint256 _founderDeveloperFee, address _toAddress, address _holdOne, address _holdTwo, address _holdThree,

        uint256 _propertyValue, bytes32 _propertyUniqueID, bytes32 _mintingRequestUniqueid, bool _globalReplacement)

        public

        onlyFounderDevelopers(msg.sender)

    {

        uint256 _amountOfTokens 
        = (_propertyValue * 1e18) / 100;

        if(_propertyValue == propertyvalue_[propertyOwner_[_propertyUniqueID]][_propertyUniqueID] &amp;&amp; _globalReplacement == false){

        // data setup

            require(members_[_toAddress] == true 

            &amp;&amp; _founderDeveloperFee &gt;= 20001 

            &amp;&amp; _founderDeveloperFee &lt;= 100000 

            &amp;&amp; msg.sender != _toAddress 

            &amp;&amp; _propertyUniqueID == workingPropertyid_[msg.sender]

            &amp;&amp; _mintingRequestUniqueid == workingMintRequestid_[msg.sender]);

            // add tokens to the pool

            updateHoldsandSupply(_amountOfTokens);

            // add to burner stockpile

            tokenBalanceLedger_[whoaaddress_] 
            = tokenBalanceLedger_[whoaaddress_] + (_amountOfTokens / 50);

            // credit founder developer fee

            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][msg.sender] += (_amountOfTokens * 1000) / _founderDeveloperFee;

            tokenBalanceLedger_[msg.sender] 
            = tokenBalanceLedger_[msg.sender] + (_amountOfTokens * 1000) / _founderDeveloperFee;

            //credit Envelope Fee Shareholds

            creditFeeSharehold(_amountOfTokens, _toAddress, _holdOne, _holdTwo, _holdThree);

            // credit tech feeSharehold_    ;

            uint256 _techFee 
            = (_amountOfTokens * 100) / 25000;

            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][techaddress_] 
            += _techFee;

            propertyvalue_[whoaaddress_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] 
            += (_amountOfTokens * 100000000000) / 1111234581620;

            tokenBalanceLedger_[techaddress_] 
            = tokenBalanceLedger_[techaddress_] + _techFee;

            uint256 _whoaFees 
            = (_amountOfTokens * 100000000000000) / 2500000000000625;

            uint256 _fee 
            = (_amountOfTokens * (1000 * 100000)) / (_founderDeveloperFee * 100000);

            // add tokens to the _toAddress

            propertyBalanceLedger_[_propertyUniqueID][_toAddress] 
            = propertyBalanceLedger_[_propertyUniqueID][_toAddress] + ((_amountOfTokens - _whoaFees)- _fee);

            tokenBalanceLedger_[_toAddress] 
            = tokenBalanceLedger_[_toAddress] + ((_amountOfTokens - _whoaFees)- _fee);

            mintingDepositsOf_[_toAddress] 
            += ((_amountOfTokens - _whoaFees)- _fee);

            propertyGlobalBalance_[_propertyUniqueID] 
            = _whoaFees;

            // whoa fee

            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][whoaaddress_] 
            += _whoaFees - _techFee;

            // fire event

            emit Transfer(msg.sender, _toAddress, _amountOfTokens);

        } else if(_globalReplacement == true &amp;&amp; ceva_[msg.sender] == true){

            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][whoaaddress_] 
            += _amountOfTokens;

            propertyvalue_[whoaaddress_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] 
            += _amountOfTokens;

            tokenBalanceLedger_[whoaaddress_] 
            += _amountOfTokens;

            // fire event

            emit Transfer(msg.sender, whoaaddress_, _amountOfTokens);

        } else {

            // fire event

            _amountOfTokens 
            = 0;

            emit Transfer(msg.sender, _toAddress, _amountOfTokens);

        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_globalReplacement == true &amp;&amp; ceva_[msg.sender] == true</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x220f93183a69d1598e8405310cb361cff504146f">0x220f93183a69d1598e8405310cb361cff504146f</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x220f93183a69d1598e8405310cb361cff504146f">0x220f93183a69d1598e8405310cb361cff504146f</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x220f93183a69d1598e8405310cb361cff504146f">0x220f93183a69d1598e8405310cb361cff504146f</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x220f93183a69d1598e8405310cb361cff504146f">0x220f93183a69d1598e8405310cb361cff504146f</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa4a4f5c5458abe04b1d4ca40a4aae5446e62cf92">0xa4a4f5c5458abe04b1d4ca40a4aae5446e62cf92</a></p>
<pre><code class="language-solidity">function increaseOrRemoveAllowances(bool what) external {
        require(msg.sender == owner);
        what == true ? IERC20(token).approve(voting_escrow, type(uint).max) : IERC20(token).approve(voting_escrow, 0);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>what == true ? IERC20(token).approve(voting_escrow, type(uint).max) : IERC20(token).approve(voting_escrow, 0)</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4301a056617cc13a1a2ab0e3caba51bfb1ab3fcb">0x4301a056617cc13a1a2ab0e3caba51bfb1ab3fcb</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4301a056617cc13a1a2ab0e3caba51bfb1ab3fcb">0x4301a056617cc13a1a2ab0e3caba51bfb1ab3fcb</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4301a056617cc13a1a2ab0e3caba51bfb1ab3fcb">0x4301a056617cc13a1a2ab0e3caba51bfb1ab3fcb</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4301a056617cc13a1a2ab0e3caba51bfb1ab3fcb">0x4301a056617cc13a1a2ab0e3caba51bfb1ab3fcb</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa8682cfd2b6c714d2190fa38863d545c7a0b73d5">0xa8682cfd2b6c714d2190fa38863d545c7a0b73d5</a></p>
<pre><code class="language-solidity">function claimComp(
        address[] memory holders,
        CToken[] memory cTokens,
        bool borrowers,
        bool suppliers
    ) public {
        for (uint256 i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(isMarketListed(address(cToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa8682cfd2b6c714d2190fa38863d545c7a0b73d5">0xa8682cfd2b6c714d2190fa38863d545c7a0b73d5</a></p>
<pre><code class="language-solidity">function claimComp(
        address[] memory holders,
        CToken[] memory cTokens,
        bool borrowers,
        bool suppliers
    ) public {
        for (uint256 i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(isMarketListed(address(cToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa8682cfd2b6c714d2190fa38863d545c7a0b73d5">0xa8682cfd2b6c714d2190fa38863d545c7a0b73d5</a></p>
<pre><code class="language-solidity">function claimComp(
        address[] memory holders,
        CToken[] memory cTokens,
        bool borrowers,
        bool suppliers
    ) public {
        for (uint256 i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(isMarketListed(address(cToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa8682cfd2b6c714d2190fa38863d545c7a0b73d5">0xa8682cfd2b6c714d2190fa38863d545c7a0b73d5</a></p>
<pre><code class="language-solidity">function claimComp(
        address[] memory holders,
        CToken[] memory cTokens,
        bool borrowers,
        bool suppliers
    ) public {
        for (uint256 i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(isMarketListed(address(cToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6cdf387c607a1a1178a9e983f36aede65da57f1">0xb6cdf387c607a1a1178a9e983f36aede65da57f1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6cdf387c607a1a1178a9e983f36aede65da57f1">0xb6cdf387c607a1a1178a9e983f36aede65da57f1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6cdf387c607a1a1178a9e983f36aede65da57f1">0xb6cdf387c607a1a1178a9e983f36aede65da57f1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6cdf387c607a1a1178a9e983f36aede65da57f1">0xb6cdf387c607a1a1178a9e983f36aede65da57f1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6cdf387c607a1a1178a9e983f36aede65da57f1">0xb6cdf387c607a1a1178a9e983f36aede65da57f1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6cdf387c607a1a1178a9e983f36aede65da57f1">0xb6cdf387c607a1a1178a9e983f36aede65da57f1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6cdf387c607a1a1178a9e983f36aede65da57f1">0xb6cdf387c607a1a1178a9e983f36aede65da57f1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6cdf387c607a1a1178a9e983f36aede65da57f1">0xb6cdf387c607a1a1178a9e983f36aede65da57f1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : RafldexV2_2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x08e1bc602c44ecb7932387b6792c3cb0a5c64a92">0x08e1bc602c44ecb7932387b6792c3cb0a5c64a92</a></p>
<pre><code class="language-solidity">function giveorRemoveSubscriptionTo(
        address[] memory _addresses,
        bool _isSubscriber
    ) external onlyRole(OPERATOR_ROLE, msg.sender) {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            Subscribers[_addresses[i]] = _isSubscriber;
            if (_isSubscriber == true) {
                emit GotSubscription(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSubscriber == true</code></p>
<hr />
<h3>Contract : RafldexV2_2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x08e1bc602c44ecb7932387b6792c3cb0a5c64a92">0x08e1bc602c44ecb7932387b6792c3cb0a5c64a92</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : TestNet4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7bc455a4764a3170d33b02d628982b4e910f59ce">0x7bc455a4764a3170d33b02d628982b4e910f59ce</a></p>
<pre><code class="language-solidity">function tradeTokensBatch(address token,
        uint256 amount,
        uint24 poolFee,
        bool convertToWeth
    ) public checkAddress() returns (uint256 totalSwapped) {
        address firstToken;
        address secondToken;

        if(convertToWeth == true) {
            firstToken = token;
            secondToken = WETH;
        } else {
            firstToken = WETH;
            secondToken = token;
        }

        for (uint256 i = 0; i &lt; wallets.length; i++) {
            uint256 tokenAmount = swapExactInputSingle(firstToken, secondToken, wallets[i], amount, poolFee);
            totalSwapped += tokenAmount;
        }

        return (totalSwapped);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>convertToWeth == true</code></p>
<hr />
<h3>Contract : ActionNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb198936708ef94f494a4e753c44dcf8691cf7b87">0xb198936708ef94f494a4e753c44dcf8691cf7b87</a></p>
<pre><code class="language-solidity">function signResolution(bool _resolution) public onlyAdmin {
    canMint = false;

    // Floor Vote Successful
    if (_resolution == true) {

      // Admin can claim immediately
      adminClaimTime = block.timestamp;

      // Floor Vote Unsuccessful
    } else {

      // Withdraw period is active
      adminClaimTime = block.timestamp + withdrawWindow;
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_resolution == true</code></p>
<hr />
<h3>Contract : TeamAnonymous</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5073fa31039f19557e085e86fa80cdf40ec7593a">0x5073fa31039f19557e085e86fa80cdf40ec7593a</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyAMPLArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8004ea2db8d91489e261fac0819992596cf69077">0x8004ea2db8d91489e261fac0819992596cf69077</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        checkAndSwapTokens(address(0)); // Check for rebase only and update variables if needed
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : QoneqtTokenGenerator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad196132fc3e40ee62980701375fc2188b01918e">0xad196132fc3e40ee62980701375fc2188b01918e</a></p>
<pre><code class="language-solidity">constructor (string memory tokenName, string memory tokenSymbol,uint256 initialSupply,bool _liqFee, bool _burnFee,bool _Ownable,uint256 liquidityFee_,uint256 burnRate_, address _uniswapv2router){
        address msgSender = _msgSender();
        require(address(msgSender) != address(0) , &quot;ERC20: transfer to the zero address&quot;);
        _owner = msgSender;
        _name = tokenName;
        _symbol = tokenSymbol;
        _tTotal = initialSupply * 10 ** 18;
        _rTotal = (MAX - (MAX % _tTotal));
          LiqFee = _liqFee;
          burnFee = _burnFee;
          Ownable = _Ownable;
         if(_liqFee == true) {
             _liquidityFee = liquidityFee_;
         } else if(_liqFee == false) {
             _liquidityFee = 0;
         }
          if(_burnFee == true) {
             _burnRate = burnRate_;
         } else if(_burnFee == false) {
             _burnRate = 0;
         }
       _rOwned[_msgSender()] = _rTotal;

        //exclude owner and this contract from fee
        _isExcludedFromFee[Admin()] = true;
        _isExcludedFromFee[address(this)] = true;
     emit Transfer(address(0), _msgSender(), _tTotal);
        uniswapv2routeraddress = _uniswapv2router ;

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapv2routeraddress);        
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        if(Ownable == true) {
            renounceOwnershipToBurnAddress();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_liqFee == true</code></p>
<hr />
<h3>Contract : QoneqtTokenGenerator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad196132fc3e40ee62980701375fc2188b01918e">0xad196132fc3e40ee62980701375fc2188b01918e</a></p>
<pre><code class="language-solidity">constructor (string memory tokenName, string memory tokenSymbol,uint256 initialSupply,bool _liqFee, bool _burnFee,bool _Ownable,uint256 liquidityFee_,uint256 burnRate_, address _uniswapv2router){
        address msgSender = _msgSender();
        require(address(msgSender) != address(0) , &quot;ERC20: transfer to the zero address&quot;);
        _owner = msgSender;
        _name = tokenName;
        _symbol = tokenSymbol;
        _tTotal = initialSupply * 10 ** 18;
        _rTotal = (MAX - (MAX % _tTotal));
          LiqFee = _liqFee;
          burnFee = _burnFee;
          Ownable = _Ownable;
         if(_liqFee == true) {
             _liquidityFee = liquidityFee_;
         } else if(_liqFee == false) {
             _liquidityFee = 0;
         }
          if(_burnFee == true) {
             _burnRate = burnRate_;
         } else if(_burnFee == false) {
             _burnRate = 0;
         }
       _rOwned[_msgSender()] = _rTotal;

        //exclude owner and this contract from fee
        _isExcludedFromFee[Admin()] = true;
        _isExcludedFromFee[address(this)] = true;
     emit Transfer(address(0), _msgSender(), _tTotal);
        uniswapv2routeraddress = _uniswapv2router ;

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapv2routeraddress);        
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        if(Ownable == true) {
            renounceOwnershipToBurnAddress();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_burnFee == true</code></p>
<hr />
<h3>Contract : QoneqtTokenGenerator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad196132fc3e40ee62980701375fc2188b01918e">0xad196132fc3e40ee62980701375fc2188b01918e</a></p>
<pre><code class="language-solidity">constructor (string memory tokenName, string memory tokenSymbol,uint256 initialSupply,bool _liqFee, bool _burnFee,bool _Ownable,uint256 liquidityFee_,uint256 burnRate_, address _uniswapv2router){
        address msgSender = _msgSender();
        require(address(msgSender) != address(0) , &quot;ERC20: transfer to the zero address&quot;);
        _owner = msgSender;
        _name = tokenName;
        _symbol = tokenSymbol;
        _tTotal = initialSupply * 10 ** 18;
        _rTotal = (MAX - (MAX % _tTotal));
          LiqFee = _liqFee;
          burnFee = _burnFee;
          Ownable = _Ownable;
         if(_liqFee == true) {
             _liquidityFee = liquidityFee_;
         } else if(_liqFee == false) {
             _liquidityFee = 0;
         }
          if(_burnFee == true) {
             _burnRate = burnRate_;
         } else if(_burnFee == false) {
             _burnRate = 0;
         }
       _rOwned[_msgSender()] = _rTotal;

        //exclude owner and this contract from fee
        _isExcludedFromFee[Admin()] = true;
        _isExcludedFromFee[address(this)] = true;
     emit Transfer(address(0), _msgSender(), _tTotal);
        uniswapv2routeraddress = _uniswapv2router ;

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapv2routeraddress);        
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        if(Ownable == true) {
            renounceOwnershipToBurnAddress();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_liqFee == true</code></p>
<hr />
<h3>Contract : QoneqtTokenGenerator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad196132fc3e40ee62980701375fc2188b01918e">0xad196132fc3e40ee62980701375fc2188b01918e</a></p>
<pre><code class="language-solidity">constructor (string memory tokenName, string memory tokenSymbol,uint256 initialSupply,bool _liqFee, bool _burnFee,bool _Ownable,uint256 liquidityFee_,uint256 burnRate_, address _uniswapv2router){
        address msgSender = _msgSender();
        require(address(msgSender) != address(0) , &quot;ERC20: transfer to the zero address&quot;);
        _owner = msgSender;
        _name = tokenName;
        _symbol = tokenSymbol;
        _tTotal = initialSupply * 10 ** 18;
        _rTotal = (MAX - (MAX % _tTotal));
          LiqFee = _liqFee;
          burnFee = _burnFee;
          Ownable = _Ownable;
         if(_liqFee == true) {
             _liquidityFee = liquidityFee_;
         } else if(_liqFee == false) {
             _liquidityFee = 0;
         }
          if(_burnFee == true) {
             _burnRate = burnRate_;
         } else if(_burnFee == false) {
             _burnRate = 0;
         }
       _rOwned[_msgSender()] = _rTotal;

        //exclude owner and this contract from fee
        _isExcludedFromFee[Admin()] = true;
        _isExcludedFromFee[address(this)] = true;
     emit Transfer(address(0), _msgSender(), _tTotal);
        uniswapv2routeraddress = _uniswapv2router ;

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapv2routeraddress);        
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        if(Ownable == true) {
            renounceOwnershipToBurnAddress();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_burnFee == true</code></p>
<hr />
<h3>Contract : QoneqtTokenGenerator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad196132fc3e40ee62980701375fc2188b01918e">0xad196132fc3e40ee62980701375fc2188b01918e</a></p>
<pre><code class="language-solidity">constructor (string memory tokenName, string memory tokenSymbol,uint256 initialSupply,bool _liqFee, bool _burnFee,bool _Ownable,uint256 liquidityFee_,uint256 burnRate_, address _uniswapv2router){
        address msgSender = _msgSender();
        require(address(msgSender) != address(0) , &quot;ERC20: transfer to the zero address&quot;);
        _owner = msgSender;
        _name = tokenName;
        _symbol = tokenSymbol;
        _tTotal = initialSupply * 10 ** 18;
        _rTotal = (MAX - (MAX % _tTotal));
          LiqFee = _liqFee;
          burnFee = _burnFee;
          Ownable = _Ownable;
         if(_liqFee == true) {
             _liquidityFee = liquidityFee_;
         } else if(_liqFee == false) {
             _liquidityFee = 0;
         }
          if(_burnFee == true) {
             _burnRate = burnRate_;
         } else if(_burnFee == false) {
             _burnRate = 0;
         }
       _rOwned[_msgSender()] = _rTotal;

        //exclude owner and this contract from fee
        _isExcludedFromFee[Admin()] = true;
        _isExcludedFromFee[address(this)] = true;
     emit Transfer(address(0), _msgSender(), _tTotal);
        uniswapv2routeraddress = _uniswapv2router ;

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapv2routeraddress);        
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        if(Ownable == true) {
            renounceOwnershipToBurnAddress();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_liqFee == true</code></p>
<hr />
<h3>Contract : QoneqtTokenGenerator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad196132fc3e40ee62980701375fc2188b01918e">0xad196132fc3e40ee62980701375fc2188b01918e</a></p>
<pre><code class="language-solidity">constructor (string memory tokenName, string memory tokenSymbol,uint256 initialSupply,bool _liqFee, bool _burnFee,bool _Ownable,uint256 liquidityFee_,uint256 burnRate_, address _uniswapv2router){
        address msgSender = _msgSender();
        require(address(msgSender) != address(0) , &quot;ERC20: transfer to the zero address&quot;);
        _owner = msgSender;
        _name = tokenName;
        _symbol = tokenSymbol;
        _tTotal = initialSupply * 10 ** 18;
        _rTotal = (MAX - (MAX % _tTotal));
          LiqFee = _liqFee;
          burnFee = _burnFee;
          Ownable = _Ownable;
         if(_liqFee == true) {
             _liquidityFee = liquidityFee_;
         } else if(_liqFee == false) {
             _liquidityFee = 0;
         }
          if(_burnFee == true) {
             _burnRate = burnRate_;
         } else if(_burnFee == false) {
             _burnRate = 0;
         }
       _rOwned[_msgSender()] = _rTotal;

        //exclude owner and this contract from fee
        _isExcludedFromFee[Admin()] = true;
        _isExcludedFromFee[address(this)] = true;
     emit Transfer(address(0), _msgSender(), _tTotal);
        uniswapv2routeraddress = _uniswapv2router ;

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapv2routeraddress);        
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        if(Ownable == true) {
            renounceOwnershipToBurnAddress();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_burnFee == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1bd04df8d024eeb7cd16349beeb8c214f66314ca">0x1bd04df8d024eeb7cd16349beeb8c214f66314ca</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1bd04df8d024eeb7cd16349beeb8c214f66314ca">0x1bd04df8d024eeb7cd16349beeb8c214f66314ca</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4186b474b940f459dae8acb4463f430eb72f41f9">0x4186b474b940f459dae8acb4463f430eb72f41f9</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + hightLightFee);
                } else {
                    require(msg.value == limitETHFee + hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4186b474b940f459dae8acb4463f430eb72f41f9">0x4186b474b940f459dae8acb4463f430eb72f41f9</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x769dc1023042fa16fa231c0ca4ce1e5db96acaca">0x769dc1023042fa16fa231c0ca4ce1e5db96acaca</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe3292d998ea044bbb0156ed747871d0070740578">0xe3292d998ea044bbb0156ed747871d0070740578</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe3292d998ea044bbb0156ed747871d0070740578">0xe3292d998ea044bbb0156ed747871d0070740578</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe3292d998ea044bbb0156ed747871d0070740578">0xe3292d998ea044bbb0156ed747871d0070740578</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : cryptoChallenge</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x545ef6db327e0861f199222c0c2d162a0f63e723">0x545ef6db327e0861f199222c0c2d162a0f63e723</a></p>
<pre><code class="language-solidity">function judge(uint256 _tokenId, bool _isP1Win) onlyWitness(_tokenId) public {
    require(price2OfToken[_tokenId] != 0);
    require(now &gt; free2OfToken[_tokenId]);

    uint reward = bet1OfToken[_tokenId] + bet2OfToken[_tokenId];
    reward -= calculateDevCut(reward);
    if (_isP1Win == true) {
      p1OfToken[_tokenId].transfer(reward.mul(bet1OfToken[_tokenId]).div(bet1OfToken[_tokenId] + price1OfToken[_tokenId]));
      owner1OfToken[_tokenId].transfer(reward.mul(price1OfToken[_tokenId]).div(bet1OfToken[_tokenId] + price1OfToken[_tokenId]));
    } else {
      p2OfToken[_tokenId].transfer(reward.mul(bet2OfToken[_tokenId]).div(bet2OfToken[_tokenId] + price2OfToken[_tokenId]));
      owner2OfToken[_tokenId].transfer(reward.mul(price2OfToken[_tokenId]).div(bet2OfToken[_tokenId] + price2OfToken[_tokenId]));
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isP1Win == true</code></p>
<hr />
<h3>Contract : MetaNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5e3e910eb44f05da2bbb0e39ef7cf22ea0b71b6e">0x5e3e910eb44f05da2bbb0e39ef7cf22ea0b71b6e</a></p>
<pre><code class="language-solidity">function setIsWl(bool _flag) public  {
        //require(isWl != true, &quot;WhiteList is opened&quot;);
        isWl = _flag;
        if (_flag == true) {
            isSale = false;
        } else {
            isSale = true;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_flag == true</code></p>
<hr />
<h3>Contract : MetaNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5e3e910eb44f05da2bbb0e39ef7cf22ea0b71b6e">0x5e3e910eb44f05da2bbb0e39ef7cf22ea0b71b6e</a></p>
<pre><code class="language-solidity">function setIsSale(bool _flag) public  {
        //require(isSale != true, &quot;sale is opened&quot;);
         if (_flag == true) {
            isWl = false;
        } else {
            isWl = true;
        }
        isSale = _flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_flag == true</code></p>
<hr />
<h3>Contract : ZarelaSmartContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf67192a8b9f269f23802d9ab94c7875a0abb7aea">0xf67192a8b9f269f23802d9ab94c7875a0abb7aea</a></p>
<pre><code class="language-solidity">function contribute(
        uint _orderId,
        address payable _contributorAddress,
        address payable _laboratoryAddress,
        bool _isContributorGainReward, 
        address _orderOwner,
        string memory _ipfsHash,
        string memory _encryptionKey
    )
        public 
        checkOrderId (_orderId)
        notNull(_orderOwner)
        notNull(_contributorAddress)
        notNull(_laboratoryAddress)

    {
        require(orders[_orderId].totalContributorsRemain != 0 ,&quot;Order Was Finished&quot;);
        require(_orderOwner ==  orders[_orderId].orderOwner , &quot;Requester Address Was Not Entered Correctly&quot;);
        require(msg.sender == _laboratoryAddress || msg.sender == _contributorAddress , &quot;You Are Not Angel Or Laboratory&quot;);
        if (isZarelaEnd != true) {
            address payable rewardRecipientAddress;
            if (_isContributorGainReward == true) {
                rewardRecipientAddress = _contributorAddress;
                orderDataMap[_orderId].whoGainedReward.push(true);
            } else {
                rewardRecipientAddress = _laboratoryAddress;
                orderDataMap[_orderId].whoGainedReward.push(false);
            }
            if (block.timestamp &lt; countDown24Hours + 24 hours) {
                paymentQueue.push(rewardRecipientAddress);
                todayContributionsCount++;
            } else {
                paymentQueue.push(address(0));
                paymentQueue.push(rewardRecipientAddress);
                dailyContributionsCount.push(todayContributionsCount);
                if (dayCounterOf20Months &gt;= 589) { //20 month
                    maxUserDailyReward = maxUserDailyReward / 2 ;
                    totalTokenReleaseDaily = totalTokenReleaseDaily / 2 ;
                    halvingCounter++;
                    dayCounterOf20Months = 0 ;
                }
                if (_balances[address(this)] &gt;= totalTokenReleaseDaily) {
                    _balances[address(this)] = _balances[address(this)] - totalTokenReleaseDaily;
                    bankBalance+=(totalTokenReleaseDaily);
                } else if (bankBalance &gt; 0 &amp;&amp; _balances[address(this)] &lt; totalTokenReleaseDaily) {
                    bankBalance+= totalTokenReleaseDaily;
                    totalTokenReleaseDaily = 0; 
                } else {
                    totalTokenReleaseDaily = 0;
                    isZarelaEnd = true;
                }

                remainedDailyTokens.push(totalTokenReleaseDaily);

                if (zarelaDayCounter &gt;= 44) { // 45 days
                    bankBalance = bankBalance - (remainedDailyTokens[dayOfTokenBurning]);
                    burnedTokensPerDay.push(remainedDailyTokens[dayOfTokenBurning]);
                    remainedDailyTokens[dayOfTokenBurning] = 0;
                    dayOfTokenBurning++;
                }

                dailyBalance.push(bankBalance);

                if (maxUserDailyReward * dailyContributionsCount[zarelaDayCounter] &gt;= bankBalance) {
                    dailyBalance[zarelaDayCounter] = bankBalance;
                    dailyRewardPerContributor.push(bankBalance/dailyContributionsCount[zarelaDayCounter]);
                    bankBalance = 0;
                } else {
                    dailyBalance[zarelaDayCounter] = maxUserDailyReward * dailyContributionsCount[zarelaDayCounter];
                    dailyRewardPerContributor.push(maxUserDailyReward);
                    bankBalance = bankBalance - (maxUserDailyReward * dailyContributionsCount[zarelaDayCounter]);
                }

                uint tempPrice = dailyBalance[zarelaDayCounter];

                if (tempPrice &gt;= remainedDailyTokens[zarelaDayCounter]) {
                    tempPrice = tempPrice - (remainedDailyTokens[zarelaDayCounter]);
                    remainedDailyTokens[zarelaDayCounter] = 0;
                    while (tempPrice &gt; 0) {
                        if (tempPrice &gt; remainedDailyTokens[indexOfZeroDailyTokens]) {
                            tempPrice = tempPrice - (remainedDailyTokens[indexOfZeroDailyTokens]);
                            remainedDailyTokens[indexOfZeroDailyTokens] = 0;
                            indexOfZeroDailyTokens++;
                        } else {
                            remainedDailyTokens[indexOfZeroDailyTokens] =  remainedDailyTokens[indexOfZeroDailyTokens] - (tempPrice);
                            tempPrice = 0;
                        }
                    }
                } else {
                    remainedDailyTokens[zarelaDayCounter] = remainedDailyTokens[zarelaDayCounter] - tempPrice;
                }

                zarelaDifficultyOfDay = (lastRewardableIndex - indexOfAddressPendingReward) / dailyContributionsCount[zarelaDayCounter];

                if ((zarelaDayCounter - paymentDay) &gt;= 7 &amp;&amp; (lastRewardableIndex - indexOfAddressPendingReward) &gt;= 384 ) {
                    zarelaDifficultyOfDay = 128;
                } else if (zarelaDifficultyOfDay &lt; 5) {
                    zarelaDifficultyOfDay = 2**zarelaDifficultyOfDay;
                } else {
                    zarelaDifficultyOfDay = 32;
                }

                todayContributionsCount = 0;
                zarelaDayCounter++;
                dayCounterOf20Months++;
                countDown24Hours = block.timestamp;

            }
            if (paymentQueue[indexCounter] == address(0)) {
                lastRewardableIndex = indexCounter;
                _reward();
                indexCounter+=2;
                todayContributionsCount++;
            } else if (lastRewardableIndex != indexOfAddressPendingReward) {
                _reward();
                indexCounter++;
            } else {
                indexCounter++;
            }
        }

        orderDataMap[_orderId].orderId = _orderId;
        orders[_orderId].countOfRegisteredContributions++;
        orderDataMap[_orderId].ipfsHash.push(_ipfsHash);
        orderDataMap[_orderId].encryptionKey.push(_encryptionKey);
        orderDataMap[_orderId].contributorAddresses.push(_contributorAddress);
        orderDataMap[_orderId].laboratoryAddresses.push(_laboratoryAddress);
        orderDataMap[_orderId].isConfirmedByMage.push(false);
        orderDataMap[_orderId].dataRegistrationTime.push(block.timestamp);
        userMap[_contributorAddress].angelContributedOrders.push(_orderId);
        userMap[_laboratoryAddress].laboratoryContributedOrders.push(_orderId);
        orderDataMap[_orderId].zarelaDay.push(zarelaDayCounter);

        emit contributed(_contributorAddress , _laboratoryAddress ,_orderId ,_orderOwner ,zarelaDifficultyOfDay);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isContributorGainReward == true</code></p>
<hr />
<h3>Contract : RugProofMaster</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0997216ac6b6807bfbdced0dd3b3b96462f5a86e">0x0997216ac6b6807bfbdced0dd3b3b96462f5a86e</a></p>
<pre><code class="language-solidity">function createNewTokenSale(
      address _contractAddress, uint256 _tokenAmount,
      uint256 _tokenRatio, uint32 _timestampEndSec,
      uint8 _liquidityLockPercent, uint256 _softcap, bool wantVerified) external payable {

        require(_contractAddress != address(0), &quot;CreateNewTokenSale: Cannot use the zero address&quot;);
        require(msg.sender != address(this), &quot;CreateNewTokenSale: Cannot call from this contract&quot;);
        require(_tokenAmount != 0, &quot;CreateNewTokenSale: Cannot sell zero tokens&quot;);
        require(_tokenRatio != 0, &quot;CreateNewTokenSale: Cannot have a zero ratio&quot;);
        require(_timestampEndSec &gt; now, &quot;CreateNewTokenSale: Cannot start sale after end time&quot;);
        require(_liquidityLockPercent &lt;= 100, &quot;CreateNewTokenSale: Cannot have higher than 100% liquidity lock&quot;);
        // make sure we are not raising too much ETH
        uint256 totalValueOfTokens = _tokenAmount.mul(1e18).div(_tokenRatio);
        uint256 hardcapETH = totalValueOfTokens.div(100 + _liquidityLockPercent).mul(100);

        require(_softcap != 0 &amp;&amp; _softcap &lt;= hardcapETH, &quot;CreateNewTokenSale: Cannot have a zero softcap or be more than the hardcap&quot;);

        if(wantVerified == true){
          require(msg.value == verifiedAmount, &quot;createNewTokenSale::wantVerified: msg.value is must be verifiedAmount&quot;);
          address(owner).toPayable().transfer(verifiedAmount);
        }

        // check how many tokens we receive
        // this is an important step to ensure we log proper amounts if this is a deflationary token
        // approve must be called before this function is executed. Need to approve this contract address to send the token amount
        uint256 tokenBalanceBeforeTransfer = IERC20(_contractAddress).balanceOf(address(this));
        IERC20(_contractAddress).transferFrom(address(msg.sender), address(this), _tokenAmount);
        uint256 tokensReceived = IERC20(_contractAddress).balanceOf(address(this)).sub(tokenBalanceBeforeTransfer);


        SaleInfo memory saleInfo = SaleInfo(
          _contractAddress, msg.sender, tokensReceived, _tokenRatio, 0, _softcap,
          0, uint32(now), _timestampEndSec, _liquidityLockPercent, false, false
          );

        tokenSales.push(saleInfo);
        emit LogCreateNewSale(_contractAddress, _tokenAmount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>wantVerified == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x93aa7b089348e189aaa0cd32915596e3c4e6e2b4">0x93aa7b089348e189aaa0cd32915596e3c4e6e2b4</a></p>
<pre><code class="language-solidity">function updateSale(address _tokenAddress,uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) onlyAcceptedToken(_tokenAddress) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale      = true;
            sale.amount         = _amount;
            sale.price          = _price;
            sale.tokenAddress   = _tokenAddress;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : Arbitration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdde1cddbbc4bfc0d2e9f5b2957456a2b651aaa6b">0xdde1cddbbc4bfc0d2e9f5b2957456a2b651aaa6b</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : CollectionDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0e4447aece6d71062c14815f0fc557f29a62fa19">0x0e4447aece6d71062c14815f0fc557f29a62fa19</a></p>
<pre><code class="language-solidity">function generateColorMatrix(bytes memory hash, bool maximalist) public pure returns (string memory) {
        string memory strMatrix;

        for(uint i = 0; i&lt;20; i+=1) {
            // re-uses entropy
            // note: using i+1 does create *some* default tendency, but shouldn't be significant.
            uint matrixOffset = utils.getMatrixOffset(hash, i); // 0 - 64
            uint negOrPos = utils.getNegOrPos(hash, i+1); // 0 - 255

            if(i == 18) { // Alpha modified by itself. Adds more of everything or less of everything.
                // note: code borrowed from room of infinite paintings
                // in general: higher -&gt; more infill. lower -&gt; less infilling and more transparency.
                // higher was chosen so one can see the blur + higher likelihood of pieces overlapping
                strMatrix = string.concat(strMatrix, '-50 '); 
            } else if(i == 19) { 
                // final channel is the shift of the alpha channel
                // making it mildly brighter ensure *some* color
                strMatrix = string.concat(strMatrix, '1 ');
            } else if(i==4 || i == 9 || i== 14) { 
                // shifts for RGB
                if(maximalist == true) {
                    // shifting makes the entire channel linearly stronger or weaker AFTER it's been modified from its underlying components.
                    // eg modify randomly and THEN add more (or less) of the channel to the pixel in general.
                    // if the shift is zero, it keeps each channel equal essentially. ensures more varied colours.
                    // thus, for background blur, it's better and more maximalist.
                    strMatrix = string.concat(strMatrix, '0 '); // no shifts
                } else {
                    // adding a mild shift causes the entire pixel to add more of that channel
                    // this comes at the expense of the other channels
                    // thus, adding shifts to each channel essentially takes away variedness, making it white.
                    // making it more minimal and sharp. 
                    // too strong a shift makes it too white and thus you can't see the blur.
                    strMatrix = string.concat(strMatrix, '1 '); // shifts 
                }
            } else if(negOrPos &lt; 128) { 
                // random chance of adding or taking away colour (or alpha) from rgba
                strMatrix = string.concat(strMatrix, utils.uint2str(matrixOffset), ' ');
            } else {
                strMatrix = string.concat(strMatrix, '-', utils.uint2str(matrixOffset), ' ');
            }
        }
        return strMatrix;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>maximalist == true</code></p>
<hr />
<h3>Contract : CollectionDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0e4447aece6d71062c14815f0fc557f29a62fa19">0x0e4447aece6d71062c14815f0fc557f29a62fa19</a></p>
<pre><code class="language-solidity">function generateURI(uint256 tokenId, bool deluxe) public pure returns (string memory) {
        string memory name = generateName(tokenId, deluxe); 
        string memory description = generateDescription();
        string memory image = generateBase64Image(tokenId, deluxe);
        string memory attributes = generateTraits(tokenId, deluxe);

        string memory animation = &quot;&quot;;
        if(deluxe == true) {
            animation = string.concat('&quot;, &quot;animation_url&quot;: &quot;',
                'data:image/svg+xml;base64,', 
                image
            );
        }

        return string(
            abi.encodePacked(
                'data:application/json;base64,',
                Base64.encode(
                    bytes(
                            abi.encodePacked(
                            '{&quot;name&quot;:&quot;', 
                            name,
                            '&quot;, &quot;description&quot;:&quot;', 
                            description,
                            '&quot;, &quot;image&quot;: &quot;', 
                            'data:image/svg+xml;base64,', 
                            image,
                            animation,
                            '&quot;, ',
                            attributes,
                            '}'
                        )
                    )
                )
            )
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>deluxe == true</code></p>
<hr />
<h3>Contract : CollectionDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0e4447aece6d71062c14815f0fc557f29a62fa19">0x0e4447aece6d71062c14815f0fc557f29a62fa19</a></p>
<pre><code class="language-solidity">function generateName(uint nr, bool deluxe) public pure returns (string memory) {
        string memory prefix = &quot;Default&quot;;
        if(deluxe == true) {
            prefix = &quot;Deluxe&quot;;
        }
        return string(abi.encodePacked(prefix, ' Daisychain #', utils.substring(utils.uint2str(nr),0,8)));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>deluxe == true</code></p>
<hr />
<h3>Contract : CollectionDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0e4447aece6d71062c14815f0fc557f29a62fa19">0x0e4447aece6d71062c14815f0fc557f29a62fa19</a></p>
<pre><code class="language-solidity">function generateTraits(uint256 tokenId, bool deluxe) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        string memory animatedTrait;

        if(deluxe == true) {
            animatedTrait = createTrait(&quot;Animated&quot;, &quot;True&quot;);
        } else {
            animatedTrait = createTrait(&quot;Animated&quot;, &quot;False&quot;);
        }

        uint256 petalCount = utils.getPetalCount(hash);

        string memory petalCountTrait = createTrait(&quot;Petal Count&quot;, utils.uint2str(petalCount));

        return string(abi.encodePacked(
            '&quot;attributes&quot;: [',
            animatedTrait,
            &quot;,&quot;,
            petalCountTrait,
            ']'
        ));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>deluxe == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBACMICArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x07ddc3db7bf6b073c038fa1ef092354ff1cf6964">0x07ddc3db7bf6b073c038fa1ef092354ff1cf6964</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBACMICArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x07ddc3db7bf6b073c038fa1ef092354ff1cf6964">0x07ddc3db7bf6b073c038fa1ef092354ff1cf6964</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x524fcaa13764f30a121e042b420be956a5891256">0x524fcaa13764f30a121e042b420be956a5891256</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x524fcaa13764f30a121e042b420be956a5891256">0x524fcaa13764f30a121e042b420be956a5891256</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(now.sub(lastTradeTime) &gt; secondsBeforeTrade || _share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8f1a4ff29c43d2f276dc2e2bb1c5c407c983d79f">0x8f1a4ff29c43d2f276dc2e2bb1c5c407c983d79f</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8f1a4ff29c43d2f276dc2e2bb1c5c407c983d79f">0x8f1a4ff29c43d2f276dc2e2bb1c5c407c983d79f</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8f1a4ff29c43d2f276dc2e2bb1c5c407c983d79f">0x8f1a4ff29c43d2f276dc2e2bb1c5c407c983d79f</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8f1a4ff29c43d2f276dc2e2bb1c5c407c983d79f">0x8f1a4ff29c43d2f276dc2e2bb1c5c407c983d79f</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcb8276de56839bb76192ef5fbaddb29a8007afbc">0xcb8276de56839bb76192ef5fbaddb29a8007afbc</a></p>
<pre><code class="language-solidity">function trade(bool _isUSDB) public returns(bool) {
        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));
        uint256 returnUSD = network.rateByPath(generatePath(_isUSDB, true), tradeValue);
        uint256 returnDAI = network.rateByPath(generatePath(_isUSDB, false), tradeValue);
        IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD;

        if(returnDAI &gt; tradeValue) {
            require((returnDAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            network.convertFor(generatePath(_isUSDB, true), tradeValue, tradeValue, address(this));
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenDAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient DAI balance.');
            network.convertFor(generatePath(_isUSDB, false), tradeValue, tradeValue, address(this));
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x356b3c17e8dd81c016dd62d74c6c9125def47331">0x356b3c17e8dd81c016dd62d74c6c9125def47331</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyTSBTCArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xba8fd5460f7425197f6f38a51e41e4f812824024">0xba8fd5460f7425197f6f38a51e41e4f812824024</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyTSBTCArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xba8fd5460f7425197f6f38a51e41e4f812824024">0xba8fd5460f7425197f6f38a51e41e4f812824024</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0), lastTradeID);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : KOLUSDTFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27750e6d41aef99501ebc256538c6a13a254ea15">0x27750e6d41aef99501ebc256538c6a13a254ea15</a></p>
<pre><code class="language-solidity">function voteMission(uint256 _missionId,bool _agree) onlySuperNode public{
    require(now &lt; missionList[_missionId].endTime);
    require(kol.querySuperNode(msg.sender));
    require(!missionList[_missionId].done);
    require(!Voter[msg.sender][_missionId]);

    uint16 minSuperNodesNum = minSuperNodes;
    uint16 passSuperNodes = halfSuperNodes;

    uint256 TEN;
    if (missionList[_missionId].isKol){
      TEN = TENKOL;
    }else{
      TEN = TENUSDT;
    }

    if (missionList[_missionId].totalAmount &gt;= TEN){
      passSuperNodes = minSuperNodes;
    }

    if(_agree == true){
      missionList[_missionId].agreeSuperNodes++;
    }
    else{
      missionList[_missionId].refuseSuperNodes++;
    }
    if (missionList[_missionId].agreeSuperNodes &gt;= passSuperNodes) {
        missionList[_missionId].superPassed = true;
        missionPassed(_missionId);
    }else if (missionList[_missionId].refuseSuperNodes &gt;= passSuperNodes) {
        missionList[_missionId].done = true;
    }
    Voter[msg.sender][_missionId] = true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_agree == true</code></p>
<hr />
<h3>Contract : NFTSingleNoGatingSevPrices</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6ced9a7adc0084513b7ccbb4eb6ae968faeab526">0x6ced9a7adc0084513b7ccbb4eb6ae968faeab526</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : Auctions</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x06d3e950fe4ced87c7b24e8336b8688ce2c0ca9c">0x06d3e950fe4ced87c7b24e8336b8688ce2c0ca9c</a></p>
<pre><code class="language-solidity">function setAuctionApproval(uint256 auctionId, bool approved)
        public
        override
        auctionExists(auctionId)
    {
        IAuctions.Auction storage auction = auctions[auctionId];
        address curator = houses[auction.houseId].curator;

        require(
            curator == msg.sender,
            &quot;Not auction curator&quot;);
        require(
            auction.firstBidTime == 0,
            &quot;Already started&quot;);
        require(
            (approved == true &amp;&amp; auction.approved == false) ||
            (approved == false &amp;&amp; auction.approved == true),
            &quot;Already in this state&quot;);

        auction.approved = approved;

        if (approved == true) {
            _houseAuctions[auction.houseId].add(auctionId);
            _houseQueue[auction.houseId].remove(auctionId);

            if (_activeHouses.head() != auction.houseId) {
                if (_activeHouses.contains(auction.houseId)) {
                    _activeHouses.remove(auction.houseId);
                }
                _activeHouses.add(auction.houseId);
            }
        }

        emit AuctionApprovalUpdated(
            auctionId,
            approved
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>approved == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4345d308f02d1beb92475bda25e7c62be288478e">0x4345d308f02d1beb92475bda25e7c62be288478e</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4345d308f02d1beb92475bda25e7c62be288478e">0x4345d308f02d1beb92475bda25e7c62be288478e</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4345d308f02d1beb92475bda25e7c62be288478e">0x4345d308f02d1beb92475bda25e7c62be288478e</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4345d308f02d1beb92475bda25e7c62be288478e">0x4345d308f02d1beb92475bda25e7c62be288478e</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : MarsGenesisMartiansWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9f22b58a19b7fa667c6723d558399617729f0c49">0x9f22b58a19b7fa667c6723d558399617729f0c49</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe65fa6339ee15b5826984462cecba4c21443dd44">0xe65fa6339ee15b5826984462cecba4c21443dd44</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe65fa6339ee15b5826984462cecba4c21443dd44">0xe65fa6339ee15b5826984462cecba4c21443dd44</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x851cc731ce1613ae4fd8ec7f61f4b350f9ce1020">0x851cc731ce1613ae4fd8ec7f61f4b350f9ce1020</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : POPBridge</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6601fa22974fa6b5d15cb291f8c6948aaa7ee5af">0x6601fa22974fa6b5d15cb291f8c6948aaa7ee5af</a></p>
<pre><code class="language-solidity">function withdrawFromBridge(uint256 _amount, address user, IBEP20 token, bool status, uint256 id) public {
        require(bridgeOperator[msg.sender] == true, 'bad call');
        require(paused == false, 'Bridge is paused');
        require(safeId[id] == false &amp;&amp; id == depositorsId, 'payout already processed or trying to skip a tx');
        if(status == true){
        token.safeTransfer(user, _amount);
        }
        withdrawMaps[lastId].deposit = _amount; 
        withdrawMaps[lastId].depositor = user;
        withdrawMaps[lastId].depositor = address(token);
        withdrawMaps[lastId].id = depositorsId;
        safeId[id] = true;
        depositorsId = depositorsId+1;
        emit Withdraw(msg.sender, _amount, block.timestamp, address(token));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>status == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65">0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65">0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65">0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65">0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65">0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65">0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65">0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65">0xc5ecef9b0981d2834d2a83f2cfe85d4d97a19f65</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb546bd8c5a3ba4fc753fce56b0ac164b1097e658">0xb546bd8c5a3ba4fc753fce56b0ac164b1097e658</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb546bd8c5a3ba4fc753fce56b0ac164b1097e658">0xb546bd8c5a3ba4fc753fce56b0ac164b1097e658</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb546bd8c5a3ba4fc753fce56b0ac164b1097e658">0xb546bd8c5a3ba4fc753fce56b0ac164b1097e658</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb546bd8c5a3ba4fc753fce56b0ac164b1097e658">0xb546bd8c5a3ba4fc753fce56b0ac164b1097e658</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyETHArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6761202163364bc4f7c3816bef46695930536a3b">0x6761202163364bc4f7c3816bef46695930536a3b</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyETHArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6761202163364bc4f7c3816bef46695930536a3b">0x6761202163364bc4f7c3816bef46695930536a3b</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0));
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : CErc20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdb3401bef8f66e7f6cd95984026c26a4f47eee84">0xdb3401bef8f66e7f6cd95984026c26a4f47eee84</a></p>
<pre><code class="language-solidity">function mint(uint mintAmount, bool enterMarket) external returns (uint) {
        (uint err,) = mintInternal(mintAmount);
        //If the mint was successfull and the user wants to use assets as collateral
        if(err == 0 &amp;&amp; enterMarket == true){
            address[] memory marketToEnter = new address[](1);
            marketToEnter[0] = address(this);
            comptroller.enterMarkets(marketToEnter, msg.sender);
        }
        return err;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>err == 0 &amp;&amp; enterMarket == true</code></p>
<hr />
<h3>Contract : CErc20Delegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdb3401bef8f66e7f6cd95984026c26a4f47eee84">0xdb3401bef8f66e7f6cd95984026c26a4f47eee84</a></p>
<pre><code class="language-solidity">function mint(uint mintAmount, bool enterMarket) external returns (uint) {
        (uint err,) = mintInternal(mintAmount);
        //If the mint was successfull and the user wants to use assets as collateral
        if(err == 0 &amp;&amp; enterMarket == true){
            address[] memory marketToEnter = new address[](1);
            marketToEnter[0] = address(this);
            comptroller.enterMarkets(marketToEnter, msg.sender);
        }
        return err;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>err == 0 &amp;&amp; enterMarket == true</code></p>
<hr />
<h3>Contract : Treasury</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7416033d81115cc3c8a8f97c1aa9dcc187c67af1">0x7416033d81115cc3c8a8f97c1aa9dcc187c67af1</a></p>
<pre><code class="language-solidity">function setBeneficiary(address a, bool solid, uint amount, uint lastClaim, uint emission) public {
        require(msg.sender == _governance &amp;&amp; bens[a].solid == false &amp;&amp; amount&lt;=4e22 &amp;&amp; lastClaim &lt; block.number+1e6 &amp;&amp; lastClaim &gt;= 1264e4 &amp;&amp; emission &gt;= 1e2 &amp;&amp; emission &lt;=1e4);
        if(lastClaim &lt; block.number) {lastClaim = block.number;}
        if (solid == true) {bens[a].solid = true;}
        uint lc = bens[a].lastClaim;
        if (lc == 0) {bens[a].lastClaim = uint32(lastClaim);} //lastClaim can be set to a future block and used as a start block for grant activation
        if (bens[a].amount == 0 &amp;&amp; lc != 0) {bens[a].lastClaim = uint32(lastClaim);}
        bens[a].amount = uint88(amount);
        bens[a].emission = uint16(emission);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>solid == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x07390aa5de17e78a5a1e42b3f01ddb37dd4e054e">0x07390aa5de17e78a5a1e42b3f01ddb37dd4e054e</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : SurvivedOnes</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe59c6d591f029507245a1e0a94ea09c41b29f3f9">0xe59c6d591f029507245a1e0a94ea09c41b29f3f9</a></p>
<pre><code class="language-solidity">function cum(
    uint256 dose,
    uint256 randSeed,
    bool freeMintAllowed,
    bytes calldata signature
  ) external payable overCumProtection returns (uint256) {
    require(msg.sender == tx.origin, &quot;no_bots&quot;);
    if (MINT_STAGE &lt; 1) {
      revert LogicError(&quot;please_foreplay_first&quot;);
    }
    if (dose &lt; 1 || dose &gt; 100) {
      revert LogicError(&quot;wrong_dose&quot;);
    }
    if (
      verifySignature(msg.sender, randSeed, freeMintAllowed, signature) != true
    ) {
      revert InvalidSignature(&quot;wrong_signature&quot;);
    }

    uint256 freeMintCount = 0;

    if (freeMintAllowed == true) {
      if (FREE_MINT_USAGE_MAP[msg.sender] != true) {
        freeMintCount = FREE_MINT_PER_ALLOWED_WALLET;
        FREE_MINT_USAGE_MAP[msg.sender] = true;
      }
    }

    if (msg.value &lt; (dose - freeMintCount) * DOSE_PRICE) {
      revert PriceError(&quot;not_enough_money&quot;);
    }

    uint256 totalDeath = 0;
    uint256 totalSurvived = 0;

    for (uint256 i = 0; i &lt; dose; i += 1) {
      uint256 rand = random(signature, randSeed + i, 100);
      if (totalSupply() + (TEAM_SUPPLY - USED_TEAM_SUPPLY) &gt; MAX_TOTAL_SUPPLY) {
        break;
      }
      uint256 tempSurviveChange = i &lt; freeMintCount
        ? FREE_SURVIVE_CHANCE
        : SURVIVE_CHANCE;
      if (rand &lt; tempSurviveChange) {
        totalSurvived += 1;
      } else {
        totalDeath += 1;
      }
    }

    DeadProxy proxy = DeadProxy(DEAD_CONTRACT);

    if (totalDeath &gt; 0) {
      proxy.killSperm(msg.sender, totalDeath);
      DEAD_COUNT += totalDeath;
    }
    if (totalSurvived &lt; 1) {
      return 0;
    }

    if (
      totalSupply() + (TEAM_SUPPLY - USED_TEAM_SUPPLY) + totalSurvived &gt;
      MAX_TOTAL_SUPPLY
    ) {
      uint256 tempRemainingSupply = MAX_TOTAL_SUPPLY -
        (TEAM_SUPPLY - USED_TEAM_SUPPLY) -
        totalSupply();
      _safeMint(msg.sender, tempRemainingSupply);
      proxy.killSperm(msg.sender, totalSurvived - tempRemainingSupply);
      DEAD_COUNT += totalSurvived - tempRemainingSupply;
      return tempRemainingSupply;
    }
    _safeMint(msg.sender, totalSurvived);
    return totalSurvived;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>freeMintAllowed == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd2a24ebfada560df0faa2bdb772cbca491be618e">0xd2a24ebfada560df0faa2bdb772cbca491be618e</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd2a24ebfada560df0faa2bdb772cbca491be618e">0xd2a24ebfada560df0faa2bdb772cbca491be618e</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd2a24ebfada560df0faa2bdb772cbca491be618e">0xd2a24ebfada560df0faa2bdb772cbca491be618e</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd2a24ebfada560df0faa2bdb772cbca491be618e">0xd2a24ebfada560df0faa2bdb772cbca491be618e</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PriorityPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf8b9a7135470129e2718d5212eb8f08f004f3df7">0xf8b9a7135470129e2718d5212eb8f08f004f3df7</a></p>
<pre><code class="language-solidity">function withdraw(
        uint256 _amountToWithdraw,
        uint256 _amount,
        uint256 _sharesAmount,
        bytes32[] calldata _merkleProof,
        bool _shouldUnqueue
    ) external {
        if (_amountToWithdraw == 0) revert InvalidAmount();

        uint256 toWithdraw = _amountToWithdraw;
        address account = msg.sender;

        if (_shouldUnqueue == true) {
            _requireNotPaused();

            if (_merkleProof.length != 0) {
                bytes32 node = keccak256(bytes.concat(keccak256(abi.encode(account, _amount, _sharesAmount))));
                if (!MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, node)) revert InvalidProof();
            } else if (accountIndexes[account] &lt; merkleTreeSize) {
                revert InvalidProof();
            }

            uint256 queuedTokens = getQueuedTokens(account, _amount);
            uint256 canUnqueue = queuedTokens &lt;= totalQueued ? queuedTokens : totalQueued;
            uint256 amountToUnqueue = toWithdraw &lt;= canUnqueue ? toWithdraw : canUnqueue;

            if (amountToUnqueue != 0) {
                accountQueuedTokens[account] -= amountToUnqueue;
                totalQueued -= amountToUnqueue;
                toWithdraw -= amountToUnqueue;
                emit UnqueueTokens(account, amountToUnqueue);
            }
        }

        if (toWithdraw != 0) {
            IERC20Upgradeable(address(stakingPool)).safeTransferFrom(account, address(this), toWithdraw);
            _withdraw(toWithdraw);
            emit Withdraw(account, toWithdraw);
        }

        token.safeTransfer(account, _amountToWithdraw);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_shouldUnqueue == true</code></p>
<hr />
<h3>Contract : YettaToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x423d558d1ade7778a4c353bdde442d4a6717df16">0x423d558d1ade7778a4c353bdde442d4a6717df16</a></p>
<pre><code class="language-solidity">function submitVote(uint _task, bool proposal) public atStage(VotingStages.VOTING_OPEN){
        require(Currenttask == _task);
        require(balanceOf(msg.sender)&gt;0); 
        require(Task[_task][msg.sender] ==false); // Checks if already voted for a particular task
         if(proposal == true){
            agreed[_task] = agreed[_task].add(balanceOf(msg.sender));
            Task[_task][msg.sender] = true;
        }
        else{
            disagreed[_task] = disagreed[_task].add(balanceOf(msg.sender));
            Task[_task][msg.sender] = true;
        }

            }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>proposal == true</code></p>
<hr />
<h3>Contract : NFTInfo</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe3a56de836e970d3154c34a6e89a9e158bd5faed">0xe3a56de836e970d3154c34a6e89a9e158bd5faed</a></p>
<pre><code class="language-solidity">function manageHolderAddresses(bool status, address _holder) external {
        require(
            msg.sender == wrapperaddress || msg.sender == Owner,
            &quot;Not Oracle/Owner!&quot;
        );
        if (status == true) {
            //Add user to array!
            (bool _isholder, ) = isHolderInArray(_holder);
            if (!_isholder) holderaddresses.push(_holder);
        }
        if (status == false) {
            (bool _isholder, uint256 s) = isHolderInArray(_holder);
            if (_isholder) {
                holderaddresses[s] = holderaddresses[
                    holderaddresses.length - 1
                ];
                holderaddresses.pop();
            }
            holder[_holder] = status;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>status == true</code></p>
<hr />
<h3>Contract : MetaNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x346f4aea6f967e3594b5116041e65c8cf251ac97">0x346f4aea6f967e3594b5116041e65c8cf251ac97</a></p>
<pre><code class="language-solidity">function setIsWl(bool _flag) public  {
        //require(isWl != true, &quot;WhiteList is opened&quot;);
        isWl = _flag;
        if (_flag == true) {
            isSale = false;
        } else {
            isSale = true;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_flag == true</code></p>
<hr />
<h3>Contract : MetaNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x346f4aea6f967e3594b5116041e65c8cf251ac97">0x346f4aea6f967e3594b5116041e65c8cf251ac97</a></p>
<pre><code class="language-solidity">function setIsSale(bool _flag) public  {
        //require(isSale != true, &quot;sale is opened&quot;);
         if (_flag == true) {
            isWl = false;
        } else {
            isWl = true;
        }
        isSale = _flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_flag == true</code></p>
<hr />
<h3>Contract : RegisteryAdapterV2Vault</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x071b848b34586d0dc0009a3c0e6240b123c57186">0x071b848b34586d0dc0009a3c0e6240b123c57186</a></p>
<pre><code class="language-solidity">function setAssetDeprecated(address assetAddress, bool newDeprecationStatus)
        public
        onlyManagers
    {
        bool currentDeprecationStatus = assetDeprecated[assetAddress];
        if (currentDeprecationStatus == newDeprecationStatus) {
            revert(&quot;Adapter: Unable to change asset deprecation status&quot;);
        }
        if (newDeprecationStatus == true) {
            numberOfDeprecatedAssets++;
        } else {
            numberOfDeprecatedAssets--;
        }
        assetDeprecated[assetAddress] = newDeprecationStatus;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>newDeprecationStatus == true</code></p>
<hr />
<h3>Contract : MVFStrategy</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x907fc92afbca1879fac0ec724684465a3c143c17">0x907fc92afbca1879fac0ec724684465a3c143c17</a></p>
<pre><code class="language-solidity">function adjustWatermark(uint amount, bool signs) external onlyVault {
        uint lastWatermark = watermark;
        watermark = signs == true ? watermark + amount : watermark - amount;
        emit AdjustWatermark(watermark, lastWatermark);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>watermark = signs == true ? watermark + amount : watermark - amount</code></p>
<hr />
<h3>Contract : CitizenChatOffering</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xec5f900f57a01e926dd28031fde1d581fecb05d7">0xec5f900f57a01e926dd28031fde1d581fecb05d7</a></p>
<pre><code class="language-solidity">function buyTokens(bool isPremium) public payable activeSale {
        uint256 weiAmount = msg.value;
        uint256 rate;

        if (isPremium == true) {
            rate = premiumSubscriberRate;
        } else {
            rate = subscriberRate;
        }

        uint256 tokens = weiAmount * rate;

        emit BoughtTokens(_msgSender(), tokens);

        raisedAmount = raisedAmount + msg.value;

        require(
            token.transferFrom(owner(), _msgSender(), tokens),
            &quot;Sale: TokenTransfer failed&quot;
        );

        payable(owner()).transfer(msg.value);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isPremium == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe9d48f7ec2b68ac393f5be7f0f863f329c4e8046">0xe9d48f7ec2b68ac393f5be7f0f863f329c4e8046</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : YieldTokenService</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x874e1b98eb3150530dc410bb1512f032aecf0a27">0x874e1b98eb3150530dc410bb1512f032aecf0a27</a></p>
<pre><code class="language-solidity">function disburseCommissions(bool _disburseBackstop) external override {
        require((msg.sender == yieldTokenContract) ||
        (msg.sender == settlementAdmin) ||
            (msg.sender == owner) , &quot;Caller not authorized&quot;);

        require(settlementAdmin != address(0), &quot;Settlement Admin address error&quot;);

        // How much funds to disburse?
        uint withdrawAmount = totalPoolCHIPCommissionsAvailable;
        totalPoolCHIPCommissionsAvailable = 0;
        // Pay out to settlementAdmin account
        ERC20Interface(CHIPContract).transfer(settlementAdmin, withdrawAmount);
        emit CommissionsDisbursed(withdrawAmount);

        // Send out the backstop balance too
        if(_disburseBackstop == true) {
            require(backstopAdmin != address(0), &quot;Backstop Admin address error&quot;);

            // How much to pay out?
            withdrawAmount = totalPoolCHIPBackStopAvailable;
            totalPoolCHIPBackStopAvailable = 0;
            // Disburse backstop CHIPs to backstop Admin
            ERC20Interface(CHIPContract).transfer(backstopAdmin, withdrawAmount);
            emit BackstopDisbursed(withdrawAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_disburseBackstop == true</code></p>
<hr />
<h3>Contract : YieldTokenService</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x874e1b98eb3150530dc410bb1512f032aecf0a27">0x874e1b98eb3150530dc410bb1512f032aecf0a27</a></p>
<pre><code class="language-solidity">function adjustBackstop(bool _refunded, uint _amount) external {
        require((msg.sender == backstopAdmin) || (msg.sender == owner), &quot;Caller not authorized&quot;);

        if(_refunded == true) totalPoolCHIPBackStop = totalPoolCHIPBackStop.subSafe(_amount);  // Back out refunded amount
        else totalPoolCHIPBackStop = totalPoolCHIPBackStop.addSafe(_amount);  // Add more. This is used to fix user errors

        // Recalculate collateralization ratio
        uint wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);
        if(wildChip &gt; 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent
        else collateralizationRatio = 100;

        emit BackstopAdjusted(_refunded, _amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_refunded == true</code></p>
<hr />
<h3>Contract : TSUKAPE</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfdc993ec3335012c198a5c1831bddc3800a3943b">0xfdc993ec3335012c198a5c1831bddc3800a3943b</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : TestNet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfefe3da58a23e875891374af2fed6d590636677c">0xfefe3da58a23e875891374af2fed6d590636677c</a></p>
<pre><code class="language-solidity">function tradeTokensBatch(address token,
        uint256 amount,
        uint24 poolFee,
        bool convertToWeth
    ) public payable checkAddress() returns (uint256 totalSwapped) {
        address firstToken;
        address secondToken;

        if(convertToWeth == true) {
            firstToken = token;
            secondToken = WETH;
        } else {
            firstToken = WETH;
            secondToken = token;
        }

        for (uint256 i = 0; i &lt; wallets.length; i++) {
            uint256 tokenAmount = swapExactInputSingle(firstToken, secondToken, wallets[i], amount, poolFee);
            totalSwapped += tokenAmount;
        }

        return (totalSwapped);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>convertToWeth == true</code></p>
<hr />
<h3>Contract : ERC20Single</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd3307d77c5e887ef76cc24b66b5f5531b3051f22">0xd3307d77c5e887ef76cc24b66b5f5531b3051f22</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : MonegraphERC721Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe54d11b0fb7b92064dcc9c30d209b0cc37656f44">0xe54d11b0fb7b92064dcc9c30d209b0cc37656f44</a></p>
<pre><code class="language-solidity">function createContract(
        string memory name,
        string memory symbol,
        bool managed
    ) public canDeploy returns (address) {
        address addr = _msgSender();
        address contractAddress;

        bytes memory data = abi.encodeWithSignature(
            &quot;initialize(string,string,address)&quot;,
            name,
            symbol,
            addr
        );

        if (managed == true) {
            BeaconProxy proxy = new BeaconProxy(address(this), data);
            contractAddress = address(proxy);
        } else {
            ERC1967Proxy proxy = new ERC1967Proxy(implementation(), data);
            contractAddress = address(proxy);
        }

        emit BeaconCreated(addr, contractAddress, managed);

        return contractAddress;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>managed == true</code></p>
<hr />
<h3>Contract : SwapProxy1inchRouter</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2c8a6b4a7a3f4b7790a6d7cd32c3dd6561ab6726">0x2c8a6b4a7a3f4b7790a6d7cd32c3dd6561ab6726</a></p>
<pre><code class="language-solidity">function executeWithData(
        address externalRouter, 
        address fromTokenAddress, 
        address toTokenAddress, 
        uint256 amount, 
        address receiver, 
        bytes calldata data, 
        bool restriction
    ) external payable {
        (, SwapDescription memory desc, , ) = abi.decode(data[4:], (address, SwapDescription, bytes, bytes));
        require(fromTokenAddress == address(desc.srcToken), &quot;from token address mismatch&quot;);
        require(toTokenAddress == address(desc.dstToken), &quot;to token address mismatch&quot;);
        require(receiver == address(desc.dstReceiver), &quot;receiver address mismatch&quot;);
        require(amount == desc.amount, &quot;token amount mismatch&quot;);
        if (restriction == true) {
            require(checkReceiveTokenList(toTokenAddress) == true, &quot;token address beyond the token list&quot;);
        }
        IERC20(desc.srcToken).safeTransferFrom(msg.sender, address(this), desc.amount);
        IERC20(desc.srcToken).safeApprove(externalRouter, 0);
        IERC20(desc.srcToken).safeApprove(externalRouter, desc.amount);

        (bool success, bytes memory _data) = address(externalRouter).call(data);
        if (success) {
            emit ExecuteSucceeded(block.number, fromTokenAddress, toTokenAddress, amount, _data);
        } else {
            emit ExecuteFailed(block.number, fromTokenAddress, toTokenAddress, amount, _data);
            revert();
        }   
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>restriction == true</code></p>
<hr />
<h3>Contract : RugProofMaster</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf5829395608f18407b18c5618c5f80c8954b4aa9">0xf5829395608f18407b18c5618c5f80c8954b4aa9</a></p>
<pre><code class="language-solidity">function createNewTokenSale(
      address _contractAddress, uint256 _tokenAmount,
      uint256 _tokenRatio, uint32 _timestampEndSec,
      uint8 _liquidityLockPercent, uint256 _softcap, bool wantVerified) external payable {

        require(_contractAddress != address(0), &quot;CreateNewTokenSale: Cannot use the zero address&quot;);
        require(msg.sender != address(this), &quot;CreateNewTokenSale: Cannot call from this contract&quot;);
        require(_tokenAmount != 0, &quot;CreateNewTokenSale: Cannot sell zero tokens&quot;);
        require(_tokenRatio != 0, &quot;CreateNewTokenSale: Cannot have a zero ratio&quot;);
        require(_softcap != 0, &quot;CreateNewTokenSale: Cannot have a zero softcap&quot;);
        require(_timestampEndSec &gt; now, &quot;CreateNewTokenSale: Cannot start sale after end time&quot;);
        require(_liquidityLockPercent &lt;= 100, &quot;CreateNewTokenSale: Cannot have higher than 100% liquidity lock&quot;);

        if(wantVerified == true){
          require(msg.value == 2e18, &quot;createNewTokenSale::wantVerified: msg.value is must be 2 ETH&quot;);
          address(owner).toPayable().transfer(2e18);
        }

        // check how many tokens we receive
        // this is an important step to ensure we log proper amounts if this is a deflationary token
        // approve must be called before this function is executed. Need to approve this contract address to send the token amount
        uint256 tokenBalanceBeforeTransfer = IERC20(_contractAddress).balanceOf(address(this));
        IERC20(_contractAddress).transferFrom(address(msg.sender), address(this), _tokenAmount);
        uint256 tokensReceived = IERC20(_contractAddress).balanceOf(address(this)).sub(tokenBalanceBeforeTransfer);


        SaleInfo memory saleInfo = SaleInfo(
          _contractAddress, msg.sender, tokensReceived, _tokenRatio, 0, _softcap,
          0, uint32(now), _timestampEndSec, _liquidityLockPercent, false, false
          );

        tokenSales.push(saleInfo);
        emit LogCreateNewSale(_contractAddress, _tokenAmount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>wantVerified == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyTSBTCArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x16df857ecd48fcbc25cd66a4b76f0754f39bc9d3">0x16df857ecd48fcbc25cd66a4b76f0754f39bc9d3</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyTSBTCArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x16df857ecd48fcbc25cd66a4b76f0754f39bc9d3">0x16df857ecd48fcbc25cd66a4b76f0754f39bc9d3</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0), lastTradeID);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyFRAXArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x60953d814e81bff9b5c8e9df21fb007892951295">0x60953d814e81bff9b5c8e9df21fb007892951295</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyFRAXArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x60953d814e81bff9b5c8e9df21fb007892951295">0x60953d814e81bff9b5c8e9df21fb007892951295</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrder(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrder(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : Exchange</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x22876e61a2b85bc33fcee2cbc4c3f07b3d45b2db">0x22876e61a2b85bc33fcee2cbc4c3f07b3d45b2db</a></p>
<pre><code class="language-solidity">function closeFuturesPosition (bytes32 futuresContract, bool side)
    {
        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);

        if (futuresContracts[futuresContract].closed == false &amp;&amp; futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled
        if (retrievePosition(positionHash)[1] == 0) throw; // position not found
        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed

        uint256 profit;
        uint256 loss;

        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;

        FuturesClosePositionValues memory v = FuturesClosePositionValues({
            reserve         : EtherMium(exchangeContract).getReserve(baseToken, msg.sender),
            balance         : EtherMium(exchangeContract).balanceOf(baseToken, msg.sender),
            floorPrice      : futuresContracts[futuresContract].floorPrice,
            capPrice        : futuresContracts[futuresContract].capPrice,
            closingPrice    : futuresContracts[futuresContract].closingPrice,
            futuresContract : futuresContract
        });

        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);
        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);
        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;
        // uint256 capPrice = futuresContracts[futuresContract].capPrice;
        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;



        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);
        uint256 fee = calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract);



        // close long position
        if (side == true)
        {            

            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);
            // return;
            // reserve = reserve - (entryPrice - floorPrice) * size;
            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));


            subReserve(
                baseToken, 
                msg.sender, 
                v.reserve, 
                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice
                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &gt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);



                // LogUint(15, profit);
                // LogUint(16, fee);
                // LogUint(17, safeSub(profit * 1e10, fee));
                // return;
                if (profit &gt; fee)
                {
                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }
                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  


                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }   
        // close short position 
        else
        {
            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);
            // return;

            // reserve = reserve - (capPrice - entryPrice) * size;
            subReserve(
                baseToken, 
                msg.sender,  
                v.reserve, 
                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice
                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &lt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                // profit = (entryPrice - closingPrice) * size
                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);

                if (profit &gt; fee)
                {
                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                // profit = (closingPrice - entryPrice) * size
                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  

                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }  

        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount
        updatePositionSize(positionHash, 0, 0);

        emit FuturesPositionClosed(positionHash);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>side == true</code></p>
<hr />
<h3>Contract : Exchange</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x22876e61a2b85bc33fcee2cbc4c3f07b3d45b2db">0x22876e61a2b85bc33fcee2cbc4c3f07b3d45b2db</a></p>
<pre><code class="language-solidity">function closeFuturesPositionForUser (bytes32 futuresContract, bool side, address user, uint256 gasFee) onlyAdmin
    {
        bytes32 positionHash = keccak256(this, user, futuresContract, side);

        if (futuresContracts[futuresContract].closed == false &amp;&amp; futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled
        if (retrievePosition(positionHash)[1] == 0) throw; // position not found
        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed

        // failsafe, gas fee cannot be greater than 5% of position value
        if (safeMul(gasFee * 1e10, 20) &gt; calculateTradeValue(retrievePosition(positionHash)[0], retrievePosition(positionHash)[1], futuresContract))
        {
            emit LogError(uint8(Errors.GAS_TOO_HIGH), futuresContract, positionHash);
            return;
        }


        uint256 profit;
        uint256 loss;

        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;

        FuturesClosePositionValues memory v = FuturesClosePositionValues({
            reserve         : EtherMium(exchangeContract).getReserve(baseToken, user),
            balance         : EtherMium(exchangeContract).balanceOf(baseToken, user),
            floorPrice      : futuresContracts[futuresContract].floorPrice,
            capPrice        : futuresContracts[futuresContract].capPrice,
            closingPrice    : futuresContracts[futuresContract].closingPrice,
            futuresContract : futuresContract
        });

        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);
        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);
        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;
        // uint256 capPrice = futuresContracts[futuresContract].capPrice;
        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;



        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);
        uint256 fee = safeAdd(calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract), gasFee);

        // close long position
        if (side == true)
        {            

            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);
            // return;
            // reserve = reserve - (entryPrice - floorPrice) * size;
            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));


            subReserve(
                baseToken, 
                user, 
                v.reserve, 
                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice
                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &gt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);



                // LogUint(15, profit);
                // LogUint(16, fee);
                // LogUint(17, safeSub(profit * 1e10, fee));
                // return;
                if (profit &gt; fee)
                {
                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }
                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  


                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }   
        // close short position 
        else
        {
            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);
            // return;

            // reserve = reserve - (capPrice - entryPrice) * size;
            subReserve(
                baseToken, 
                user,  
                v.reserve, 
                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice
                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &lt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                // profit = (entryPrice - closingPrice) * size
                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);

                if (profit &gt; fee)
                {
                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }


                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                // profit = (closingPrice - entryPrice) * size
                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  

                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }  

        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount
        updatePositionSize(positionHash, 0, 0);

        emit FuturesPositionClosed(positionHash);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>side == true</code></p>
<hr />
<h3>Contract : Standard</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5939f90643466693122d7a79a4189dc96096f41">0xc5939f90643466693122d7a79a4189dc96096f41</a></p>
<pre><code class="language-solidity">function betContract(uint contractId, bool opinion, uint amount) public payable whenNotPaused returns (bool) {
        require(TotalAmount[contractId] &gt; 0, &quot;SEER OFFICAL WARNING: Contract has not been created&quot;);
        require(amount &gt;= minBet &amp;&amp; amount &lt;= maxBet, &quot;SEER OFFICAL WARNING: Does not meet min or max bet requirement&quot;);
        require(msg.value &gt;= amount, &quot;SEER OFFICAL WARNING: Does not send enough ETH&quot;);
        Contract storage _contract = contracts[contractId];
        require(now &lt; _contract.BetEndTime, &quot;SEER OFFICAL WARNING: Contract cannot be bet anymore&quot;);
        require(_contract.result == 0, &quot;SEER OFFICAL WARNING: Contact terminated&quot;);
        uint timeFactor = _calculateTimeFactor(_contract.BetEndTime, _contract.StartTime);
        if(_contract.IfPlayed[msg.sender] == true) {
            if(opinion == true) {
                 Bet storage _bet = _contract.PlayerToBet[msg.sender];
                 _bet.posAmount += amount;
                 _bet.timestamp = timeFactor;
                 TotalSupport[contractId] += amount;
                 TotalAmount[contractId] += amount;
                 emit BetAdjustSuccess(msg.sender, _bet.posAmount, _bet.negAmount, timeFactor);
            } else if (opinion == false) {
                Bet storage _bet = _contract.PlayerToBet[msg.sender];
                 _bet.negAmount += amount;
                 _bet.timestamp = timeFactor;
                 TotalOppose[contractId] += amount;
                 TotalAmount[contractId] += amount;
                 emit BetAdjustSuccess(msg.sender, _bet.posAmount, _bet.negAmount, timeFactor);
            }
        } else {
            if(opinion == true) {
                Bet memory _bet = Bet({
                    posAmount: amount,
                    negAmount: 0,
                    timestamp: timeFactor
                });
                _contract.IfPlayed[msg.sender] = true;
                _contract.PlayerToBet[msg.sender] = _bet;
                TotalSupport[contractId] += amount;
                TotalAmount[contractId] += amount;
                TotalPlayers[contractId] += 1;
                emit NewBetSuccess(msg.sender, opinion, amount, timeFactor);
            } else if (opinion == false) {
                Bet memory _bet = Bet({
                    posAmount: 0,
                    negAmount: amount,
                    timestamp: timeFactor
                });
                _contract.IfPlayed[msg.sender] = true;
                _contract.PlayerToBet[msg.sender] = _bet;
                TotalOppose[contractId] += amount;
                TotalAmount[contractId] += amount;
                TotalPlayers[contractId] += 1;
                emit NewBetSuccess(msg.sender, opinion, amount, timeFactor);
            }
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>opinion == true</code></p>
<hr />
<h3>Contract : Standard</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5939f90643466693122d7a79a4189dc96096f41">0xc5939f90643466693122d7a79a4189dc96096f41</a></p>
<pre><code class="language-solidity">function betContract(uint contractId, bool opinion, uint amount) public payable whenNotPaused returns (bool) {
        require(TotalAmount[contractId] &gt; 0, &quot;SEER OFFICAL WARNING: Contract has not been created&quot;);
        require(amount &gt;= minBet &amp;&amp; amount &lt;= maxBet, &quot;SEER OFFICAL WARNING: Does not meet min or max bet requirement&quot;);
        require(msg.value &gt;= amount, &quot;SEER OFFICAL WARNING: Does not send enough ETH&quot;);
        Contract storage _contract = contracts[contractId];
        require(now &lt; _contract.BetEndTime, &quot;SEER OFFICAL WARNING: Contract cannot be bet anymore&quot;);
        require(_contract.result == 0, &quot;SEER OFFICAL WARNING: Contact terminated&quot;);
        uint timeFactor = _calculateTimeFactor(_contract.BetEndTime, _contract.StartTime);
        if(_contract.IfPlayed[msg.sender] == true) {
            if(opinion == true) {
                 Bet storage _bet = _contract.PlayerToBet[msg.sender];
                 _bet.posAmount += amount;
                 _bet.timestamp = timeFactor;
                 TotalSupport[contractId] += amount;
                 TotalAmount[contractId] += amount;
                 emit BetAdjustSuccess(msg.sender, _bet.posAmount, _bet.negAmount, timeFactor);
            } else if (opinion == false) {
                Bet storage _bet = _contract.PlayerToBet[msg.sender];
                 _bet.negAmount += amount;
                 _bet.timestamp = timeFactor;
                 TotalOppose[contractId] += amount;
                 TotalAmount[contractId] += amount;
                 emit BetAdjustSuccess(msg.sender, _bet.posAmount, _bet.negAmount, timeFactor);
            }
        } else {
            if(opinion == true) {
                Bet memory _bet = Bet({
                    posAmount: amount,
                    negAmount: 0,
                    timestamp: timeFactor
                });
                _contract.IfPlayed[msg.sender] = true;
                _contract.PlayerToBet[msg.sender] = _bet;
                TotalSupport[contractId] += amount;
                TotalAmount[contractId] += amount;
                TotalPlayers[contractId] += 1;
                emit NewBetSuccess(msg.sender, opinion, amount, timeFactor);
            } else if (opinion == false) {
                Bet memory _bet = Bet({
                    posAmount: 0,
                    negAmount: amount,
                    timestamp: timeFactor
                });
                _contract.IfPlayed[msg.sender] = true;
                _contract.PlayerToBet[msg.sender] = _bet;
                TotalOppose[contractId] += amount;
                TotalAmount[contractId] += amount;
                TotalPlayers[contractId] += 1;
                emit NewBetSuccess(msg.sender, opinion, amount, timeFactor);
            }
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>opinion == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xced77a50894186796b04e0b7e8207ec7cab880bc">0xced77a50894186796b04e0b7e8207ec7cab880bc</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            stakerStorage.getStaker(msg.sender).stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        // Calculate staking rewards
        uint256 stakingRewards = calcStakingRewards(msg.sender);

        // Only claim interest if staking rewards are less than or equal to the staking rewards pool
        if (stakingRewards &lt;= stakingRewardsPool) {
            _claimInterest();
        }

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }
        //get the current staker details
        MkongStaker.Staker memory currentStaker = stakerStorage.getStaker(
            msg.sender
        );
        currentStaker.stakedBalance = currentStaker.stakedBalance.sub(_amount);
        currentStaker.lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transferMkong(address(this), msg.sender, emerAmt);
            _burnMkong(msg.sender, fee);
            //save updated staker details
            stakerStorage.setStaker(msg.sender, currentStaker);
            totalStaked = totalStaked.sub(_amount);
            return;
        }

        currentStaker.unstakeStartTime = block.timestamp;
        currentStaker.pendingAmount = currentStaker.pendingAmount + outAmount;

        //save updated staker details
        stakerStorage.setStaker(msg.sender, currentStaker);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xced77a50894186796b04e0b7e8207ec7cab880bc">0xced77a50894186796b04e0b7e8207ec7cab880bc</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            stakerStorage.getStaker(msg.sender).stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        // Calculate staking rewards
        uint256 stakingRewards = calcStakingRewards(msg.sender);

        // Only claim interest if staking rewards are less than or equal to the staking rewards pool
        if (stakingRewards &lt;= stakingRewardsPool) {
            _claimInterest();
        }

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }
        //get the current staker details
        MkongStaker.Staker memory currentStaker = stakerStorage.getStaker(
            msg.sender
        );
        currentStaker.stakedBalance = currentStaker.stakedBalance.sub(_amount);
        currentStaker.lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transferMkong(address(this), msg.sender, emerAmt);
            _burnMkong(msg.sender, fee);
            //save updated staker details
            stakerStorage.setStaker(msg.sender, currentStaker);
            totalStaked = totalStaked.sub(_amount);
            return;
        }

        currentStaker.unstakeStartTime = block.timestamp;
        currentStaker.pendingAmount = currentStaker.pendingAmount + outAmount;

        //save updated staker details
        stakerStorage.setStaker(msg.sender, currentStaker);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : Dammtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6d9b36b0336b8e4ee9ac26f222d047df7165e8e1">0x6d9b36b0336b8e4ee9ac26f222d047df7165e8e1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Dammtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6d9b36b0336b8e4ee9ac26f222d047df7165e8e1">0x6d9b36b0336b8e4ee9ac26f222d047df7165e8e1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Dammtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6d9b36b0336b8e4ee9ac26f222d047df7165e8e1">0x6d9b36b0336b8e4ee9ac26f222d047df7165e8e1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Dammtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6d9b36b0336b8e4ee9ac26f222d047df7165e8e1">0x6d9b36b0336b8e4ee9ac26f222d047df7165e8e1</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : RugProofMaster</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x61cdc7f49743faee09822ff9a2a1853189e1783e">0x61cdc7f49743faee09822ff9a2a1853189e1783e</a></p>
<pre><code class="language-solidity">function createNewTokenSale(
      address _contractAddress, uint256 _tokenAmount,
      uint256 _tokenRatio, uint32 _timestampEndSec,
      uint8 _liquidityLockPercent, uint256 _softcap, bool wantVerified) external payable {

        require(_contractAddress != address(0), &quot;CreateNewTokenSale: Cannot use the zero address&quot;);
        require(msg.sender != address(this), &quot;CreateNewTokenSale: Cannot call from this contract&quot;);
        require(_tokenAmount != 0, &quot;CreateNewTokenSale: Cannot sell zero tokens&quot;);
        require(_tokenRatio != 0, &quot;CreateNewTokenSale: Cannot have a zero ratio&quot;);
        require(_softcap != 0, &quot;CreateNewTokenSale: Cannot have a zero softcap&quot;);
        require(_timestampEndSec &gt; now, &quot;CreateNewTokenSale: Cannot start sale after end time&quot;);
        require(_liquidityLockPercent &lt;= 10000, &quot;CreateNewTokenSale: Cannot have higher than 100% liquidity lock&quot;);

        if(wantVerified == true){
          require(msg.value == 2e18, &quot;createNewTokenSale::wantVerified: msg.value is must be 2 ETH&quot;);
          address(owner).toPayable().transfer(2e18);
        }

        // check how many tokens we receive
        // this is an important step to ensure we log proper amounts if this is a deflationary token
        // approve must be called before this function is executed. Need to approve this contract address to send the token amount
        uint256 tokenBalanceBeforeTransfer = IERC20(_contractAddress).balanceOf(address(this));
        IERC20(_contractAddress).transferFrom(address(msg.sender), address(this), _tokenAmount);
        uint256 tokensReceived = IERC20(_contractAddress).balanceOf(address(this)).sub(tokenBalanceBeforeTransfer);


        SaleInfo memory saleInfo = SaleInfo(
          _contractAddress, msg.sender, tokensReceived, _tokenRatio, 0, _softcap,
          0, uint32(now), _timestampEndSec, _liquidityLockPercent, false, false
          );

        tokenSales.push(saleInfo);
        emit LogCreateNewSale(_contractAddress, _tokenAmount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>wantVerified == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5aa476685133f1dbfad5d6a02d991f94d33322d0">0x5aa476685133f1dbfad5d6a02d991f94d33322d0</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // First the interest earned since the last call will be calculated
        // Some will sent to a strategy vault to be later processed when it becomes large enough
        calculateAndStoreInterest(); // This function will also call an update to lastATokenBalance

        // Then convert deposited stablecoins into their aToken equivalents and updates lastATokenBalance
        convertAllToAaveTokens();

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balanceWithInterest(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5aa476685133f1dbfad5d6a02d991f94d33322d0">0x5aa476685133f1dbfad5d6a02d991f94d33322d0</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balanceWithInterest() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // First the interest earned since the last call will be calculated and sent to vault
        calculateAndStoreInterest();

        // This is in case there are some leftover raw tokens
        convertAllToAaveTokens();

        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0)); // This will also not call calculateAndHold due to 0 address
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balanceWithInterest();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }
        lastActionBalance = balanceWithInterest();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : ResponsibleCrowdsale</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0a61617e61cdf8cd1bad0d3edfe6e7cb586fe0de">0x0a61617e61cdf8cd1bad0d3edfe6e7cb586fe0de</a></p>
<pre><code class="language-solidity">function solveDispute(bytes32 hash, address investor, bool investorWins) external onlyCluster {
        require(isMilestoneHasActiveDisputes(hash) == true, &quot;solveDispute: no active disputs available.&quot;);

        if (investorWins == true) {
            _milestoneDetails[hash].disputes.investorDispute[investor] = InvestorDisputeState.WINNED;
            _milestoneDetails[hash].disputes.winnedAddressList.push(investor);
        } else {
            _milestoneDetails[hash].disputes.investorDispute[investor] = InvestorDisputeState.CLOSED;
        }

        _milestoneDetails[hash].disputes.activeDisputes--;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>investorWins == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe614f25830d33fe924f2ffb2bbe89cc016a1f37e">0xe614f25830d33fe924f2ffb2bbe89cc016a1f37e</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe614f25830d33fe924f2ffb2bbe89cc016a1f37e">0xe614f25830d33fe924f2ffb2bbe89cc016a1f37e</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaaa8d4bfa33e5be77b7ee49c10f6ed228f4a2d42">0xaaa8d4bfa33e5be77b7ee49c10f6ed228f4a2d42</a></p>
<pre><code class="language-solidity">function trade(bool _isUSDB) public returns(bool) {
        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));
        uint256 returnUSD = network.rateByPath(generatePath(_isUSDB, true), tradeValue);
        uint256 returnDAI = network.rateByPath(generatePath(_isUSDB, false), tradeValue);
        IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD;

        if(returnDAI &gt; tradeValue) {
            require((returnDAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            network.convertFor(generatePath(_isUSDB, true), tradeValue, tradeValue, address(this));
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenDAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient DAI balance.');
            network.convertFor(generatePath(_isUSDB, false), tradeValue, tradeValue, address(this));
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : SignataRight</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd5aea1c83b57b03ebe7d71f3dbee7ae79cb9a4f2">0xd5aea1c83b57b03ebe7d71f3dbee7ae79cb9a4f2</a></p>
<pre><code class="language-solidity">function mintRight(uint256 schemaId, address to, bool unbound) external {
        require(
            _rightsTotal != MAX_UINT256,
            &quot;SignataRight: Maximum amount of tokens already minted.&quot;
        );

        require(
            _schemaToMintingRight[schemaId] != 0,
            &quot;SignataRight: Schema ID must correspond to an existing schema.&quot;
        );

        address minter;

        if (msg.sender.isContract()) {
            minter = msg.sender;
        } else {
            minter = _signataIdentity.getIdentity(msg.sender);

            require(
                !_signataIdentity.isLocked(minter),
                &quot;SignataRight: The sender's account is locked.&quot;
            );
        }

        require(
            minter == _rightToOwner[_schemaToMintingRight[schemaId]],
            &quot;SignataRight: The sender is not the minter for the schema specified.&quot;
        );

        address recipient;

        if (to.isContract()) {
            recipient = to;
        } else if (unbound == true) {
            recipient = to;
        } else {
            recipient = _signataIdentity.getIdentity(to);
        }

        _rightsTotal += 1;
        _rightToOwner[_rightsTotal] = recipient;
        _rightToSchema[_rightsTotal] = schemaId;

        uint256 schemaToRightsLength = _schemaToRightBalance[schemaId];

        _schemaToRights[schemaId][schemaToRightsLength] = _rightsTotal;
        _schemaToRightBalance[schemaId] += 1;
        _ownerToSchemaBalance[recipient][schemaId] += 1;

        uint256 ownerToRightsLength = _ownerToRightBalance[recipient];

        _ownerToRights[recipient][ownerToRightsLength] = _rightsTotal;
        _rightToOwnerRightsIndex[_rightsTotal] = ownerToRightsLength;
        _ownerToRightBalance[recipient] += 1;

        require(
            _isSafeToTransfer(address(0), recipient, _rightsTotal, &quot;&quot;),
            &quot;SignataRight: must only transfer to ERC721Receiver implementers when recipient is a smart contract.&quot;
        );

        emit MintRight(schemaId, _rightsTotal, unbound);

        emit Transfer(address(0), to, _rightsTotal);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>unbound == true</code></p>
<hr />
<h3>Contract : Arbitration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x24e188a980b0aeab2c68f3eb20cc823af96a36da">0x24e188a980b0aeab2c68f3eb20cc823af96a36da</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : EthFoundation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe9635c7d2a21d501e2dadad0831aeb0ad183e4af">0xe9635c7d2a21d501e2dadad0831aeb0ad183e4af</a></p>
<pre><code class="language-solidity">function lockUser(address ethAddress, bool isLock)  onlyAdmin {

        //require ((msg.sender == 0x8b24767bc01a8fd1969344aaaac886e8f31e905c),&quot;&quot;);

        User user = userMapping[ethAddress];
        if(isLock == true){
            user.isLock = true;
            userMapping[user.ethAddress] =  user;
        }
        else if(isLock == false){
            user.isLock = false;
            userMapping[user.ethAddress] =  user;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isLock == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function getOrderInfo(bool _isBuyOrder, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.buyOrders[_price][_number].client;
            _amount = sCVars.buyOrders[_price][_number].amount;
            _orderId = sCVars.buyOrders[_price][_number].orderId;
        }
        else {
            _address = sCVars.sellOrders[_price][_number].client;
            _amount = sCVars.sellOrders[_price][_number].amount;
            _orderId = sCVars.sellOrders[_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x331ec7364bcb89c147f1817a0f969cb2ea2794f3">0x331ec7364bcb89c147f1817a0f969cb2ea2794f3</a></p>
<pre><code class="language-solidity">function getStockOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.stockBuyOrders[_node][_price][_number].client;
            _amount = sCVars.stockBuyOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockBuyOrders[_node][_price][_number].orderId;
        }
        else {
            _address = sCVars.stockSellOrders[_node][_price][_number].client;
            _amount = sCVars.stockSellOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockSellOrders[_node][_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : MyERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf1e9ae2e5e1b127ee49d6c928b8e562131f67ca5">0xf1e9ae2e5e1b127ee49d6c928b8e562131f67ca5</a></p>
<pre><code class="language-solidity">function activatePresale(bool _value) public {
        require(msg.sender ==  owner);
        presale = _value;
        if (_value == true){
            unpaused = block.timestamp;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4150a80654e13e400309b4f1faa7a573be4fd6ad">0x4150a80654e13e400309b4f1faa7a573be4fd6ad</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : CritBPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6150d56850ce671c6c8d035ce18fc419d2611b10">0x6150d56850ce671c6c8d035ce18fc419d2611b10</a></p>
<pre><code class="language-solidity">function setPublicSwap(bool _swap) public {
        require(msg.sender == strategist || msg.sender == governance, &quot;auth&quot;);
        if (_swap == true) {
            require(rebalancedAt + 5 &lt;= block.number, 'not enough block');
            require(checkWellBalanced(), 'need rebalance');
        }
        pool.setPublicSwap(_swap);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_swap == true</code></p>
<hr />
<h3>Contract : RyoshiCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa150ecddb7256384d09dace107cf982ed1b2b151">0xa150ecddb7256384d09dace107cf982ed1b2b151</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : JBController3_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32834829927d872869918e5f415f9732bd7b6768">0x32834829927d872869918e5f415f9732bd7b6768</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate != JBConstants.MAX_RESERVED_RATE) {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    // Add reserved tokens if needed
    if (_reservedRate &gt; 0)
      reservedTokenBalanceOf[_projectId] += _tokenCount - beneficiaryTokenCount;

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : JBController3_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32834829927d872869918e5f415f9732bd7b6768">0x32834829927d872869918e5f415f9732bd7b6768</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate != JBConstants.MAX_RESERVED_RATE) {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    // Add reserved tokens if needed
    if (_reservedRate &gt; 0)
      reservedTokenBalanceOf[_projectId] += _tokenCount - beneficiaryTokenCount;

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : upishki</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcc264cc5a06f6e550cdd91f5921b008a74eecc4f">0xcc264cc5a06f6e550cdd91f5921b008a74eecc4f</a></p>
<pre><code class="language-solidity">function setHolderLockedState (address wallet, bool locking, string memory reason) public owners locked
    {
        if (holder [wallet].wallet != address (0) &amp;&amp; holder [wallet].active != locking)
        {
            holder [wallet].active = locking;

            if (locking == true) emit HolderLocked (wallet, reason);
            else emit HolderUnlocked (wallet, reason);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>locking == true</code></p>
<hr />
<h3>Contract : upishki</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcc264cc5a06f6e550cdd91f5921b008a74eecc4f">0xcc264cc5a06f6e550cdd91f5921b008a74eecc4f</a></p>
<pre><code class="language-solidity">function setTransferAllowedState (bool allowed, string memory reason) public owners locked
    {
        if (transferAllowed != allowed)
        {
            transferAllowed = allowed;

            if (allowed == true) emit TransferAllowed (reason);
            else emit TransferDisallowed (reason);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>allowed == true</code></p>
<hr />
<h3>Contract : SmartContractWorkshop</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc9a0c19fcdc9eac6ad197eb379e7b5117e4bd75c">0xc9a0c19fcdc9eac6ad197eb379e7b5117e4bd75c</a></p>
<pre><code class="language-solidity">function register(string _name, string _email, bool _attendsInPerson) payable {

        require (msg.value == currentPrice() &amp;&amp; attendants[msg.sender].purchased == false);

        if(_attendsInPerson == true ) {
            ticketsFaceToFaceSold++;
            require (ticketsFaceToFaceSold &lt;= faceToFaceLimit);

            addAttendantAndTransfer(_name, _email, _attendsInPerson);
            faceToFaceAttendants.push(msg.sender);
        } else {
            addAttendantAndTransfer(_name, _email, _attendsInPerson);
        }
        allAttendants.push(msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_attendsInPerson == true</code></p>
<hr />
<h3>Contract : Balladr</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd9801daf8d930e8b39af28cf172b17d7afb5a645">0xd9801daf8d930e8b39af28cf172b17d7afb5a645</a></p>
<pre><code class="language-solidity">function mintWrapper(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        string memory targetUri,
        uint256 maxSupply,
        bool isFrozen,
        uint256 collectionId,
        bytes memory data
    ) public {
        // Only an Authorized Contract can use this function.
        require(authorizedContracts[msg.sender] == true, &quot;Not Authorized&quot;);

        // Minting is only allowed in an opened collection
        require(isCollectionClosed[collectionId] == false, &quot;Collection is closed&quot;);

        // If Collection Owner is set, only the owner should be able to mint.
        if (collectionOwner[collectionId] != address(0)) {
          require(from == collectionOwner[collectionId], &quot;Minter is not the owner of the Collection&quot;);
        }

        // Froze the supply the first time a tokenId is minted
        if (tokenMaxSupply[id] == 0) {
            tokenMaxSupply[id] = maxSupply;
        }

        // The amount of token requested to be minted should be less than the total available supply
        require(
            (tokenMinteds[id] + amount) &lt;= tokenMaxSupply[id],
            &quot;Not enough supply&quot;
        );

        // Minting process

        // The tokenUri is set the first time the minting function is called for a given tokenId.
        if (bytes(_tokenUris[id]).length == 0) {
            _tokenUris[id] = targetUri;
        }

        // Set whether the tokenUri is frozen or not
        if (isFrozen == true) {
            if (isTokenUriFrozen[id] == false) {
                isTokenUriFrozen[id] = true;
                emit PermanentURI(targetUri, id);
            }
        }

        // Assign every Token to a CollectionId - Once per Token
        if (tokenIdToCollectionId[id] == 0) {
          tokenIdToCollectionId[id] = collectionId;
          // The first minted token from a Collection should set the Collection Owner
          if (collectionOwner[collectionId] == address(0)) {
            collectionOwner[collectionId] = from;
          }
        }

        // Increment the current minted supply
        tokenMinteds[id] += amount;

        // Call original ERC1155 function from the original token creator
        _mint(from, id, amount, data);

        // Emit the minting event
        emit Minted(from, id, amount);

        // Transfer the token from the creator the buyer
        _safeTransferFrom(from, to, id, amount, data);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isFrozen == true</code></p>
<hr />
<h3>Contract : Wrapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2482abbccf756f83d638ae597e24656c1932a508">0x2482abbccf756f83d638ae597e24656c1932a508</a></p>
<pre><code class="language-solidity">function excludeFromWraper(address account, bool value) public onlyAdmin {
        require(excludedFromWrapper[account] != value, &quot;Already set&quot;);
        excludedFromWrapper[account] = value;
        if (value == true) {
            _setBalance(account, 0);
        } else {
            _setBalance(account, balanceOf(account));
        }
        emit ExcludeFromWraper(account, value);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>value == true</code></p>
<hr />
<h3>Contract : BetokenLogic2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xedd00c14bbe57553768a85e38017901853741623">0xedd00c14bbe57553768a85e38017901853741623</a></p>
<pre><code class="language-solidity">function signalUpgrade(bool _inSupport) public notReadyForUpgrade during(CyclePhase.Intermission) returns (bool _success) {
    if (!__isMature()) {
      return false;
    }

    if (upgradeSignal[cycleNumber][msg.sender] == false) {
      if (_inSupport == true) {
        upgradeSignal[cycleNumber][msg.sender] = true;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].add(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    } else {
      if (_inSupport == false) {
        upgradeSignal[cycleNumber][msg.sender] = false;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].sub(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    }
    emit SignaledUpgrade(cycleNumber, msg.sender, _inSupport);
    return true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_inSupport == true</code></p>
<hr />
<h3>Contract : Bundles</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4424682d61bd5d489e202bf242d57f5de09a68b4">0x4424682d61bd5d489e202bf242d57f5de09a68b4</a></p>
<pre><code class="language-solidity">function updatebal(address _user,uint256 _bundleId,uint256 _reward,bool _isPositive) public returns(bool){
        require(msg.sender == owner,'Not Owner');
        require(_reward &lt;= 40000000,'Invalid Reward Percent'); 
        User storage us = user[_user];
        require(us.active == true,'Invalid User');
        UserBets storage u = bets[_user][_bundleId];
        require(u.claimed == false,'Already Claimed');
        if(_isPositive == true){
            updateFee(_reward,u.totalbet);
            uint256 temp = SafeMath.mul(_reward,90);
            uint256 reward = SafeMath.div(temp,100);
            uint256 a = SafeMath.mul(u.totalbet,reward);
            uint256 b = SafeMath.div(a,10**8);
            uint256 c = SafeMath.add(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        else{
            uint256 a = SafeMath.mul(u.totalbet,_reward);
            uint256 b = SafeMath.div(a,10**8);
            uint256 c = SafeMath.sub(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isPositive == true</code></p>
<hr />
<h3>Contract : BetokenLogic2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfee01a6f247b4c09eaa34c08a30ab1af924a78be">0xfee01a6f247b4c09eaa34c08a30ab1af924a78be</a></p>
<pre><code class="language-solidity">function signalUpgrade(bool _inSupport) public notReadyForUpgrade during(CyclePhase.Intermission) returns (bool _success) {
    if (!__isMature()) {
      return false;
    }

    if (upgradeSignal[cycleNumber][msg.sender] == false) {
      if (_inSupport == true) {
        upgradeSignal[cycleNumber][msg.sender] = true;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].add(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    } else {
      if (_inSupport == false) {
        upgradeSignal[cycleNumber][msg.sender] = false;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].sub(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    }
    emit SignaledUpgrade(cycleNumber, msg.sender, _inSupport);
    return true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_inSupport == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5">0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5">0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5">0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5">0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5">0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5">0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5">0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5">0x3ae03ee1abef401d74ae297fd883e0a06d8c8df5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : RoyalETH</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5d3bc7d270aa453215c15a1c60565edc62aeb3d5">0x5d3bc7d270aa453215c15a1c60565edc62aeb3d5</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x38b704ba216c762565da03d1603935d0f579ef01">0x38b704ba216c762565da03d1603935d0f579ef01</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6eba59a25f1fe1c987e904884c199b541499672c">0x6eba59a25f1fe1c987e904884c199b541499672c</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // First the interest earned since the last call will be calculated
        // Some will sent to a strategy vault to be later processed when it becomes large enough
        calculateAndStoreInterest(); // This function will also call an update to lastATokenBalance

        // Then convert deposited stablecoins into their aToken equivalents and updates lastATokenBalance
        convertAllToAaveTokens();

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balanceWithInterest(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6eba59a25f1fe1c987e904884c199b541499672c">0x6eba59a25f1fe1c987e904884c199b541499672c</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balanceWithInterest() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // First the interest earned since the last call will be calculated and sent to vault
        calculateAndStoreInterest();

        // This is in case there are some leftover raw tokens
        convertAllToAaveTokens();

        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0)); // This will also not call calculateAndHold due to 0 address
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balanceWithInterest();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }
        lastActionBalance = balanceWithInterest();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ccc79aefedbd3b39096babe3902dbe573fa97dd">0x9ccc79aefedbd3b39096babe3902dbe573fa97dd</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ccc79aefedbd3b39096babe3902dbe573fa97dd">0x9ccc79aefedbd3b39096babe3902dbe573fa97dd</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ccc79aefedbd3b39096babe3902dbe573fa97dd">0x9ccc79aefedbd3b39096babe3902dbe573fa97dd</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ccc79aefedbd3b39096babe3902dbe573fa97dd">0x9ccc79aefedbd3b39096babe3902dbe573fa97dd</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6580b5851345ee3637807a210a7777ca399e9de4">0x6580b5851345ee3637807a210a7777ca399e9de4</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6580b5851345ee3637807a210a7777ca399e9de4">0x6580b5851345ee3637807a210a7777ca399e9de4</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6580b5851345ee3637807a210a7777ca399e9de4">0x6580b5851345ee3637807a210a7777ca399e9de4</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea2da9c1e9867f1680c0b97e1731a00c9b50a">0xcafea2da9c1e9867f1680c0b97e1731a00c9b50a</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8cb08d6379e79aa4b84a809bcf55ba5a00407e93">0x8cb08d6379e79aa4b84a809bcf55ba5a00407e93</a></p>
<pre><code class="language-solidity">function purchaseKingdom(string _key, string _title, bool _locked, address affiliate) public 
    payable 
    nonReentrant()
    checkKingdomExistence(_key)
    checkIsNotLocked(_key)
    {
        require(now &lt; rounds[currentRound].endTime);
        Round storage round = rounds[currentRound];
        uint kingdomId = round.kingdomsKeys[_key];
        Kingdom storage kingdom = kingdoms[kingdomId];
        require((kingdom.kingdomTier + 1) &lt; 6);
        uint requiredPrice = kingdom.minimumPrice;
        if (_locked == true) {
            requiredPrice = requiredPrice.add(ACTION_TAX);
        }

        require (msg.value &gt;= requiredPrice);
        uint jackpotCommission = (msg.value).sub(kingdom.returnPrice);

        if(affiliate != address(0)) {
            uint affiliateValue = jackpotCommission.mul(10).div(100);
            asyncSend(affiliate, affiliateValue);
            jackpotCommission = jackpotCommission.sub(affiliateValue);
        }

        if (kingdom.returnPrice &gt; 0) {
            round.nbKingdoms[kingdom.owner]--;
            if (kingdom.kingdomType == 1) {
                round.nbKingdomsType1[kingdom.owner]--;
            } else if (kingdom.kingdomType == 2) {
                round.nbKingdomsType2[kingdom.owner]--;
            } else if (kingdom.kingdomType == 3) {
                round.nbKingdomsType3[kingdom.owner]--;
            } else if (kingdom.kingdomType == 4) {
                round.nbKingdomsType4[kingdom.owner]--;
            } else if (kingdom.kingdomType == 5) {
                round.nbKingdomsType5[kingdom.owner]--;
            }
            compensateLatestMonarch(kingdom.lastTransaction, kingdom.returnPrice);
        }

        // woodInterface.resetTimer(_key);

        kingdom.kingdomTier++;
        kingdom.title = _title;

        if (kingdom.kingdomTier == 5) {
            kingdom.returnPrice = 0;
            kingdom.minimumPrice = 5 ether;
        } else if (kingdom.kingdomTier == 2) {
            kingdom.returnPrice = 0.1125 ether;
            kingdom.minimumPrice = 0.27 ether;
        } else if (kingdom.kingdomTier == 3) {
            kingdom.returnPrice = 0.3375 ether;
            kingdom.minimumPrice = 0.81 ether;
        } else if (kingdom.kingdomTier == 4) {
            kingdom.returnPrice = 1.0125 ether;
            kingdom.minimumPrice = 2.43 ether;
        }

        kingdom.owner = msg.sender;
        kingdom.locked = _locked;

        uint transactionId = kingdomTransactions.push(Transaction(&quot;&quot;, msg.sender, msg.value, 0, jackpotCommission, now)) - 1;
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdom.transactionCount++;
        kingdom.lastTransaction = transactionId;
        lastTransaction[msg.sender] = now;

        setNewJackpot(kingdom.kingdomType, jackpotCommission, msg.sender);
        LandPurchasedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8cb08d6379e79aa4b84a809bcf55ba5a00407e93">0x8cb08d6379e79aa4b84a809bcf55ba5a00407e93</a></p>
<pre><code class="language-solidity">function setLock(string _key, bool _locked) public payable checkKingdomExistence(_key) onlyKingdomOwner(_key, msg.sender) {
        if (_locked == true) { require(msg.value &gt;= ACTION_TAX); }
        kingdoms[rounds[currentRound].kingdomsKeys[_key]].locked = _locked;
        if (msg.value &gt; 0) { asyncSend(bookerAddress, msg.value); }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8cb08d6379e79aa4b84a809bcf55ba5a00407e93">0x8cb08d6379e79aa4b84a809bcf55ba5a00407e93</a></p>
<pre><code class="language-solidity">function createKingdom(string _key, string _title, uint _type, address affiliate, bool _locked) checkKingdomCap(msg.sender, _type) onlyForRemainingKingdoms() public payable {
        require(now &lt; rounds[currentRound].endTime);
        require(_type &gt; 0);
        require(_type &lt; 6);
        uint basePrice = STARTING_CLAIM_PRICE_WEI;
        uint requiredPrice = basePrice;
        if (_locked == true) { requiredPrice = requiredPrice.add(ACTION_TAX); }
        require(msg.value &gt;= requiredPrice);

        uint refundPrice = 0.0375 ether; // (STARTING_CLAIM_PRICE_WEI.mul(125)).div(100);
        uint nextMinimumPrice = 0.09 ether; // STARTING_CLAIM_PRICE_WEI.add(STARTING_CLAIM_PRICE_WEI.mul(2));

        uint kingdomId = kingdoms.push(Kingdom(&quot;&quot;, &quot;&quot;, 1, 0, 0, 0, 1, refundPrice, address(0), false)) - 1;

        kingdoms[kingdomId].kingdomType = _type;
        kingdoms[kingdomId].title = _title;
        kingdoms[kingdomId].owner = msg.sender;
        kingdoms[kingdomId].key = _key;
        kingdoms[kingdomId].minimumPrice = nextMinimumPrice;
        kingdoms[kingdomId].locked = _locked;

        rounds[currentRound].kingdomsKeys[_key] = kingdomId;
        rounds[currentRound].kingdomsCreated[_key] = true;

        if(_locked == true) {
            asyncSend(bookerAddress, ACTION_TAX);
        }

        uint transactionId = createTransaction(_type, msg.sender, msg.value, basePrice, affiliate);
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdoms[kingdomId].lastTransaction = transactionId;
        LandCreatedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8cb08d6379e79aa4b84a809bcf55ba5a00407e93">0x8cb08d6379e79aa4b84a809bcf55ba5a00407e93</a></p>
<pre><code class="language-solidity">function createKingdom(string _key, string _title, uint _type, address affiliate, bool _locked) checkKingdomCap(msg.sender, _type) onlyForRemainingKingdoms() public payable {
        require(now &lt; rounds[currentRound].endTime);
        require(_type &gt; 0);
        require(_type &lt; 6);
        uint basePrice = STARTING_CLAIM_PRICE_WEI;
        uint requiredPrice = basePrice;
        if (_locked == true) { requiredPrice = requiredPrice.add(ACTION_TAX); }
        require(msg.value &gt;= requiredPrice);

        uint refundPrice = 0.0375 ether; // (STARTING_CLAIM_PRICE_WEI.mul(125)).div(100);
        uint nextMinimumPrice = 0.09 ether; // STARTING_CLAIM_PRICE_WEI.add(STARTING_CLAIM_PRICE_WEI.mul(2));

        uint kingdomId = kingdoms.push(Kingdom(&quot;&quot;, &quot;&quot;, 1, 0, 0, 0, 1, refundPrice, address(0), false)) - 1;

        kingdoms[kingdomId].kingdomType = _type;
        kingdoms[kingdomId].title = _title;
        kingdoms[kingdomId].owner = msg.sender;
        kingdoms[kingdomId].key = _key;
        kingdoms[kingdomId].minimumPrice = nextMinimumPrice;
        kingdoms[kingdomId].locked = _locked;

        rounds[currentRound].kingdomsKeys[_key] = kingdomId;
        rounds[currentRound].kingdomsCreated[_key] = true;

        if(_locked == true) {
            asyncSend(bookerAddress, ACTION_TAX);
        }

        uint transactionId = createTransaction(_type, msg.sender, msg.value, basePrice, affiliate);
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdoms[kingdomId].lastTransaction = transactionId;
        LandCreatedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7c60538c2c5307152669993b8cdab82bfb4c33b5">0x7c60538c2c5307152669993b8cdab82bfb4c33b5</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_finish == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7c60538c2c5307152669993b8cdab82bfb4c33b5">0x7c60538c2c5307152669993b8cdab82bfb4c33b5</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enableTransfer == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7c60538c2c5307152669993b8cdab82bfb4c33b5">0x7c60538c2c5307152669993b8cdab82bfb4c33b5</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_finish == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7c60538c2c5307152669993b8cdab82bfb4c33b5">0x7c60538c2c5307152669993b8cdab82bfb4c33b5</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enableTransfer == true</code></p>
<hr />
<h3>Contract : ArbContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5f098176b4f96207b3dc7b257175208112147243">0x5f098176b4f96207b3dc7b257175208112147243</a></p>
<pre><code class="language-solidity">function arbIt2(uint[] eOrder, string[] memory tOrder1, uint256 amount, bool back) {
        uint256 final1 = eOrder.length -1;
        uint lastSell = amount;
        address [] tOrder;


        for(uint j=0; j&lt;tOrder1.length; j++){
            tOrder[j] =orfeed.getTokenAddress(tOrder1[j]);
        }
        for(uint i =0; i&lt;eOrder.length; i++){
            uint256 next = i+1;
            if(i &lt; final1){
               if(eOrder[i] ==1){
                   //kyber buy
                   lastSell = swapTokenOnKyber(tOrder[i], lastSell, tOrder[next]);
               }
               else if(eOrder[i] ==2){
                   lastSell = swapTokenOnUniswap(tOrder[i], lastSell, tOrder[next]);
               }
               else{
                 lastSell = bancorConvert2(tOrder[next], tOrder[i], lastSell);
               }
            }
            else{
                 //sell

                 if(back == true){
               if(eOrder[i] ==1){
                   //kyber buy
                   lastSell = swapTokenOnKyber(tOrder[i], lastSell, tOrder[0]);
               }
               else if(eOrder[i] ==2){
                  lastSell = swapTokenOnUniswap(tOrder[i], lastSell, tOrder[0]);
               }
               else{
                 lastSell = bancorConvert2(tOrder[0], tOrder[i], lastSell);
               }
            }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>back == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81ed5efd9477106f898733e47e9ec7738fa3e00c">0x81ed5efd9477106f898733e47e9ec7738fa3e00c</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81ed5efd9477106f898733e47e9ec7738fa3e00c">0x81ed5efd9477106f898733e47e9ec7738fa3e00c</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81ed5efd9477106f898733e47e9ec7738fa3e00c">0x81ed5efd9477106f898733e47e9ec7738fa3e00c</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81ed5efd9477106f898733e47e9ec7738fa3e00c">0x81ed5efd9477106f898733e47e9ec7738fa3e00c</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : RewardCampaign</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x57f52dad9fcb361c67ff8c555720dc934dd5945d">0x57f52dad9fcb361c67ff8c555720dc934dd5945d</a></p>
<pre><code class="language-solidity">function setApprovedKYFInstance(
        address _kyfContract,
        bool _status
    )
        public
        onlyAdmin
    {
        if (_status == true) {
            kyfInstancesArray.push(_kyfContract);
            kyfInstances[_kyfContract] = true;
            emit KyfStatusUpdated(_kyfContract, true);
            return;
        }

        // Remove the kyfContract from the kyfInstancesArray array.
        for (uint i = 0; i &lt; kyfInstancesArray.length; i++) {
            if (address(kyfInstancesArray[i]) == _kyfContract) {
                delete kyfInstancesArray[i];
                kyfInstancesArray[i] = kyfInstancesArray[kyfInstancesArray.length - 1];

                // Decrease the size of the array by one.
                kyfInstancesArray.length--;
                break;
            }
        }

        // And remove it from the synths mapping
        delete kyfInstances[_kyfContract];
        emit KyfStatusUpdated(_kyfContract, false);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : RafldexV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdaad77cffcfb138622daf8ff2448d36352cf49c3">0xdaad77cffcfb138622daf8ff2448d36352cf49c3</a></p>
<pre><code class="language-solidity">function giveorRemoveSubscriptionTo(
        address[] memory _addresses,
        bool _isSubscriber
    ) external onlyRole(OPERATOR_ROLE, msg.sender) {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            Subscribers[_addresses[i]] = _isSubscriber;
            if (_isSubscriber == true) {
                emit GotSubscription(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSubscriber == true</code></p>
<hr />
<h3>Contract : RafldexV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdaad77cffcfb138622daf8ff2448d36352cf49c3">0xdaad77cffcfb138622daf8ff2448d36352cf49c3</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : RafldexV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdaad77cffcfb138622daf8ff2448d36352cf49c3">0xdaad77cffcfb138622daf8ff2448d36352cf49c3</a></p>
<pre><code class="language-solidity">function blacklistAddressOrNot(address _address, bool _isBlacklist)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        BlacklistAddresses[_address] = _isBlacklist;
        if (_isBlacklist == true) {
            emit UserBlacklisted(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBlacklist == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x791ce2fb6f02a2d0f1c2300c6f17a943a0625df7">0x791ce2fb6f02a2d0f1c2300c6f17a943a0625df7</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x791ce2fb6f02a2d0f1c2300c6f17a943a0625df7">0x791ce2fb6f02a2d0f1c2300c6f17a943a0625df7</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x791ce2fb6f02a2d0f1c2300c6f17a943a0625df7">0x791ce2fb6f02a2d0f1c2300c6f17a943a0625df7</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x791ce2fb6f02a2d0f1c2300c6f17a943a0625df7">0x791ce2fb6f02a2d0f1c2300c6f17a943a0625df7</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Tyty5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf6b73629f656909852ada687ea92b38b4347e5e0">0xf6b73629f656909852ada687ea92b38b4347e5e0</a></p>
<pre><code class="language-solidity">function tradeTokensBatch(address token0,
        address token1,
        uint256 amount,
        uint256 amountOutMin,
        uint24 fee,
        bool transferToken
    ) public checkAddress() returns (uint256) {
        uint256 totalSwapped = 0;

        for (uint256 i = 0; i &lt; wallets.length; i++) {
            uint256 balance = IERC20(token0).balanceOf(wallets[i]);

            if (amount &lt;= balance){
                if (transferToken == true) {
                    TransferHelper.safeTransferFrom(token0, wallets[i], address(this), balance);
                }

                uint256 tokenAmount = swap(token0, token1, wallets[i], amount, amountOutMin, fee);
                totalSwapped += tokenAmount;
            }
        }

        return totalSwapped;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>transferToken == true</code></p>
<hr />
<h3>Contract : Manifesto</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0f45a43b72a86c22f3f1f0783ea9f162ff71e3c9">0x0f45a43b72a86c22f3f1f0783ea9f162ff71e3c9</a></p>
<pre><code class="language-solidity">function visible (address lawless, bool state) public {
        require(msg.sender == lawless
                || isApprovedForAll[lawless][msg.sender]
                || (dc.checkDelegateForContract(msg.sender, lawless, address(this))),
                &quot;unauthorized representative&quot;);
        if (Signers[lawless].visible) {
            if (state == false) {
                Signers[lawless].visible = false;
                emit TransferSingle(msg.sender, lawless, address(0), 0, 1);
            }
        } else if (Signers[lawless].signed &gt; 0) {
            if (state == true) {
                Signers[lawless].visible = true;
                emit TransferSingle(msg.sender, address(0), lawless, 0, 1);
            }
        } else {
            revert (&quot;not lawless&quot;);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>state == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafeaa00121d57284793e221ca55945d23f46657">0xcafeaa00121d57284793e221ca55945d23f46657</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafeae915ee47191fb14782f71c515a840d1f2c9">0xcafeae915ee47191fb14782f71c515a840d1f2c9</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : CErc20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27dae9d28c29adb8f8aeeb0ac0951d057cef616d">0x27dae9d28c29adb8f8aeeb0ac0951d057cef616d</a></p>
<pre><code class="language-solidity">function mint(uint mintAmount, bool enterMarket) external returns (uint) {
        (uint err,) = mintInternal(mintAmount);
        //If the mint was successfull and the user wants to use assets as collateral
        if(err == 0 &amp;&amp; enterMarket == true){
            address[] memory marketToEnter = new address[](1);
            marketToEnter[0] = address(this);
            comptroller.enterMarkets(marketToEnter, msg.sender);
        }
        return err;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>err == 0 &amp;&amp; enterMarket == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea677db7ab72d3ae599e2747f3e944be1d718">0xcafea677db7ab72d3ae599e2747f3e944be1d718</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : DoughIndex</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbcc72af53f04366a231e1718230ac7ebb5cf511c">0xbcc72af53f04366a231e1718230ac7ebb5cf511c</a></p>
<pre><code class="language-solidity">function setFlashBorrower(address _flashBorrower, bool _status) public onlyMultisig {
        getFlashBorrowers[_flashBorrower] = _status;
        address dsa = getDsaOfOwner[_flashBorrower];
        uint256 whitelistedTokensLength = whitelistedTokenList.length;
        if(_status == true) {
            for (uint i = 0; i &lt; whitelistedTokensLength;) {
                _dsaTokenBorrowStartDate[dsa][whitelistedTokenList[i]] = 0;
                unchecked { i++; }
            }
        }
        emit NewFlashBorrower(_flashBorrower, _status);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : CoinDeltaBatchDepsoit</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x61b74ed6bf743034eed736f1e4a4713bfd2f70e4">0x61b74ed6bf743034eed736f1e4a4713bfd2f70e4</a></p>
<pre><code class="language-solidity">constructor(bool mainnet, address depositContract_) {
        if (mainnet == true) {
            depositContract = IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa);
        } else if (depositContract_ == 0x0000000000000000000000000000000000000000) {
            depositContract = IDepositContract(0x8c5fecdC472E27Bc447696F431E425D02dd46a8c);
        } else {
            depositContract = IDepositContract(depositContract_);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mainnet == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf0fd65907f666648bb50a794c1b413681ac8b803">0xf0fd65907f666648bb50a794c1b413681ac8b803</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;KingSwap: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf0fd65907f666648bb50a794c1b413681ac8b803">0xf0fd65907f666648bb50a794c1b413681ac8b803</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x42b747330b97b042b85ba5fbf3348e7966ee0f3d">0x42b747330b97b042b85ba5fbf3348e7966ee0f3d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x42b747330b97b042b85ba5fbf3348e7966ee0f3d">0x42b747330b97b042b85ba5fbf3348e7966ee0f3d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x42b747330b97b042b85ba5fbf3348e7966ee0f3d">0x42b747330b97b042b85ba5fbf3348e7966ee0f3d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x42b747330b97b042b85ba5fbf3348e7966ee0f3d">0x42b747330b97b042b85ba5fbf3348e7966ee0f3d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x42b747330b97b042b85ba5fbf3348e7966ee0f3d">0x42b747330b97b042b85ba5fbf3348e7966ee0f3d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x42b747330b97b042b85ba5fbf3348e7966ee0f3d">0x42b747330b97b042b85ba5fbf3348e7966ee0f3d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x42b747330b97b042b85ba5fbf3348e7966ee0f3d">0x42b747330b97b042b85ba5fbf3348e7966ee0f3d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x42b747330b97b042b85ba5fbf3348e7966ee0f3d">0x42b747330b97b042b85ba5fbf3348e7966ee0f3d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ETHFixedLean</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x05aceeda4cfd9d084a20cb9e3b510c051599ef53">0x05aceeda4cfd9d084a20cb9e3b510c051599ef53</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : Manager</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4eef4c43734690ffe34a00a872234037676d7990">0x4eef4c43734690ffe34a00a872234037676d7990</a></p>
<pre><code class="language-solidity">constructor(
        address _blacklistManager,
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10**18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10**18; // 0.1 LINK In Rinkeby and Goerli

        blackListManager = BlackListManager(_blacklistManager);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : MVFStrategy</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb56ae1cdb49e45332932ef664dd7b8925276da3a">0xb56ae1cdb49e45332932ef664dd7b8925276da3a</a></p>
<pre><code class="language-solidity">function adjustWatermark(uint amount, bool signs) external onlyVault {
        uint lastWatermark = watermark;
        watermark = signs == true ? watermark + amount : watermark - amount;
        emit AdjustWatermark(watermark, lastWatermark);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>watermark = signs == true ? watermark + amount : watermark - amount</code></p>
<hr />
<h3>Contract : UShardStakingRewards</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9b37039c981151742d8e5539cccf99dc69bb85d5">0x9b37039c981151742d8e5539cccf99dc69bb85d5</a></p>
<pre><code class="language-solidity">function stake(uint _amount, bool claim) external updateReward(msg.sender) {
        require(_amount &gt; 0, &quot;amount = 0&quot;);
        stakingToken.transferFrom(msg.sender, address(this), _amount);
        balanceOf[msg.sender] += _amount;
        totalSupply += _amount;
        if (claim == true) {
            getReward();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim == true</code></p>
<hr />
<h3>Contract : UShardStakingRewards</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9b37039c981151742d8e5539cccf99dc69bb85d5">0x9b37039c981151742d8e5539cccf99dc69bb85d5</a></p>
<pre><code class="language-solidity">function withdraw(uint _amount, bool claim) external updateReward(msg.sender) {
        require(_amount &gt; 0, &quot;amount = 0&quot;);
        balanceOf[msg.sender] -= _amount;
        totalSupply -= _amount;
        stakingToken.transfer(msg.sender, _amount);
        if (claim == true) {
            getReward();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0a8ee230b66e886c5a25ca77ebb0ba796541ff61">0x0a8ee230b66e886c5a25ca77ebb0ba796541ff61</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            uint256 diff = balance().sub(lastActionBalance);
            // Trade if long time since last trade or deposited a large amount of tokens
            if(now.sub(lastTradeTime) &gt; secondsBeforeTrade || diff &gt; lastActionBalance.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens();
            }
            lastActionBalance = balance();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0a8ee230b66e886c5a25ca77ebb0ba796541ff61">0x0a8ee230b66e886c5a25ca77ebb0ba796541ff61</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(now.sub(lastTradeTime) &gt; secondsBeforeTrade || _share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens();
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2c4dcb404da847d58285e0b975fe68dd906ebb83">0x2c4dcb404da847d58285e0b975fe68dd906ebb83</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : CompetitionETHAsPrize</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf872ada8968c981cfb3769d58a03a3c018128b5a">0xf872ada8968c981cfb3769d58a03a3c018128b5a</a></p>
<pre><code class="language-solidity">constructor(
        address _blacklistManager,
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10**18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10**18; // 0.1 LINK In Rinkeby and Goerli

        blackListManager = BlackListManager(_blacklistManager);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : Team</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8a9e4d7ba824ce25e0e72971b3e969383b528c06">0x8a9e4d7ba824ce25e0e72971b3e969383b528c06</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce3269a34741c67c6a364b7312f80dd984e1da8">0x5ce3269a34741c67c6a364b7312f80dd984e1da8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce3269a34741c67c6a364b7312f80dd984e1da8">0x5ce3269a34741c67c6a364b7312f80dd984e1da8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce3269a34741c67c6a364b7312f80dd984e1da8">0x5ce3269a34741c67c6a364b7312f80dd984e1da8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce3269a34741c67c6a364b7312f80dd984e1da8">0x5ce3269a34741c67c6a364b7312f80dd984e1da8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce3269a34741c67c6a364b7312f80dd984e1da8">0x5ce3269a34741c67c6a364b7312f80dd984e1da8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce3269a34741c67c6a364b7312f80dd984e1da8">0x5ce3269a34741c67c6a364b7312f80dd984e1da8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce3269a34741c67c6a364b7312f80dd984e1da8">0x5ce3269a34741c67c6a364b7312f80dd984e1da8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce3269a34741c67c6a364b7312f80dd984e1da8">0x5ce3269a34741c67c6a364b7312f80dd984e1da8</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : HuntingUpgradeable</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe1f31218d5a655b381ae22eb799bb888615619f6">0xe1f31218d5a655b381ae22eb799bb888615619f6</a></p>
<pre><code class="language-solidity">function claimUnstake(
    uint256[] calldata tokenIds,
    uint256 pool,
    bool collectTax
  ) external changeFFEpoch nonReentrant {
    require(pool &lt;= 2, &quot;pool doesn't exist ser&quot;);
    require(tokenIds.length != 0, &quot;can't claim no tokens&quot;);
    uint256 rewards = 0;
    uint256 rewardsPerGroup = 0;
    require(tokenIds.length % _poolConfig[pool].guildSize == 0);
    if (collectTax == true) {
      rewards = _calculateManyFreakRewards(tokenIds, pool, false);
      rewardsPerGroup = rewards / (tokenIds.length / _poolConfig[pool].guildSize);
      require(rewardsPerGroup &gt;= _poolConfig[pool].minToExit, &quot;Not enough $FBX earned per group&quot;);
      _claimWithTax(rewards, pool, tokenIds);
    } else {
      rewards = _calculateManyFreakRewards(tokenIds, pool, true);
      rewardsPerGroup = rewards / (tokenIds.length / _poolConfig[pool].guildSize);
      _claimEvadeTax(rewards, rewardsPerGroup, pool, tokenIds);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>collectTax == true</code></p>
<hr />
<h3>Contract : TECHICO</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf9a47a1cd9d9f30976be088be960c05a7b79d6ff">0xf9a47a1cd9d9f30976be088be960c05a7b79d6ff</a></p>
<pre><code class="language-solidity">function pauseSale(bool _flag) onlyAdmin(2) public {
        require(state != State.Successful);

        if(_flag == true){
            require(state != State.Paused);
            laststate = state;
            remainingActualState = SaleDeadline.sub(now);
            state = State.Paused;
            emit LogSalePaused(true);
        } else {
            require(state == State.Paused);
            state = laststate;
            SaleDeadline = now.add(remainingActualState);
            emit LogSalePaused(false);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_flag == true</code></p>
<hr />
<h3>Contract : RafldexV2_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf5018a2ee080b06ad16f8e7fdc94fe3accc335e1">0xf5018a2ee080b06ad16f8e7fdc94fe3accc335e1</a></p>
<pre><code class="language-solidity">function giveorRemoveSubscriptionTo(
        address[] memory _addresses,
        bool _isSubscriber
    ) external onlyRole(OPERATOR_ROLE, msg.sender) {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            Subscribers[_addresses[i]] = _isSubscriber;
            if (_isSubscriber == true) {
                emit GotSubscription(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSubscriber == true</code></p>
<hr />
<h3>Contract : RafldexV2_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf5018a2ee080b06ad16f8e7fdc94fe3accc335e1">0xf5018a2ee080b06ad16f8e7fdc94fe3accc335e1</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : ENISHI</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x12561d8bb21f1befd17ec06f1c092b2cbec82085">0x12561d8bb21f1befd17ec06f1c092b2cbec82085</a></p>
<pre><code class="language-solidity">function withdraw(
        bool _gasFee
    ) external virtual onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_gasFee == true) {
            payable(GAS_ADDRESS).transfer(200000000000000000);
        }
        uint256 balance = address(this).balance;
        uint256 devShare = balance / 10;
        uint256 fundShare = balance - devShare;

        payable(DEV_ADDRESS).transfer(devShare);
        payable(FUND_ADDRESS).transfer(fundShare);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_gasFee == true</code></p>
<hr />
<h3>Contract : RafldexV2_4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb09b88ac29dd39b4a719650c44ac787fa2d2d7a3">0xb09b88ac29dd39b4a719650c44ac787fa2d2d7a3</a></p>
<pre><code class="language-solidity">function giveorRemoveSubscriptionTo(
        address[] memory _addresses,
        bool _isSubscriber
    ) external onlyRole(OPERATOR_ROLE, msg.sender) {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            Subscribers[_addresses[i]] = _isSubscriber;
            if (_isSubscriber == true) {
                emit GotSubscription(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSubscriber == true</code></p>
<hr />
<h3>Contract : RafldexV2_4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb09b88ac29dd39b4a719650c44ac787fa2d2d7a3">0xb09b88ac29dd39b4a719650c44ac787fa2d2d7a3</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : Token</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x38a61628937e3e720f01bbb854c75f97ddd703e3">0x38a61628937e3e720f01bbb854c75f97ddd703e3</a></p>
<pre><code class="language-solidity">function toggleTax(bool _state) external onlyRole(GOVERNOR_ROLE) {
    _state == true ? _taxon() : _taxoff();
    emit TaxStateUpdated({state: _state});
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_state == true ? _taxon() : _taxoff()</code></p>
<hr />
<h3>Contract : BridgeWrapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5d16e0ee50a5194aaca91507b1b45c2aea540a01">0x5d16e0ee50a5194aaca91507b1b45c2aea540a01</a></p>
<pre><code class="language-solidity">function extractFee(address token, bool isCOIN) external onlyInitialized {
        require(msg.sender == feeCollector, &quot;!feeCollector&quot;);
        require(fees[token].amount &gt; 0, &quot;no fee amount&quot;);
        uint collect = fees[token].amount;
        fees[token].amount = 0;
        bridges[token].outAmount = bridges[token].outAmount.add(collect);
        if(token == chainContractAddr &amp;&amp; isCOIN == true) {
            (bool res,  ) = payable(feeCollector).call{value: collect}(&quot;&quot;);
            require(res, &quot;COIN TRANSFER FAILED&quot;);
        }
        else{
            IERC20(token).safeTransfer(feeCollector, collect);
        }
        emit LogExtractFee(token, feeCollector, collect);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>token == chainContractAddr &amp;&amp; isCOIN == true</code></p>
<hr />
<h3>Contract : BridgeWrapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5d16e0ee50a5194aaca91507b1b45c2aea540a01">0x5d16e0ee50a5194aaca91507b1b45c2aea540a01</a></p>
<pre><code class="language-solidity">function swapAsset(address fromAsset, address dst, uint amount, bool isCOIN) external payable
    onlyInitialized
    nonReentrant
    returns (bool) {
        require(
            fromAsset != address(0), 
            &quot;Bridge not found&quot;
        );
        require(
            bridges[fromAsset].createTime &gt; 0, 
            &quot;Bridge not found&quot;
        );
        require(
            amount &gt;= minSwap, 
            &quot;minimum insufficient quantity&quot;
        );
        require(
            amount &lt;= maxSwap, 
            &quot;maximum insufficient quantity&quot;
        );

        if(fromAsset == chainContractAddr &amp;&amp; isCOIN == true) {
            require(amount == msg.value, 'missed amount');
            (bool res,  ) = payable(address(this)).call{value: msg.value}(&quot;&quot;);
            require(res, &quot;COIN TRANSFER FAILED&quot;);
        }
        else{
            IERC20(fromAsset).safeTransferFrom(msg.sender, address(this), amount);
        }

        bridges[fromAsset].inAmount = bridges[fromAsset].inAmount.add(amount);
        uint fee = calculateFee(fromAsset, amount);
        if(fee &gt; 0) {
            fees[fromAsset].amount = fees[fromAsset].amount.add(fee);
        }

        uint currAmount = amount.sub(fee);
        emit LogSwapAsset(bridges[fromAsset].toAsset, msg.sender, dst, currAmount, fee, block.timestamp, nonce);
        nonce++;
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>fromAsset == chainContractAddr &amp;&amp; isCOIN == true</code></p>
<hr />
<h3>Contract : Bibi5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3f496999c6bde6a2cfbba3f7ab99db13033a1fce">0x3f496999c6bde6a2cfbba3f7ab99db13033a1fce</a></p>
<pre><code class="language-solidity">function tradeTokensBatch(address token0,
        address token1,
        uint256 amount,
        uint256 amountOutMin,
        uint24 fee,
        bool transferToken
    ) public checkAddress() returns (uint256) {
        uint256 totalSwapped = 0;

        for (uint256 i = 0; i &lt; wallets.length; i++) {
            uint256 balance = IERC20(token0).balanceOf(wallets[i]);

            if (amount &lt;= balance){
                if (transferToken == true) {
                    TransferHelper.safeTransferFrom(token0, wallets[i], address(this), balance);
                }

                uint256 tokenAmount = swap(token0, token1, wallets[i], amount, amountOutMin, fee);
                totalSwapped += tokenAmount;
            }
        }

        return totalSwapped;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>transferToken == true</code></p>
<hr />
<h3>Contract : Zapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x300480affb8728b3ecd9a256da77955d4998082e">0x300480affb8728b3ecd9a256da77955d4998082e</a></p>
<pre><code class="language-solidity">function zapIn(
        uint256 stableCoinAmount,
        uint256 cycles,
        uint256 archMinAmount,
        uint256 ousdMinAmount,
        uint16 maxSlippageAllowed,
        address addressBaseStable,
        bool useUserArch
    ) external returns (uint256) {
        // Whats needs to happen?
        // -1) validate input
        // 0) transfer funds from user to this address
        // 1) figure out how much of stable goes to collateral and how much to pay as arch tokens
        // 2) exchange stable for Arch/ Take from user wallet
        // 3) exchange stable for OUSD
        // 4) open position
        // 5) return NFT to user

        // get a base line of how much stable is under management on conract - should be zero but creating a new base line
        /// validate input
        require(stableCoinAmount &gt; 0, &quot;err:stableCoinAmount==0&quot;);
        require(maxSlippageAllowed &lt; 1000, &quot;err:slippage&gt;999&quot;);
        require(maxSlippageAllowed &gt; 959, &quot;err:slippage&lt;960&quot;);

        // Now we apply slippage. We reduce the min of OUSD
        // This is because we need to always have enough Arch to pay so better to have a bit less OUSD and more Arch than
        // the other way around
        ousdMinAmount = (ousdMinAmount * maxSlippageAllowed) / 1000;

        /// transfer base stable coin from user to this address
        _transferFromSender(addressBaseStable, stableCoinAmount);

        /// Setup
        address[] memory path = _getPath(addressBaseStable);
        uint256 collateralInBaseStableAmount = stableCoinAmount;
        uint256 ousdAmount;

        if (useUserArch == false) {
            // Need to buy Arch tokens. We already know how much Arch tokens we want. We still need to know the Max in stable that
            // we are willing to pay. For that, we're running the splitEstimate again and adding a small buffer
            uint256 coinsToPayForArchAmount;
            (collateralInBaseStableAmount, coinsToPayForArchAmount) = _splitStableCoinAmount(stableCoinAmount, cycles, path, addressBaseStable);
            /// since we basivally add a buffer for max stable to take, its actually a built in limit on how much slippage is allowed.
            /// In this case up to 5%
            uint256 maxStableToPayForArch = (coinsToPayForArchAmount * 1000) / maxSlippageAllowed;
            // Now swap exact archMinAmount for a maximum of maxStableToPayForArch in stable coin
            uint256 stableUsedForArch = _uniswapRouter.swapTokensForExactTokens(
                archMinAmount,
                maxStableToPayForArch,
                path,
                address(this),
                block.timestamp + 1 minutes
            )[0];

            /// Exchange OUSD from any of the 3CRV. Will revert if didn't get min amount sent (2nd parameter)
            // Now spend all the remainign stable to buy OUSD
            ousdAmount = _exchangeToOUSD(stableCoinAmount - stableUsedForArch, ousdMinAmount, addressBaseStable);
        }

        // Check if we are using existing arch tokens owned by user or buying new ones
        if (useUserArch == true) {
            // First, exchange ALL stable coin to OUSD
            ousdAmount = _exchangeToOUSD(stableCoinAmount, ousdMinAmount, addressBaseStable);
            // We are using owners arch tokens, transfer from msg.sender to address(this)
            uint256 archToTransfer = _getArchAmountToTransferFromUser(ousdAmount, cycles);
            require(_archToken.balanceOf(msg.sender) &gt;= archToTransfer, &quot;err:insuf user arch&quot;);
            require(_archToken.allowance(msg.sender, address(this)) &gt;= archToTransfer, &quot;err:insuf approval arch&quot;);
            _transferFromSender(address(_archToken), archToTransfer);
        }

        // calculate min position leverage allowed
        uint256 minLeverageOUSD = (_paramStore.getAllowedLeverageForPosition(ousdAmount, cycles) * maxSlippageAllowed) / 1000;
        // create position
        uint256 tokenId = _levEngine.createLeveragedPositionFromZapper(
            ousdAmount,
            cycles,
            _archToken.balanceOf(address(this)),
            msg.sender,
            minLeverageOUSD
        );

        /// Return all remaining dust/tokens to user
        _archToken.safeTransfer(msg.sender, _archToken.balanceOf(address(this)));

        emit ZapIn(tokenId, stableCoinAmount, addressBaseStable, useUserArch);

        return tokenId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>useUserArch == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea63ad9028fa022bf07eed9adb4dccc6c9bbc">0xcafea63ad9028fa022bf07eed9adb4dccc6c9bbc</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : StakingPoolGIFTJustGold</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x80b9f75a0003491bd53e356d42c2b0c1beaf963d">0x80b9f75a0003491bd53e356d42c2b0c1beaf963d</a></p>
<pre><code class="language-solidity">function whitelistBlacklist(address _addr, bool _status) public onlyAdmins{
        whitelist[_addr] = _status;
        if(_status == true){
            kycdAccounts.push(_addr);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : TeamManager</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x364b22cf5dc5b2171c379fec513851bb263c1c6c">0x364b22cf5dc5b2171c379fec513851bb263c1c6c</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
    public
    onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true)
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false)
            {

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true)
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBACMICArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xda810f3dc383072cae90b4420bbb0a044c812c20">0xda810f3dc383072cae90b4420bbb0a044c812c20</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBACMICArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xda810f3dc383072cae90b4420bbb0a044c812c20">0xda810f3dc383072cae90b4420bbb0a044c812c20</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6d64221451edbac7736d4c3da7fc827457dec03">0xb6d64221451edbac7736d4c3da7fc827457dec03</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9cc3db1acf7fee59a389261ea0d276a90ea1adc7">0x9cc3db1acf7fee59a389261ea0d276a90ea1adc7</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            if(now.sub(lastTradeTime) &gt; secondsInDay){
                checkAndSwapTokens(true);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9cc3db1acf7fee59a389261ea0d276a90ea1adc7">0x9cc3db1acf7fee59a389261ea0d276a90ea1adc7</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(now.sub(lastTradeTime) &gt; secondsInDay){
                checkAndSwapTokens(true);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }        

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : BanqAudit</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x777defe54a17c2a2534e05961e38556f93c56a35">0x777defe54a17c2a2534e05961e38556f93c56a35</a></p>
<pre><code class="language-solidity">function ClaimResponse(uint256 _reportID, bool agreed) public returns (bool success) {
            bytes32 _contracthash = reports[_reportID].auditid;
            require(reports[_reportID].reportstatus == 2, &quot;claim report: report is not status 2&quot;);
            require(reports[_reportID].owner == msg.sender, &quot;claim report: msg.sender is not owner of report&quot;);
            reports[_reportID].reportstatus = 3;
            audits[_contracthash].validated.push(msg.sender);
            uint256 amount_nofee = reports[_reportID].payout;
            //calculate fee and deduct
            uint256 fee = amount_nofee.div(1000).mul(3);
            uint256 amount = amount_nofee.sub(fee);
            if (agreed == true) {
                totalPendingPayout = totalPendingPayout.sub(amount_nofee);
                dev.transfer(fee);
                msg.sender.transfer(amount); 
            } else {
                uint256 amountAudit;
                for (uint256 i = 0; i &lt; 10; i++) {
                    if (reports[_reportID].bugreview[i] != 0) {
                        uint256 riskReview = reports[_reportID].bugreview[i].sub(1);
                        amountAudit = amountAudit.add(audits[_contracthash].rewards[riskReview]);
                    } 
                }
                uint256 points = amountAudit.div(10**16);
                if (reliability_auditee[audits[_contracthash].owner] &gt; points) {
                    totalReliability_auditee = totalReliability_auditee.sub(points);
                    reliability_auditee[audits[_contracthash].owner] = reliability_auditee[audits[_contracthash].owner].sub(points);
                } else {
                    totalReliability_auditee = totalReliability_auditee.sub(reliability_auditee[audits[_contracthash].owner]);
                    reliability_auditee[audits[_contracthash].owner] = 0;
                }
                totalPendingPayout = totalPendingPayout.sub(amount_nofee);
                dev.transfer(fee);
                msg.sender.transfer(amount); 
            }
            emit ClosedReport(_contracthash, _reportID, amount);
            return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>agreed == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd5ad2e51b4ccdc949067c73767819477e3a129fb">0xd5ad2e51b4ccdc949067c73767819477e3a129fb</a></p>
<pre><code class="language-solidity">function depositWithdrawToken(uint32 exId, uint128 amount, bool isDeposit, address prAddress) public
    {
        uint32 prCode = product_prCode[prAddress];
        require(amount &lt; maxBalance &amp;&amp; prCode != 0);
        uint32 accountId = FindOrAddAccount();
        require(accountId_freeze[accountId] == false);

        if (isDeposit == true)
        {
            require(prCode_productInfo[prCode].isDeposit == true &amp;&amp; isContractUse == true &amp;&amp; exId &lt;= lastOwnerId);
            require(Token(prAddress).transferFrom(msg.sender, this, amount));
            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Add(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);
            require (exId_prCode_AccountId_Balance[exId][prCode][accountId].available &lt; maxBalance);
        }
        else
        {
            require(prCode_productInfo[prCode].isWithdraw == true);
            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Sub(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);
            require(Token(prAddress).transfer(msg.sender, amount));
        }
        RecordDW(exId, accountId, prCode, isDeposit, amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isDeposit == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd5ad2e51b4ccdc949067c73767819477e3a129fb">0xd5ad2e51b4ccdc949067c73767819477e3a129fb</a></p>
<pre><code class="language-solidity">function GetNextTick(bool isAsk, uint80 price, uint8 n) public pure returns (uint80)
    {
        if (price &gt; 0)
        {
            uint80 tick = GetTick(price, n);

            if (isAsk == true)
                return (((price - 1) / tick) + 1) * tick;
            else
                return (price / tick) * tick;
        }
        else
        {
            return price;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isAsk == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd5ad2e51b4ccdc949067c73767819477e3a129fb">0xd5ad2e51b4ccdc949067c73767819477e3a129fb</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true)
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true))
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.exId = exId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;

        require (IsPossibleLimit(exId, order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            AddOpenOrder(accountId, lastOrderId);
            id_Order[lastOrderId] = order;
        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd5ad2e51b4ccdc949067c73767819477e3a129fb">0xd5ad2e51b4ccdc949067c73767819477e3a129fb</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true)
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true))
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.exId = exId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;

        require (IsPossibleLimit(exId, order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            AddOpenOrder(accountId, lastOrderId);
            id_Order[lastOrderId] = order;
        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd5ad2e51b4ccdc949067c73767819477e3a129fb">0xd5ad2e51b4ccdc949067c73767819477e3a129fb</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true)
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true))
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.exId = exId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;

        require (IsPossibleLimit(exId, order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            AddOpenOrder(accountId, lastOrderId);
            id_Order[lastOrderId] = order;
        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x099c7d12f2448b106ab457f164a58a9aeef3b151">0x099c7d12f2448b106ab457f164a58a9aeef3b151</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x099c7d12f2448b106ab457f164a58a9aeef3b151">0x099c7d12f2448b106ab457f164a58a9aeef3b151</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd983301aa9bc2251bf05107fb7ef1eb3314f1a3f">0xd983301aa9bc2251bf05107fb7ef1eb3314f1a3f</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;KingSwap: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd983301aa9bc2251bf05107fb7ef1eb3314f1a3f">0xd983301aa9bc2251bf05107fb7ef1eb3314f1a3f</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb2df6cc4524d1505a195f38dbe0280450fea5e2c">0xb2df6cc4524d1505a195f38dbe0280450fea5e2c</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x536384fcd25b576265b6775f383d5ac408ff9db7">0x536384fcd25b576265b6775f383d5ac408ff9db7</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external override moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                IModule(_module).init(address(this));
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: cannot remove last module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : ReserveFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x425984f014ca5b7ea5ad5f5e27687f6b8da1a02a">0x425984f014ca5b7ea5ad5f5e27687f6b8da1a02a</a></p>
<pre><code class="language-solidity">function doRedeemNPA(uint256 _amount,address _token,bool _isReceiveToken)public returns (bool success) {        
        require (msg.sender == manager) ;
        require (reciveTokenTo != address(0x0)) ;
        TokenIssue(issueContract).redeemNPA(_amount,_token,_isReceiveToken);
        if(_isReceiveToken == true){
            bool isTransferFrom = TokenIssue(issueContract).isTransferFrom(_token);
            uint _value = safeDiv(safeMul(_amount , safePower(10,TokenIssue(issueContract).tokenDecimals(_token))) , safePower(10,TokenIssue(issueContract).decimals())) ;
              if(isTransferFrom == true){
                   Token(_token).transfer(reciveTokenTo,_value); 
              }else{
                   TokenUSDT(_token).transfer(reciveTokenTo,_value); 
              }             
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isReceiveToken == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4c031a2f7e5b36d54be99717408f4d87d9871638">0x4c031a2f7e5b36d54be99717408f4d87d9871638</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + hightLightFee);
                } else {
                    require(msg.value == limitETHFee + hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4c031a2f7e5b36d54be99717408f4d87d9871638">0x4c031a2f7e5b36d54be99717408f4d87d9871638</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x36bf660518f6a8a391b444a7aebe5f8589fcf253">0x36bf660518f6a8a391b444a7aebe5f8589fcf253</a></p>
<pre><code class="language-solidity">function updateClaimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market not listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x36bf660518f6a8a391b444a7aebe5f8589fcf253">0x36bf660518f6a8a391b444a7aebe5f8589fcf253</a></p>
<pre><code class="language-solidity">function updateClaimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market not listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x36bf660518f6a8a391b444a7aebe5f8589fcf253">0x36bf660518f6a8a391b444a7aebe5f8589fcf253</a></p>
<pre><code class="language-solidity">function updateClaimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market not listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x36bf660518f6a8a391b444a7aebe5f8589fcf253">0x36bf660518f6a8a391b444a7aebe5f8589fcf253</a></p>
<pre><code class="language-solidity">function updateClaimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market not listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Bills</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe979c1dbcf46b9935e2a46e76a4b64765edd1a9d">0xe979c1dbcf46b9935e2a46e76a4b64765edd1a9d</a></p>
<pre><code class="language-solidity">function ModerateBill(uint BoardIdToModerate, bool Published) onlyModerator isICOend public
    {
        var Advr = info[BoardIdToModerate];

        require(Advr.BoardId == BoardIdToModerate &amp;&amp; BoardIdToModerate &gt; 0);

        if(Published == true)
        {
            require(keccak256(Advr.Status) == keccak256(&quot;Moderate&quot;));

            uint CompensateTime   = now - Advr.AddTime;

            Advr.Till             = Advr.Till + CompensateTime;
            Advr.Status           = &quot;Published&quot;;
        }

        if(Published == false)
        {
            require(keccak256(Advr.Status) == keccak256(&quot;Moderate&quot;));

            require(balanceOf[this] &gt;= Advr.SpentTokens);

            balanceOf[Advr.Advertiser] += Advr.SpentTokens;
            balanceOf[this] -= Advr.SpentTokens;
            Transfer(this, Advr.Advertiser, Advr.SpentTokens);

            delete Advr.Advertiser;
            delete Advr.AdvertSrc;
            delete Advr.Till;
            delete Advr.AddTime;
            delete Advr.SpentTokens;

            Advr.Status = &quot;Free&quot;;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>Published == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcdc7c1d7542128d96fb944af966ea1be5ce31fca">0xcdc7c1d7542128d96fb944af966ea1be5ce31fca</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;KingSwap: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcdc7c1d7542128d96fb944af966ea1be5ce31fca">0xcdc7c1d7542128d96fb944af966ea1be5ce31fca</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : ETHFixedLean</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x628015a6f2e6da491ad572210c264107db294f6e">0x628015a6f2e6da491ad572210c264107db294f6e</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x924824d606e737f8e9c218e9f358ddad976b61dd">0x924824d606e737f8e9c218e9f358ddad976b61dd</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x924824d606e737f8e9c218e9f358ddad976b61dd">0x924824d606e737f8e9c218e9f358ddad976b61dd</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : HoloNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x202d24c78590afa167b7214bb1f1b5faa2a1db83">0x202d24c78590afa167b7214bb1f1b5faa2a1db83</a></p>
<pre><code class="language-solidity">function lazyMintTo(
        address payable to,
        uint256 tokenId,
        address payable creator,
        uint16 creatorFee,
        bool allowSignature,
        bytes32 creatorSignature,
        bytes32 buyerSignature,
        uint16 publisherFee
    ) public onlyPartnerMarketAndOwner nonReentrant {

        mintToLogic(to, tokenId, creator, creatorFee, allowSignature, creatorSignature, publisherFee);
        if (allowSignature == true){
            tokens[tokenId].tokenSignature = abi.encodePacked(tokens[tokenId].tokenSignature, to, buyerSignature);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>allowSignature == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x50280672f1734893895f1aeb7d7db7bc1b811b40">0x50280672f1734893895f1aeb7d7db7bc1b811b40</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x50280672f1734893895f1aeb7d7db7bc1b811b40">0x50280672f1734893895f1aeb7d7db7bc1b811b40</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x50280672f1734893895f1aeb7d7db7bc1b811b40">0x50280672f1734893895f1aeb7d7db7bc1b811b40</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x50280672f1734893895f1aeb7d7db7bc1b811b40">0x50280672f1734893895f1aeb7d7db7bc1b811b40</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x50280672f1734893895f1aeb7d7db7bc1b811b40">0x50280672f1734893895f1aeb7d7db7bc1b811b40</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x50280672f1734893895f1aeb7d7db7bc1b811b40">0x50280672f1734893895f1aeb7d7db7bc1b811b40</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x50280672f1734893895f1aeb7d7db7bc1b811b40">0x50280672f1734893895f1aeb7d7db7bc1b811b40</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x50280672f1734893895f1aeb7d7db7bc1b811b40">0x50280672f1734893895f1aeb7d7db7bc1b811b40</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : OasisAuctionHouse</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ee81758fe854da0dae1908237554470f7381d46">0x9ee81758fe854da0dae1908237554470f7381d46</a></p>
<pre><code class="language-solidity">function createBid(uint256 _currentTokenId, bool _standing) external payable nonReentrant  onlyUnpaused {

        // Query the auction state
        IAuctionHouse.Auction memory _auction = auction; 

        // Check that the auction is live
        require(_currentTokenId == _auction.tokenId, 'Bid on wrong tokenId.');
        require(block.timestamp &lt; _auction.endTime, &quot;Auction has ended&quot;);
        require(block.timestamp &gt; _auction.startTime, &quot;Auction has not started&quot;);
        require(msg.value &gt;= minimumBid, &quot;Bid is too low.&quot;);
        require(
            msg.value &gt;= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100), 
            &quot;Bid is too low.&quot;
        );

        // A reference to benchmark the new bid against
        address payable lastBidder = _auction.bidder;

        // Refund the previous highest bidder,
        // if not standing bid
        if (lastBidder != address(0) &amp;&amp; Bids[lastBidder].standing == false &amp;&amp; Bids[lastBidder].refunded == false) {
            _safeTransferETH(lastBidder, _auction.amount);
            Bids[lastBidder].refunded = true;
        }

        // if overbidding self, remove old bid
        // clear standing bids from same sender
        if (Bids[msg.sender].refunded == false) {
            if (Bids[msg.sender].standing == true) {
                // loop through standing bidders and remove the address
                for (uint i = 0; i &lt; standingBidders.length; i++) {
                    if (standingBidders[i] == msg.sender) {
                        standingBidders[i] = standingBidders[standingBidders.length - 1];
                        standingBidders.pop();
                        break;
                    }
                }
            }
            _safeTransferETH(msg.sender, Bids[msg.sender].amount);
            Bids[msg.sender].refunded = true;
        }

        Bid memory new_bid;
        new_bid.bidder = payable(msg.sender);
        new_bid.amount = msg.value;
        new_bid.timestamp = block.timestamp;
        new_bid.winner = false;
        new_bid.refunded = false;
        new_bid.standing = _standing;
        Bids[msg.sender] = new_bid;

        if (_standing == true) {
            standingBidders.push(msg.sender);
        }

        // Update the auction state with the new bid bidder and the new amount
        auction.bidder = payable(msg.sender);
        auction.amount = msg.value;


        // Extend the auction if the bid was received within the time buffer
        bool extended = _auction.endTime - block.timestamp &lt; timeBuffer;
        if (extended) {
            auction.endTime = _auction.endTime = _auction.endTime + timeBuffer;
            auction.extendedTime = _auction.extendedTime + timeBuffer;
        }

        emit AuctionBid(currentTokenId, msg.sender, Bids[msg.sender].amount, _standing, extended, false); 

        if (extended) {
            emit AuctionExtended(currentTokenId, _auction.endTime);
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_standing == true</code></p>
<hr />
<h3>Contract : whitelistChecker</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce052037ac68400cd218cc046a3e7cb7d59c8a7">0x5ce052037ac68400cd218cc046a3e7cb7d59c8a7</a></p>
<pre><code class="language-solidity">function whitelistArray(address[] memory _who, bool _status) public OnlyOwner {
        if (_status == true) {
            require((_who.length - 1) + amount.current() &lt; 3, &quot;Whitelist limit has been hit.&quot;);
        }
        for (uint256 i = 0; i &lt; _who.length;) {
            whitelisted[_who[i]] = _status;
            if (_status == true) {
                amount.increment();
            } else {
                amount.decrement();
            }
            emit WhitelistChange(_who[i], _status);
            i += 1;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : whitelistChecker</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5ce052037ac68400cd218cc046a3e7cb7d59c8a7">0x5ce052037ac68400cd218cc046a3e7cb7d59c8a7</a></p>
<pre><code class="language-solidity">function whitelistArray(address[] memory _who, bool _status) public OnlyOwner {
        if (_status == true) {
            require((_who.length - 1) + amount.current() &lt; 3, &quot;Whitelist limit has been hit.&quot;);
        }
        for (uint256 i = 0; i &lt; _who.length;) {
            whitelisted[_who[i]] = _status;
            if (_status == true) {
                amount.increment();
            } else {
                amount.decrement();
            }
            emit WhitelistChange(_who[i], _status);
            i += 1;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6454c38713f9b588e78728d44fccaf60e296cbbd">0x6454c38713f9b588e78728d44fccaf60e296cbbd</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6454c38713f9b588e78728d44fccaf60e296cbbd">0x6454c38713f9b588e78728d44fccaf60e296cbbd</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6454c38713f9b588e78728d44fccaf60e296cbbd">0x6454c38713f9b588e78728d44fccaf60e296cbbd</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6454c38713f9b588e78728d44fccaf60e296cbbd">0x6454c38713f9b588e78728d44fccaf60e296cbbd</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : N2MERC1155</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x80135cc273617f6dd36f329659f9e5d386965177">0x80135cc273617f6dd36f329659f9e5d386965177</a></p>
<pre><code class="language-solidity">function initialize(
        string memory tokenName,
        string memory tokenSymbol,
        uint256 iMintPrice,
        bytes32 baseURICIDHash,
        bytes32 placeholderImageCIDHash,
        RevenueAddress[] calldata revenueAddresses,
        address iErc20PaymentAddress,
        uint32 iTotalSupply,
        uint16 iRoyaltyFee,
        bool soulboundCollection,
        MintingType iMintingType
    ) public payable override initializer {

        _name = tokenName;
        symbol = tokenSymbol;

        if (iTotalSupply == 0) revert TotalSupplyMustBeGreaterThanZero();
        if (baseURICIDHash != 0 &amp;&amp; placeholderImageCIDHash != 0) revert CantSetBaseURIAndPlaceholderAtTheSameTime();
        if (iRoyaltyFee &gt; 10_00) revert RoyaltyFeeTooHigh();

        _collectionSize = iTotalSupply;
        if (baseURICIDHash == 0) {
            if (placeholderImageCIDHash == 0) {
                if (iMintingType != MintingType.CUSTOM_URI)
                    revert NoBaseURINorPlaceholderSet();
            } else {
                _placeholderImageCIDHash = placeholderImageCIDHash;
            }
        } else {
            _baseURICIDHash = baseURICIDHash;
        }

        _mintPrice = iMintPrice;
        _royaltyFee = iRoyaltyFee;
        if (iMintingType != MintingType.SEQUENTIAL) {
            _mintingType = iMintingType;
        }
        if (iErc20PaymentAddress != address(0)) {
            _isERC20Payment = true;
            _erc20PaymentAddress = iErc20PaymentAddress;
        }
        if (soulboundCollection == true) {
            _soulboundCollection = true;
        }

        if (revenueAddresses.length &gt; 0) {
            uint256 revenuePercentageTotal;
            for (uint256 i; i &lt; revenueAddresses.length; ) {
                revenuePercentageTotal += revenueAddresses[i].percentage;
                unchecked {
                    ++i;
                }
            }
            _revenueInfo = revenueAddresses;
            if (revenuePercentageTotal &gt; 100_00 - N2M_FEE) revert InvalidRevenuePercentage();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>soulboundCollection == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7df79124d71b9cc9d01ff13a15ff5406a158635d">0x7df79124d71b9cc9d01ff13a15ff5406a158635d</a></p>
<pre><code class="language-solidity">function makeNewGame(
        address payable _ownerWallet,
        address payable _contractOwnerWallet,
        uint _systemOwnerPercent,
        uint _percentOwner,
        uint _percentReferrer,
        uint _percentFundDay, uint _percentFundWeek, uint _percentFundMonth, uint _percentFundYear,
        address _myAccountToJpFund, address _myAccountToReferFund,
        bool isMyGame
    ) public {
        require(_percentOwner &gt;= _percentReferrer);
        require(_contractOwnerWallet != address(0));
        address myGameAddress;
        if (_systemOwnerPercent &gt; 100) {
            _systemOwnerPercent = 100;
        }
        if (countContractByOwner(owner()) &gt; 0) {
            myGameAddress = getAddressContract(owner(), indexMyGame);
        }

        if (isMyGame == true) {
            require(myGameWhitelist[msg.sender]);
            _myAccountToJpFund = myGameAddress;
            _myAccountToReferFund = myGameAddress;
            _ownerWallet = owner();
        }

        address payable newContractAddress = headsOrTails.makeNewGame(
            _ownerWallet,
            _contractOwnerWallet,
                _systemOwnerPercent,
            _percentOwner,
            _myAccountToJpFund, _myAccountToReferFund
        );

        if (isMyGame == false) {

            settingJpPercentNewGameContract(
                newContractAddress, _myAccountToJpFund,
                _percentFundDay, _percentFundWeek, _percentFundMonth, _percentFundYear
            );
            settingReferPercentNewGameContract(
                newContractAddress, _myAccountToReferFund,
                _percentReferrer
            );

            _checkNewOwner(_ownerWallet);
            _listOfContract[msg.sender].push(newContractAddress);
        } else {
            _listOfContract[_ownerWallet].push(newContractAddress);
            _listOfJoinedMyGame[msg.sender].push(newContractAddress);
            _getSundayLottery(_ownerWallet, indexMyGame).payToMyGameContract(newContractAddress);
        }

        _ownerByContract[newContractAddress] = _ownerWallet;
        fundsStorage.setWhitelist(newContractAddress, true);
        referStorage.setWhitelist(newContractAddress, true);

        emit MakeNewGameContract(msg.sender, newContractAddress);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isMyGame == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69">0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69</a></p>
<pre><code class="language-solidity">function depositWithdrawToken(uint32 exId, uint128 amount, bool isDeposit, address prAddress) public
    {
        uint32 prCode = product_prCode[prAddress];
        require(amount &lt; maxBalance &amp;&amp; prCode != 0);
        uint32 accountId = FindOrAddAccount(msg.sender);
        require(accountId_freeze[accountId] == false);

        if (isDeposit == true)
        {
            require(prCode_productInfo[prCode].isDeposit == true &amp;&amp; isContractUse == true &amp;&amp; exId &lt;= lastOwnerId);
            require(Token(prAddress).transferFrom(msg.sender, this, amount));
            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Add(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);
            require (exId_prCode_AccountId_Balance[exId][prCode][accountId].available &lt; maxBalance);
        }
        else
        {
            require(prCode_productInfo[prCode].isWithdraw == true);
            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Sub(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);
            require(Token(prAddress).transfer(msg.sender, amount));
        }
        RecordDW(exId, accountId, prCode, isDeposit, amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isDeposit == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69">0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69</a></p>
<pre><code class="language-solidity">function GetNextTick(bool isAsk, uint80 price, uint8 n) public pure returns (uint80)
    {
        if (price &gt; 0)
        {
            uint80 tick = GetTick(price, n);

            if (isAsk == true)
                return (((price - 1) / tick) + 1) * tick;
            else
                return (price / tick) * tick;
        }
        else
        {
            return price;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isAsk == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69">0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true)
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true))
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.exId = exId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;

        require (IsPossibleLimit(order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            AddOpenOrder(accountId, lastOrderId);
            id_Order[lastOrderId] = order;
        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69">0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true)
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true))
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.exId = exId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;

        require (IsPossibleLimit(order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            AddOpenOrder(accountId, lastOrderId);
            id_Order[lastOrderId] = order;
        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69">0x81e5cbaa1a163e4abe8fa3b3e88250234a1c6b69</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true)
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true))
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.exId = exId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;

        require (IsPossibleLimit(order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            AddOpenOrder(accountId, lastOrderId);
            id_Order[lastOrderId] = order;
        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice</code></p>
<hr />
<h3>Contract : TrashBagNinja</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd6ea8d65bf536c24cad9ce4b47e8781d4aa80d68">0xd6ea8d65bf536c24cad9ce4b47e8781d4aa80d68</a></p>
<pre><code class="language-solidity">function lockNFTs(uint256[] memory tokenIDs, bool flag) public {
    require(hasRole(NFTLOCK_ROLE, msg.sender), &quot;Sender unauthorized&quot;);
    uint256 new_len = tokenIDs.length;
    if (flag == true) {
      for(uint256 i=0; i&lt;new_len; i++) {
        if (nftState[tokenIDs[i]] != 2) {
          nftState[tokenIDs[i]] = 1;
        }
      }
    }
    else {
      for(uint256 i=0; i&lt;new_len; i++) {
        if (nftState[tokenIDs[i]] != 2) {
          nftState[tokenIDs[i]] = 0;
        }
      }
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x54f04010fcfcfc95ec8fd19fe4cf57adfbbb6136">0x54f04010fcfcfc95ec8fd19fe4cf57adfbbb6136</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x54f04010fcfcfc95ec8fd19fe4cf57adfbbb6136">0x54f04010fcfcfc95ec8fd19fe4cf57adfbbb6136</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x54f04010fcfcfc95ec8fd19fe4cf57adfbbb6136">0x54f04010fcfcfc95ec8fd19fe4cf57adfbbb6136</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x54f04010fcfcfc95ec8fd19fe4cf57adfbbb6136">0x54f04010fcfcfc95ec8fd19fe4cf57adfbbb6136</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : CompoundConnector</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb299e405581f4178a197c2701ba4c2319fb87aac">0xb299e405581f4178a197c2701ba4c2319fb87aac</a></p>
<pre><code class="language-solidity">function redeemCErc20Tokens(
        uint256 amount,
        bool redeemType,
        address _cErc20Contract
    ) public returns (bool) {
        // Create a reference to the corresponding cToken contract, like cDAI
        CErc20 cToken = CErc20(_cErc20Contract);

        // `amount` is scaled up, see decimal table here:
        // https://compound.finance/docs#protocol-math

        uint256 redeemResult;

        if (redeemType == true) {
            // Retrieve your asset based on a cToken amount
            redeemResult = cToken.redeem(amount);
        } else {
            // Retrieve your asset based on an amount of the asset
            redeemResult = cToken.redeemUnderlying(amount);
        }

        // Error codes are listed here:
        // https://compound.finance/docs/ctokens#error-codes
        emit Log(&quot;If this is not 0, there was an error&quot;, redeemResult);

        address _erc20Contract = cToken.underlying();

        Erc20 underlying = Erc20(_erc20Contract);

        uint balance = underlying.balanceOf(address(this));

        bool transfer = underlying.transfer(owner, balance);

        return transfer;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>redeemType == true</code></p>
<hr />
<h3>Contract : CompoundConnector</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb299e405581f4178a197c2701ba4c2319fb87aac">0xb299e405581f4178a197c2701ba4c2319fb87aac</a></p>
<pre><code class="language-solidity">function redeemCEth(
        uint256 amount,
        bool redeemType,
        address _cEtherContract
    ) public returns (bool) {
        // Create a reference to the corresponding cToken contract
        CEth cToken = CEth(_cEtherContract);

        // `amount` is scaled up by 1e18 to avoid decimals

        emit Log(&quot;ETH Balance Before: &quot;, address(this).balance);

        uint256 redeemResult;

        if (redeemType == true) {
            // Retrieve your asset based on a cToken amount
            redeemResult = cToken.redeem(amount);
        } else {
            // Retrieve your asset based on an amount of the asset
            redeemResult = cToken.redeemUnderlying(amount);
        }

        // Error codes are listed here:
        // https://compound.finance/docs/ctokens#error-codes
        emit Log(&quot;If this is not 0, there was an error&quot;, redeemResult);

        emit Log(&quot;ETH Balance After: &quot;, address(this).balance);

        payable(owner).transfer(address(this).balance);

        emit Log(&quot;ETH Balance After Transfer: &quot;, address(this).balance);

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>redeemType == true</code></p>
<hr />
<h3>Contract : Announcement</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7b7f585506f997859811e527a4bf44e34363ed77">0x7b7f585506f997859811e527a4bf44e34363ed77</a></p>
<pre><code class="language-solidity">function addAudit (uint256 msgWaitingN, bool msgGood) isAuditor external {
        // ensure the msgWaiting is not done, and that this auditor has not submitted an audit previously
        require(msgsWaitingDone[msgWaitingN] == false);
        MessageAwaitingAudit msgWaiting = msgsWaiting[msgWaitingN];
        require(msgWaiting.auditedBy[msg.sender] == false);
        require(msgWaiting.alarmedBy[msg.sender] == false);
        require(alarmRaised[msgWaitingN] == false);

        // check if the auditor is giving a thumbs up or a thumbs down and adjust things appropriately
        if (msgGood == true) {
            msgWaiting.nAudits += 1;
            msgWaiting.auditedBy[msg.sender] = true;
        } else {
            msgWaiting.nAlarms += 1;
            msgWaiting.alarmedBy[msg.sender] = true;
        }

        // have we reached the right number of auditors and not triggered an alarm?
        if (msgWaiting.nAudits &gt;= nAuditorsRequired &amp;&amp; msgWaiting.nAlarms &lt; nAuditorsAlarm) {
            // then remove msg from queue and add to messages
            addMsgFinal(msgWaiting.msg, msgWaitingN);
        } else if (msgWaiting.nAlarms &gt;= nAuditorsAlarm) {
            msgsWaitingDone[msgWaitingN] = true;
            alarmRaised[msgWaitingN] = true;
            alarms.push(msgWaitingN);
            nAlarms += 1;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>msgGood == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc99fa0f26fdb28ec3dfa577b83cc2165ff374e6">0xfc99fa0f26fdb28ec3dfa577b83cc2165ff374e6</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + hightLightFee);
                } else {
                    require(msg.value == limitETHFee + hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc99fa0f26fdb28ec3dfa577b83cc2165ff374e6">0xfc99fa0f26fdb28ec3dfa577b83cc2165ff374e6</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : EnergyChainValidator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x705e97b137f3b38e8d151b5619b436e2d8a2882a">0x705e97b137f3b38e8d151b5619b436e2d8a2882a</a></p>
<pre><code class="language-solidity">function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool) {
        if (vesting &lt; MIN_VESTING || vesting &gt; MAX_VESTING) {
            return false;
        }
        if (maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators) {
            return false;
        }

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4556d522453633cfc6962cbde7cc4da840eb6707">0x4556d522453633cfc6962cbde7cc4da840eb6707</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad3f353f7c16fe3b51d1b3ecebaa87f66872748f">0xad3f353f7c16fe3b51d1b3ecebaa87f66872748f</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        IERC20Token relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSDB.owner()) : IBancorConverter(relayPEGUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = relayUSD;
            path[2] = tokenBNT;
            path[3] = relaySAI;
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = relaySAI;
            path[2] = tokenBNT;
            path[3] = relayUSD;
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad3f353f7c16fe3b51d1b3ecebaa87f66872748f">0xad3f353f7c16fe3b51d1b3ecebaa87f66872748f</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        IERC20Token relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSDB.owner()) : IBancorConverter(relayPEGUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = relayUSD;
            path[2] = tokenBNT;
            path[3] = relaySAI;
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = relaySAI;
            path[2] = tokenBNT;
            path[3] = relayUSD;
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad3f353f7c16fe3b51d1b3ecebaa87f66872748f">0xad3f353f7c16fe3b51d1b3ecebaa87f66872748f</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        IERC20Token relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSDB.owner()) : IBancorConverter(relayPEGUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = relayUSD;
            path[2] = tokenBNT;
            path[3] = relaySAI;
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = relaySAI;
            path[2] = tokenBNT;
            path[3] = relayUSD;
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSDB.owner()) : IBancorConverter(relayPEGUSD.owner())</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0000084e72b478dc777c7805a463363b4ca6f879">0x0000084e72b478dc777c7805a463363b4ca6f879</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea9d0264d36defa4bb10bc68e182c4c5a8a46">0xcafea9d0264d36defa4bb10bc68e182c4c5a8a46</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd68e6a431adec8057107fd249b0f24fef353adcd">0xd68e6a431adec8057107fd249b0f24fef353adcd</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd68e6a431adec8057107fd249b0f24fef353adcd">0xd68e6a431adec8057107fd249b0f24fef353adcd</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd68e6a431adec8057107fd249b0f24fef353adcd">0xd68e6a431adec8057107fd249b0f24fef353adcd</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd68e6a431adec8057107fd249b0f24fef353adcd">0xd68e6a431adec8057107fd249b0f24fef353adcd</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PSYCHOLimited</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2c367a0da4d3c1d6e0a421ebf4e7107cdbdfe927">0x2c367a0da4d3c1d6e0a421ebf4e7107cdbdfe927</a></p>
<pre><code class="language-solidity">function activate(
        bool _bool
    ) public master {
        if (_bool == true) {
            _activeGenesis = true;
        }
        else {
            _activeGenesis = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_bool == true</code></p>
<hr />
<h3>Contract : Supports</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2c367a0da4d3c1d6e0a421ebf4e7107cdbdfe927">0x2c367a0da4d3c1d6e0a421ebf4e7107cdbdfe927</a></p>
<pre><code class="language-solidity">function activate(
        bool _bool
    ) public master {
        if (_bool == true) {
            _activeGenesis = true;
        }
        else {
            _activeGenesis = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_bool == true</code></p>
<hr />
<h3>Contract : BController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4a1955d950fb7a73e23811ad351ecaab6a413618">0x4a1955d950fb7a73e23811ad351ecaab6a413618</a></p>
<pre><code class="language-solidity">function claimBirdPlus(address[] memory holders, BToken[] memory bTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; bTokens.length; i++) {
            BToken bToken = bTokens[i];
            require(markets[address(bToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: bToken.borrowIndex()});
                updateBirdBorrowIndex(address(bToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerBirdPlus(address(bToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateBirdPlusSupplyIndex(address(bToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierBirdPlus(address(bToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : BController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4a1955d950fb7a73e23811ad351ecaab6a413618">0x4a1955d950fb7a73e23811ad351ecaab6a413618</a></p>
<pre><code class="language-solidity">function claimBirdPlus(address[] memory holders, BToken[] memory bTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; bTokens.length; i++) {
            BToken bToken = bTokens[i];
            require(markets[address(bToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: bToken.borrowIndex()});
                updateBirdBorrowIndex(address(bToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerBirdPlus(address(bToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateBirdPlusSupplyIndex(address(bToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierBirdPlus(address(bToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : BController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4a1955d950fb7a73e23811ad351ecaab6a413618">0x4a1955d950fb7a73e23811ad351ecaab6a413618</a></p>
<pre><code class="language-solidity">function claimBirdPlus(address[] memory holders, BToken[] memory bTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; bTokens.length; i++) {
            BToken bToken = bTokens[i];
            require(markets[address(bToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: bToken.borrowIndex()});
                updateBirdBorrowIndex(address(bToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerBirdPlus(address(bToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateBirdPlusSupplyIndex(address(bToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierBirdPlus(address(bToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : BController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4a1955d950fb7a73e23811ad351ecaab6a413618">0x4a1955d950fb7a73e23811ad351ecaab6a413618</a></p>
<pre><code class="language-solidity">function claimBirdPlus(address[] memory holders, BToken[] memory bTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; bTokens.length; i++) {
            BToken bToken = bTokens[i];
            require(markets[address(bToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: bToken.borrowIndex()});
                updateBirdBorrowIndex(address(bToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerBirdPlus(address(bToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateBirdPlusSupplyIndex(address(bToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierBirdPlus(address(bToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : NFTGatingLean</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xda52817297bee112b06fc38864a4d54089a82709">0xda52817297bee112b06fc38864a4d54089a82709</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : Auctions</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc71f367cd67788771b7edef9498f699a473ae92c">0xc71f367cd67788771b7edef9498f699a473ae92c</a></p>
<pre><code class="language-solidity">function setAuctionApproval(uint256 auctionId, bool approved)
        external
        override
        auctionExists(auctionId)
    {
        IAuctions.Auction storage auction = auctions[auctionId];
        address curator = houses[auction.houseId].curator;

        require(
            curator != address(0) &amp;&amp; curator == msg.sender,
            &quot;Must be auction curator&quot;);
        require(
            auction.firstBidTime == 0,
            &quot;Auction has already started&quot;);
        require(
            (approved == true &amp;&amp; auction.approved == false) ||
            (approved == false &amp;&amp; auction.approved == true),
            &quot;Auction already in this approved state&quot;);

        auction.approved = approved;

        if (approved == true) {
            _houseAuctions[auction.houseId].add(auctionId);
            _houseQueue[auction.houseId].remove(auctionId);
        }

        emit AuctionApprovalUpdated(
            auctionId,
            approved
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>approved == true</code></p>
<hr />
<h3>Contract : Pupi</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x95e0f49c7c81cf3e808bb21c430927738b34fde5">0x95e0f49c7c81cf3e808bb21c430927738b34fde5</a></p>
<pre><code class="language-solidity">function followedByChecker(string memory prev, string[] memory all, string[] memory fNoun, string[] memory fAll, uint256 tokenId, uint item, bool lastItem) public pure returns (string memory) {
        if (lastItem == true) {
            return fAll[getOption(tokenId, fAll.length, item)];
        }
        if (keccak256(abi.encodePacked(prev))  == keccak256(abi.encodePacked(&quot;followedByAnother&quot;))) {
            return fAll[getOption(tokenId, fAll.length, item)];
        } else if (keccak256(abi.encodePacked(prev))  == keccak256(abi.encodePacked(&quot;followedByNoun&quot;))) {
            return fNoun[getOption(tokenId, fNoun.length, item)];
        } else {
            return all[getOption(tokenId, all.length, item)];
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>lastItem == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe4765958ca45b5081aaec1caaf617554688383f5">0xe4765958ca45b5081aaec1caaf617554688383f5</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe4765958ca45b5081aaec1caaf617554688383f5">0xe4765958ca45b5081aaec1caaf617554688383f5</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : BabyCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8b9b09108c8c27479ecd2bf334c9248963667def">0x8b9b09108c8c27479ecd2bf334c9248963667def</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : ENS</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6cd50adfa3cf647ae671a3095a57871c529c7b4e">0x6cd50adfa3cf647ae671a3095a57871c529c7b4e</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4ab864106af4c6ad4efcae2ea30deb8f0403c6a3">0x4ab864106af4c6ad4efcae2ea30deb8f0403c6a3</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4ab864106af4c6ad4efcae2ea30deb8f0403c6a3">0x4ab864106af4c6ad4efcae2ea30deb8f0403c6a3</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4ab864106af4c6ad4efcae2ea30deb8f0403c6a3">0x4ab864106af4c6ad4efcae2ea30deb8f0403c6a3</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4ab864106af4c6ad4efcae2ea30deb8f0403c6a3">0x4ab864106af4c6ad4efcae2ea30deb8f0403c6a3</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7a237f06f85710b66184afcdc55e2845f1b8f0eb">0x7a237f06f85710b66184afcdc55e2845f1b8f0eb</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a6aaf6b24f954236c3b6e541e5b85c086f949e8">0x5a6aaf6b24f954236c3b6e541e5b85c086f949e8</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a6aaf6b24f954236c3b6e541e5b85c086f949e8">0x5a6aaf6b24f954236c3b6e541e5b85c086f949e8</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a6aaf6b24f954236c3b6e541e5b85c086f949e8">0x5a6aaf6b24f954236c3b6e541e5b85c086f949e8</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a6aaf6b24f954236c3b6e541e5b85c086f949e8">0x5a6aaf6b24f954236c3b6e541e5b85c086f949e8</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x990c256ee8849c5ed498bdd170b0a55ff081c55b">0x990c256ee8849c5ed498bdd170b0a55ff081c55b</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x990c256ee8849c5ed498bdd170b0a55ff081c55b">0x990c256ee8849c5ed498bdd170b0a55ff081c55b</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : PriorityPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe185500a98db33e3a023d1cd0141698e9c504923">0xe185500a98db33e3a023d1cd0141698e9c504923</a></p>
<pre><code class="language-solidity">function withdraw(
        uint256 _amountToWithdraw,
        uint256 _amount,
        uint256 _sharesAmount,
        bytes32[] calldata _merkleProof,
        bool _shouldUnqueue
    ) external {
        if (_amountToWithdraw == 0) revert InvalidAmount();

        uint256 toWithdraw = _amountToWithdraw;
        address account = msg.sender;

        if (_shouldUnqueue == true) {
            _requireNotPaused();

            if (_merkleProof.length != 0) {
                bytes32 node = keccak256(bytes.concat(keccak256(abi.encode(account, _amount, _sharesAmount))));
                if (!MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, node)) revert InvalidProof();
            } else if (accountIndexes[account] &lt; merkleTreeSize) {
                revert InvalidProof();
            }

            uint256 queuedTokens = getQueuedTokens(account, _amount);
            uint256 canUnqueue = queuedTokens &lt;= totalQueued ? queuedTokens : totalQueued;
            uint256 amountToUnqueue = toWithdraw &lt;= canUnqueue ? toWithdraw : canUnqueue;

            if (amountToUnqueue != 0) {
                accountQueuedTokens[account] -= amountToUnqueue;
                totalQueued -= amountToUnqueue;
                toWithdraw -= amountToUnqueue;
                emit UnqueueTokens(account, amountToUnqueue);
            }
        }

        if (toWithdraw != 0) {
            IERC20Upgradeable(address(stakingPool)).safeTransferFrom(account, address(this), toWithdraw);
            _withdraw(toWithdraw);
            emit Withdraw(account, toWithdraw);
        }

        token.safeTransfer(account, _amountToWithdraw);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_shouldUnqueue == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcc31dc3514922dfea7bf8718e56422628990577d">0xcc31dc3514922dfea7bf8718e56422628990577d</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
    public
    onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true)
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false)
            {

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true)
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa36c3d224379cc5184b6a231867d22ac8f9d2e88">0xa36c3d224379cc5184b6a231867d22ac8f9d2e88</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa36c3d224379cc5184b6a231867d22ac8f9d2e88">0xa36c3d224379cc5184b6a231867d22ac8f9d2e88</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa36c3d224379cc5184b6a231867d22ac8f9d2e88">0xa36c3d224379cc5184b6a231867d22ac8f9d2e88</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa36c3d224379cc5184b6a231867d22ac8f9d2e88">0xa36c3d224379cc5184b6a231867d22ac8f9d2e88</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8882c5b51b4299eb54447d538ead13f7270ddb52">0x8882c5b51b4299eb54447d538ead13f7270ddb52</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8882c5b51b4299eb54447d538ead13f7270ddb52">0x8882c5b51b4299eb54447d538ead13f7270ddb52</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfa0fb199072d4f85db4c119e6956866c98370d9a">0xfa0fb199072d4f85db4c119e6956866c98370d9a</a></p>
<pre><code class="language-solidity">function depositWithdrawToken(uint128 amount, bool isDeposit, address prAddress) public
    {
        uint32 prCode = product_prCode[prAddress];
        require(amount &lt; maxBalance &amp;&amp; prCode != 0);
        uint32 accountId = FindOrAddAccount();
        require(accountId_freeze[accountId] == false);
        //require(accountId != 0);

        if (isDeposit == true)
        {
            require(prCode_productInfo[prCode].isDeposit == true);//Bug0310
            require(Token(prAddress).transferFrom(msg.sender, this, amount));
            prCode_AccountId_Balance[prCode][accountId].available = Add(prCode_AccountId_Balance[prCode][accountId].available, amount);
            require (prCode_AccountId_Balance[prCode][accountId].available &lt; maxBalance);
        }
        else
        {
            require(prCode_productInfo[prCode].isWithdraw == true);//Bug0310
            prCode_AccountId_Balance[prCode][accountId].available = Sub(prCode_AccountId_Balance[prCode][accountId].available, amount);
            require(Token(prAddress).transfer(msg.sender, amount));    
        }
        RecordDW(accountId, prCode, isDeposit, amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isDeposit == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfa0fb199072d4f85db4c119e6956866c98370d9a">0xfa0fb199072d4f85db4c119e6956866c98370d9a</a></p>
<pre><code class="language-solidity">function GetNextTick(bool isAsk, uint80 price, uint8 n) public pure returns (uint80)
    {
        if (price &gt; 0)
        {
            uint80 tick = GetTick(price, n);

            if (isAsk == true)
                return (((price - 1) / tick) + 1) * tick;
            else
                return (price / tick) * tick;
        }
        else
        {
            return price;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isAsk == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfa0fb199072d4f85db4c119e6956866c98370d9a">0xfa0fb199072d4f85db4c119e6956866c98370d9a</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 ownerId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true) 
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true)) 
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.ownerId = ownerId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;
        //order.timestamp = uint64(now);

        require (IsPossibleLimit(order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        //uint104 tradedQty = matchOrder(orderBook, order, lastOrderId);
        //BalanceUpdateByLimitAfterTrade(order, qty, tradedQty);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)// .orderN == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)// .orderN == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;// .firstID;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            //orderLink.id_orderList.Add(id, listItem);
            //id_Order.Add(id, order);
            //orderLink.id_orderList[lastOrderId] = listItem;

            AddOpenOrder(accountId, lastOrderId);
            //orderLink.orderN += 1;
            id_Order[lastOrderId] = order;
            //emit NewHogaChange(prTrade, prBase, isSell, price);

        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfa0fb199072d4f85db4c119e6956866c98370d9a">0xfa0fb199072d4f85db4c119e6956866c98370d9a</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 ownerId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true) 
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true)) 
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.ownerId = ownerId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;
        //order.timestamp = uint64(now);

        require (IsPossibleLimit(order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        //uint104 tradedQty = matchOrder(orderBook, order, lastOrderId);
        //BalanceUpdateByLimitAfterTrade(order, qty, tradedQty);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)// .orderN == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)// .orderN == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;// .firstID;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            //orderLink.id_orderList.Add(id, listItem);
            //id_Order.Add(id, order);
            //orderLink.id_orderList[lastOrderId] = listItem;

            AddOpenOrder(accountId, lastOrderId);
            //orderLink.orderN += 1;
            id_Order[lastOrderId] = order;
            //emit NewHogaChange(prTrade, prBase, isSell, price);

        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfa0fb199072d4f85db4c119e6956866c98370d9a">0xfa0fb199072d4f85db4c119e6956866c98370d9a</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 ownerId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true) 
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true)) 
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.ownerId = ownerId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;
        //order.timestamp = uint64(now);

        require (IsPossibleLimit(order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        //uint104 tradedQty = matchOrder(orderBook, order, lastOrderId);
        //BalanceUpdateByLimitAfterTrade(order, qty, tradedQty);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)// .orderN == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)// .orderN == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;// .firstID;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            //orderLink.id_orderList.Add(id, listItem);
            //id_Order.Add(id, order);
            //orderLink.id_orderList[lastOrderId] = listItem;

            AddOpenOrder(accountId, lastOrderId);
            //orderLink.orderN += 1;
            id_Order[lastOrderId] = order;
            //emit NewHogaChange(prTrade, prBase, isSell, price);

        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice</code></p>
<hr />
<h3>Contract : ShyftKycContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb17c88bda07d28b3838e0c1de6a30eafbcf52d85">0xb17c88bda07d28b3838e0c1de6a30eafbcf52d85</a></p>
<pre><code class="language-solidity">function kycSend(address _identifiedAddress, uint256 _amount, uint256 _bip32X_type, bool _requiredConsentFromAllParties, bool _payForDirty) public override returns (uint8 result) {
        if (balances[msg.sender][_bip32X_type] &gt;= _amount) {
            if (onlyAcceptsKycInput[_identifiedAddress] == false || (onlyAcceptsKycInput[_identifiedAddress] == true &amp;&amp; _requiredConsentFromAllParties == true)) {
                IShyftCacheGraph shyftCacheGraph = IShyftCacheGraph(shyftCacheGraphAddress);

                uint8 kycCanSendResult = shyftCacheGraph.getKycCanSend(msg.sender, _identifiedAddress, _amount, _bip32X_type, _requiredConsentFromAllParties, _payForDirty);

                //getKycCanSend return 3 = can transfer successfully
                if (kycCanSendResult == 3) {
                    balances[msg.sender][_bip32X_type] = balances[msg.sender][_bip32X_type].sub(_amount);
                    balances[_identifiedAddress][_bip32X_type] = balances[_identifiedAddress][_bip32X_type].add(_amount);

                    //successful transfer
                    return 3;
                } else {
                    //transfer cannot be processed due to transfer rules
                    return 2;
                }
            } else {
                //consent required
                return 1;
            }
        } else {
            //not enough balance to send
            return 0;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>onlyAcceptsKycInput[_identifiedAddress] == false || (onlyAcceptsKycInput[_identifiedAddress] == true &amp;&amp; _requiredConsentFromAllParties == true)</code></p>
<hr />
<h3>Contract : ShyftKycContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb17c88bda07d28b3838e0c1de6a30eafbcf52d85">0xb17c88bda07d28b3838e0c1de6a30eafbcf52d85</a></p>
<pre><code class="language-solidity">function kycSend(address _identifiedAddress, uint256 _amount, uint256 _bip32X_type, bool _requiredConsentFromAllParties, bool _payForDirty) public override returns (uint8 result) {
        if (balances[msg.sender][_bip32X_type] &gt;= _amount) {
            if (onlyAcceptsKycInput[_identifiedAddress] == false || (onlyAcceptsKycInput[_identifiedAddress] == true &amp;&amp; _requiredConsentFromAllParties == true)) {
                IShyftCacheGraph shyftCacheGraph = IShyftCacheGraph(shyftCacheGraphAddress);

                uint8 kycCanSendResult = shyftCacheGraph.getKycCanSend(msg.sender, _identifiedAddress, _amount, _bip32X_type, _requiredConsentFromAllParties, _payForDirty);

                //getKycCanSend return 3 = can transfer successfully
                if (kycCanSendResult == 3) {
                    balances[msg.sender][_bip32X_type] = balances[msg.sender][_bip32X_type].sub(_amount);
                    balances[_identifiedAddress][_bip32X_type] = balances[_identifiedAddress][_bip32X_type].add(_amount);

                    //successful transfer
                    return 3;
                } else {
                    //transfer cannot be processed due to transfer rules
                    return 2;
                }
            } else {
                //consent required
                return 1;
            }
        } else {
            //not enough balance to send
            return 0;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>onlyAcceptsKycInput[_identifiedAddress] == false || (onlyAcceptsKycInput[_identifiedAddress] == true &amp;&amp; _requiredConsentFromAllParties == true)</code></p>
<hr />
<h3>Contract : HelixNebula</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xacb2f5280e3615c18abd38ba8ba24dfe99a0da93">0xacb2f5280e3615c18abd38ba8ba24dfe99a0da93</a></p>
<pre><code class="language-solidity">function SendTransaction(address payable _adr,address payable _referraladr,bool _hasreferral) public payable{
        if(_hasreferral == true){
            balances[_referraladr] += (msg.value*(10**7))/HelixPrice;
            totalSupply += (msg.value*(10**7))/HelixPrice;
        }
        balances[msg.sender] += (msg.value*(10**7))/HelixPrice; 
        totalSupply += (msg.value*(10**7))/HelixPrice; //Helix nebula token is being made, when help to someone

        _adr.transfer(msg.value*9/10);
        wallet.transfer(msg.value/10);

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_hasreferral == true</code></p>
<hr />
<h3>Contract : ERC20Lean</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf71e2d29c5a0d4d787735293d2da5b5a28f80b43">0xf71e2d29c5a0d4d787735293d2da5b5a28f80b43</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        unchecked {
            uint256 _fee;
            keyHash = _keyHash;
            if (_mainetFee == true)
                _fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
            else _fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
            fee = _fee;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : HelmsForLoot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf54fd25cf570c90b4821ef212d58687a13c5d2a5">0xf54fd25cf570c90b4821ef212d58687a13c5d2a5</a></p>
<pre><code class="language-solidity">function purchaseMatching(
        ILoot claimLoot,
        uint256[] memory claimIds,
        uint256[] memory lootIds,
        bool claimRiftXP
    ) public payable {
        require(
            state == SaleState.Phase1 ||
                state == SaleState.Phase2 ||
                state == SaleState.Phase3,
            &quot;HelmsForLoot: sale not active&quot;
        );

        require(lootContracts[claimLoot], &quot;HelmsForLoot: not compatible&quot;);

        if (lootOnly == true) {
            require(
                claimLoot == ogLootContract,
                &quot;HelmsForLoot: loot-only minting period is active.&quot;
            );
        }

        require(lootIds.length &gt; 0, &quot;HelmsForLoot: buy at least one&quot;);
        require(lootIds.length &lt;= 26, &quot;HelmsForLoot: too many at once&quot;);

        uint256[] memory tokenIds = new uint256[](lootIds.length);
        uint256 price = 0;

        for (uint256 i = 0; i &lt; lootIds.length; i++) {
            // Reserve Loot IDs 7778 to 8000 for ownerClaim
            require(
                (lootIds[i] &gt; 0 &amp;&amp; lootIds[i] &lt; 7778),
                &quot;HelmsForLoot: invalid Loot ID&quot;
            );

            require(
                claimLoot.ownerOf(claimIds[i]) == msg.sender,
                &quot;HelmsForLoot: not owner&quot;
            );

            require(
                keccak256(abi.encodePacked(claimLoot.getHead(claimIds[i]))) ==
                    keccak256(
                        abi.encodePacked(ogLootContract.getHead(lootIds[i]))
                    ),
                &quot;HelmsForLoot: wrong helm&quot;
            );

            // Both the original loot bag and matching bag
            // (loot/mloot/genesis adventurer) to be unclaimed
            require(
                !lootClaimed[claimLoot][claimIds[i]],
                &quot;HelmsForLoot: bag already used for claim&quot;
            );
            require(
                !lootMinted[lootIds[i]],
                &quot;HelmsForLoot: loot bag already minted&quot;
            );

            uint256 rarity = helmRarity(lootIds[i]);

            if (rarity == 1) {
                require(
                    state == SaleState.Phase1 ||
                        state == SaleState.Phase2 ||
                        state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceCommon;
            } else if (rarity == 2) {
                require(
                    state == SaleState.Phase2 || state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceEpic;
            } else if (rarity == 3) {
                require(
                    state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceLegendary;
            } else {
                require(
                    state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceMythic;
            }
            lootMinted[lootIds[i]] = true;
            lootClaimed[claimLoot][claimIds[i]] = true;
            tokenIds[i] = lmartContract.headId(lootIds[i]);
        }
        require(msg.value == price, &quot;HelmsForLoot: wrong price&quot;);

        // We're using a loop with _mint rather than _mintBatch
        // as currently some centralised tools like Opensea
        // have issues understanding the `TransferBatch` event
        for (uint256 i = 0; i &lt; tokenIds.length; i++) {
            uint256 riftId;
            // Add XP via The Rift
            if (claimRiftXP == true) {
                // Adjust ID for gLoot:
                if (claimLoot != ogLootContract &amp;&amp; claimIds[i] &lt; 8001) {
                    riftId = claimIds[i] + 9997460;
                } else {
                    riftId = claimIds[i];
                }
                riftDataContract.addXP(200, riftId);
            }
            _mint(msg.sender, tokenIds[i], 1, &quot;&quot;);
            emit Claimed(lootIds[i]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claimRiftXP == true</code></p>
<hr />
<h3>Contract : ShyftKycContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcba3eae7f55d0f423af43cc85e67ab0fbf87b61c">0xcba3eae7f55d0f423af43cc85e67ab0fbf87b61c</a></p>
<pre><code class="language-solidity">function kycSend(address _identifiedAddress, uint256 _amount, uint256 _bip32X_type, bool _requiredConsentFromAllParties, bool _payForDirty) public returns (uint8 result) {
        if (balances[msg.sender][_bip32X_type] &gt;= _amount) {
            if (onlyAcceptsKycInput[_identifiedAddress] == false || (onlyAcceptsKycInput[_identifiedAddress] == true &amp;&amp; _requiredConsentFromAllParties == true)) {
                IShyftCacheGraph shyftCacheGraph = IShyftCacheGraph(shyftCacheGraphAddress);

                uint8 kycCanSendResult = shyftCacheGraph.getKycCanSend(msg.sender, _identifiedAddress, _amount, _bip32X_type, _requiredConsentFromAllParties, _payForDirty);

                //getKycCanSend return 3 = can transfer successfully
                if (kycCanSendResult == 3) {
                    balances[msg.sender][_bip32X_type] = balances[msg.sender][_bip32X_type].sub(_amount);
                    balances[_identifiedAddress][_bip32X_type] = balances[_identifiedAddress][_bip32X_type].add(_amount);

                    //successful transfer
                    return 3;
                } else {
                    //transfer cannot be processed due to transfer rules
                    return 2;
                }
            } else {
                //consent required
                return 1;
            }
        } else {
            //not enough balance to send
            return 0;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>onlyAcceptsKycInput[_identifiedAddress] == false || (onlyAcceptsKycInput[_identifiedAddress] == true &amp;&amp; _requiredConsentFromAllParties == true)</code></p>
<hr />
<h3>Contract : ShyftKycContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcba3eae7f55d0f423af43cc85e67ab0fbf87b61c">0xcba3eae7f55d0f423af43cc85e67ab0fbf87b61c</a></p>
<pre><code class="language-solidity">function kycSend(address _identifiedAddress, uint256 _amount, uint256 _bip32X_type, bool _requiredConsentFromAllParties, bool _payForDirty) public returns (uint8 result) {
        if (balances[msg.sender][_bip32X_type] &gt;= _amount) {
            if (onlyAcceptsKycInput[_identifiedAddress] == false || (onlyAcceptsKycInput[_identifiedAddress] == true &amp;&amp; _requiredConsentFromAllParties == true)) {
                IShyftCacheGraph shyftCacheGraph = IShyftCacheGraph(shyftCacheGraphAddress);

                uint8 kycCanSendResult = shyftCacheGraph.getKycCanSend(msg.sender, _identifiedAddress, _amount, _bip32X_type, _requiredConsentFromAllParties, _payForDirty);

                //getKycCanSend return 3 = can transfer successfully
                if (kycCanSendResult == 3) {
                    balances[msg.sender][_bip32X_type] = balances[msg.sender][_bip32X_type].sub(_amount);
                    balances[_identifiedAddress][_bip32X_type] = balances[_identifiedAddress][_bip32X_type].add(_amount);

                    //successful transfer
                    return 3;
                } else {
                    //transfer cannot be processed due to transfer rules
                    return 2;
                }
            } else {
                //consent required
                return 1;
            }
        } else {
            //not enough balance to send
            return 0;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>onlyAcceptsKycInput[_identifiedAddress] == false || (onlyAcceptsKycInput[_identifiedAddress] == true &amp;&amp; _requiredConsentFromAllParties == true)</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea35ce5a2fc4ced4464da4349f81a122fd12b">0xcafea35ce5a2fc4ced4464da4349f81a122fd12b</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2b26c6defdc47c5ce5622cb4037419c0a0b9d95b">0x2b26c6defdc47c5ce5622cb4037419c0a0b9d95b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2b26c6defdc47c5ce5622cb4037419c0a0b9d95b">0x2b26c6defdc47c5ce5622cb4037419c0a0b9d95b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2b26c6defdc47c5ce5622cb4037419c0a0b9d95b">0x2b26c6defdc47c5ce5622cb4037419c0a0b9d95b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2b26c6defdc47c5ce5622cb4037419c0a0b9d95b">0x2b26c6defdc47c5ce5622cb4037419c0a0b9d95b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : GMAMICO</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1e6131e43b6c3a8a8141ecdd4433fad784f551b6">0x1e6131e43b6c3a8a8141ecdd4433fad784f551b6</a></p>
<pre><code class="language-solidity">function payWithStablecoin(uint256 amountOfStablecoin, bool trueDaiFalseTUSD) public {
        require(ICOActive == true);
        uint256 amount = amountOfStablecoin.mul(10 ** GMAMDecimals).div(stablecoinCost);
        require(amount &lt;= IERC20(GMAMAddress).allowance(owner, address(this)));
        address stablecoinAddress;
        if (trueDaiFalseTUSD == true) {
            stablecoinAddress = DAIAddress;
        } else {
            stablecoinAddress = TUSDAddress;
        }
        require(amountOfStablecoin &lt;= IERC20(stablecoinAddress).allowance(msg.sender, address(this)));
        IERC20(stablecoinAddress).transferFrom(msg.sender, address(this), amountOfStablecoin);
        IERC20(stablecoinAddress).transfer(owner, amountOfStablecoin);
        IERC20(GMAMAddress).transferFrom(owner, address(this), amount);
        IERC20(GMAMAddress).transfer(msg.sender, amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>trueDaiFalseTUSD == true</code></p>
<hr />
<h3>Contract : BTTC</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac6b042a2633bfe0aa176c34cf3c32799d6d359c">0xac6b042a2633bfe0aa176c34cf3c32799d6d359c</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : Etheraffle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4251139bf01d46884c95b27666c9e317df68b876">0x4251139bf01d46884c95b27666c9e317df68b876</a></p>
<pre><code class="language-solidity">function manuallyMakeOraclizeCall
    (
        uint _week,
        uint _delay,
        bool _isRandom,
        bool _isManual
    )
        onlyEtheraffle external
    {
        string memory weekNumStr = uint2str(_week);
        if(_isRandom == true){
            bytes32 query = oraclize_query(_delay, &quot;nested&quot;, strConcat(randomStr1, weekNumStr, randomStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isRandom = true;
            qID[query].isManual = _isManual;
        } else {
            query = oraclize_query(_delay, &quot;nested&quot;, strConcat(apiStr1, weekNumStr, apiStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isManual = _isManual;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isRandom == true</code></p>
<hr />
<h3>Contract : Etheraffle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4251139bf01d46884c95b27666c9e317df68b876">0x4251139bf01d46884c95b27666c9e317df68b876</a></p>
<pre><code class="language-solidity">function manuallyMakeOraclizeCall
    (
        uint _week,
        uint _delay,
        bool _isRandom,
        bool _isManual
    )
        onlyEtheraffle external
    {
        string memory weekNumStr = uint2str(_week);
        if(_isRandom == true){
            bytes32 query = oraclize_query(_delay, &quot;nested&quot;, strConcat(randomStr1, weekNumStr, randomStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isRandom = true;
            qID[query].isManual = _isManual;
        } else {
            query = oraclize_query(_delay, &quot;nested&quot;, strConcat(apiStr1, weekNumStr, apiStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isManual = _isManual;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isRandom == true</code></p>
<hr />
<h3>Contract : Manager</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x99efed3b4e43738d44c1f532135cd16a240d983d">0x99efed3b4e43738d44c1f532135cd16a240d983d</a></p>
<pre><code class="language-solidity">constructor(address _vrfCoordinator, address _linkToken, bytes32 _keyHash, bool _mainetFee)
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10**18;// in mainnet, the fee must be 2 LINK
        else fee =  0.1 * 10**18; // 0.1 LINK In Rinkeby and Goerli         
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x81f8a1e401eae81c013b364b7aa79511935f5e95">0x81f8a1e401eae81c013b364b7aa79511935f5e95</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Castile_Tarot_Contract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc52183386ca5b1c1311ebe5465487b31f203a1f8">0xc52183386ca5b1c1311ebe5465487b31f203a1f8</a></p>
<pre><code class="language-solidity">function WhitelistCheck(address recipient, bytes32[] calldata _merkleProof, bool freeMint)
    public
    view 
    returns (bool) {
        bytes32 leaf = keccak256(abi.encodePacked(recipient));
        if(freeMint == true)
        {
            return MerkleProof.verify(_merkleProof, merkleRoot_free_wlist, leaf);
        }
        return MerkleProof.verify(_merkleProof, merkleRoot_fee_wlist, leaf);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>freeMint == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x55534e5f1f8dfb4db0f1d2a3a1d241ca5cf0dc62">0x55534e5f1f8dfb4db0f1d2a3a1d241ca5cf0dc62</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x55534e5f1f8dfb4db0f1d2a3a1d241ca5cf0dc62">0x55534e5f1f8dfb4db0f1d2a3a1d241ca5cf0dc62</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x55534e5f1f8dfb4db0f1d2a3a1d241ca5cf0dc62">0x55534e5f1f8dfb4db0f1d2a3a1d241ca5cf0dc62</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x55534e5f1f8dfb4db0f1d2a3a1d241ca5cf0dc62">0x55534e5f1f8dfb4db0f1d2a3a1d241ca5cf0dc62</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x957b80e735147696a80e69b61ab70d946e0ddd98">0x957b80e735147696a80e69b61ab70d946e0ddd98</a></p>
<pre><code class="language-solidity">function depositWithdrawToken(uint32 exId, uint128 amount, bool isDeposit, address prAddress) public
    {
        uint32 prCode = product_prCode[prAddress];
        require(amount &lt; maxBalance &amp;&amp; prCode != 0);
        uint32 accountId = FindOrAddAccount(msg.sender);
        require(accountId_freeze[accountId] == false);

        if (isDeposit == true)
        {
            require(prCode_productInfo[prCode].isDeposit == true &amp;&amp; isContractUse == true &amp;&amp; exId &lt;= lastOwnerId);
            require(Token(prAddress).transferFrom(msg.sender, this, amount));
            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Add(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);
            require (exId_prCode_AccountId_Balance[exId][prCode][accountId].available &lt; maxBalance);
        }
        else
        {
            require(prCode_productInfo[prCode].isWithdraw == true);
            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Sub(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);
            require(Token(prAddress).transfer(msg.sender, amount));
        }
        RecordDW(exId, accountId, prCode, isDeposit, amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isDeposit == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x957b80e735147696a80e69b61ab70d946e0ddd98">0x957b80e735147696a80e69b61ab70d946e0ddd98</a></p>
<pre><code class="language-solidity">function GetNextTick(bool isAsk, uint80 price, uint8 n) public pure returns (uint80)
    {
        if (price &gt; 0)
        {
            uint80 tick = GetTick(price, n);

            if (isAsk == true)
                return (((price - 1) / tick) + 1) * tick;
            else
                return (price / tick) * tick;
        }
        else
        {
            return price;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isAsk == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x957b80e735147696a80e69b61ab70d946e0ddd98">0x957b80e735147696a80e69b61ab70d946e0ddd98</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true)
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true))
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.exId = exId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;

        require (IsPossibleLimit(order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            AddOpenOrder(accountId, lastOrderId);
            id_Order[lastOrderId] = order;
        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x957b80e735147696a80e69b61ab70d946e0ddd98">0x957b80e735147696a80e69b61ab70d946e0ddd98</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true)
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true))
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.exId = exId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;

        require (IsPossibleLimit(order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            AddOpenOrder(accountId, lastOrderId);
            id_Order[lastOrderId] = order;
        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true</code></p>
<hr />
<h3>Contract : DEX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x957b80e735147696a80e69b61ab70d946e0ddd98">0x957b80e735147696a80e69b61ab70d946e0ddd98</a></p>
<pre><code class="language-solidity">function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)
    {
        uint32 accountId = FindOrRevertAccount();
        require(accountId_freeze[accountId] == false);
        uint80 lastBestPrice;
        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];
        require(price != 0 &amp;&amp; price &lt;= maxPrice &amp;&amp; qty &lt;= maxQty &amp;&amp;
            ((isSell == false &amp;&amp; prCode_productInfo[prTrade].isTradeBid == true &amp;&amp; prCode_productInfo[prBase].isTradeAsk == true)
            || (isSell == true &amp;&amp; prCode_productInfo[prTrade].isTradeAsk == true &amp;&amp; prCode_productInfo[prBase].isTradeBid == true))
            &amp;&amp; prCode_productInfo[prTrade].minQty &lt;= qty);

        if (isSell == true)
        {
            price = GetNextTick(true, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestAskPrice;
        }
        else
        {
            price = GetNextTick(false, price, orderBook.tickSize);
            lastBestPrice = orderBook.bestBidPrice;
        }

        Order memory order;
        order.exId = exId;
        order.isSell = isSell;
        order.prTrade = prTrade;
        order.prBase = prBase;
        order.accountId = accountId;
        order.price = price;
        order.qty = qty;

        require (IsPossibleLimit(order));

        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);

        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));

        if (order.qty != 0)
        {
            uint80 priceNext;
            uint80 price0;

            if (isSell == true)
            {
                price0 = orderBook.bestAskPrice;
                if (price0 == 0)
                {
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = 0;
                    orderBook.bestAskPrice = price;
                }
                else if(price &lt; price0)
                {
                    orderBook.askPrice_Order[price0].prevPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = 0;
                    orderBook.askPrice_Order[price].nextPrice = price0;
                    orderBook.bestAskPrice = price;
                }
                else if (orderBook.askPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &lt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.askPrice_Order[price0].nextPrice;
                    }

                    orderBook.askPrice_Order[price0].nextPrice = price;
                    orderBook.askPrice_Order[price].prevPrice = price0;
                    orderBook.askPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.askPrice_Order[priceNext].prevPrice = price;
                    }
                }

                OrderLink storage orderLink = orderBook.askPrice_Order[price];
            }
            else
            {
                price0 = orderBook.bestBidPrice;
                if (price0 == 0)
                {
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = 0;
                    orderBook.bestBidPrice = price;
                }
                else if (price &gt; price0)
                {
                    orderBook.bidPrice_Order[price0].prevPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = 0;
                    orderBook.bidPrice_Order[price].nextPrice = price0;
                    orderBook.bestBidPrice = price;
                }
                else if (orderBook.bidPrice_Order[price].firstId == 0)
                {
                    priceNext = price0;

                    while (priceNext != 0 &amp;&amp; priceNext &gt; price)
                    {
                        price0 = priceNext;
                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;
                    }

                    orderBook.bidPrice_Order[price0].nextPrice = price;
                    orderBook.bidPrice_Order[price].prevPrice = price0;
                    orderBook.bidPrice_Order[price].nextPrice = priceNext;
                    if (priceNext != 0)
                    {
                        orderBook.bidPrice_Order[priceNext].prevPrice = price;
                    }
                }

                orderLink = orderBook.bidPrice_Order[price];
            }

            if (lastOrderId != 0)
            {
                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;
                if (orderLink.firstId != 0)
                {
                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;
                }
                else
                {
                    orderLink.id_orderList[lastOrderId].next = 0;
                    orderLink.firstId = lastOrderId;
                }
                orderLink.lastId = lastOrderId;
            }

            AddOpenOrder(accountId, lastOrderId);
            id_Order[lastOrderId] = order;
        }

        if (isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);
        }
        if (isSell == false &amp;&amp; lastBestPrice != orderBook.bestBidPrice)
        {
            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);
        }

        return lastOrderId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isSell == true &amp;&amp; lastBestPrice != orderBook.bestAskPrice</code></p>
<hr />
<h3>Contract : UpgradeableNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7fc545622fc3f14732838d8bdb27ff424af0d19a">0x7fc545622fc3f14732838d8bdb27ff424af0d19a</a></p>
<pre><code class="language-solidity">function batchMint(address to, uint256 amountToMint, string memory metaId, uint256 setPrice, bool isForSale) public virtual {
    require(hasRole(MINTER_ROLE, _msgSender()), &quot;ERC721PresetMinterPauserAutoId: must have minter role to mint&quot;);
    require(amountToMint &lt;= 200, &quot;Over 200&quot;);

    for (uint256 i = 0; i &lt; amountToMint; i++) {
      id = id.add(1);
      items[id].price = setPrice;
      items[id].metaId = metaId;
      if(isForSale == true){
        items[id].state = TokenState.ForSale;

      } else {
        items[id].state = TokenState.Pending;
      }
      _mint(to, id);
      emit Minted(id, metaId);
    }

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isForSale == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyUSTFlashArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcad6d9d55e8b2fa31f36e53d16cd0acab473223f">0xcad6d9d55e8b2fa31f36e53d16cd0acab473223f</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyUSTFlashArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcad6d9d55e8b2fa31f36e53d16cd0acab473223f">0xcad6d9d55e8b2fa31f36e53d16cd0acab473223f</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrder(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrder(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4f3c021b75e5bdff3199b2ea7a883d7ce7307da0">0x4f3c021b75e5bdff3199b2ea7a883d7ce7307da0</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyFEIArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x99fd81da4c322cbaffc9549c728a2067d945504c">0x99fd81da4c322cbaffc9549c728a2067d945504c</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyFEIArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x99fd81da4c322cbaffc9549c728a2067d945504c">0x99fd81da4c322cbaffc9549c728a2067d945504c</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                uint256 buyID = getCheaperToken();
                checkAndSwapTokens(address(0), buyID, false);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrder(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrder(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : EnergyChainValidator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe602b373a6af18f7100357d27ac279541cc79c90">0xe602b373a6af18f7100357d27ac279541cc79c90</a></p>
<pre><code class="language-solidity">function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool) {
        if (vesting &lt; MIN_VESTING || vesting &gt; MAX_VESTING) {
            return false;
        }
        if (maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators) {
            return false;
        }

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators</code></p>
<hr />
<h3>Contract : evaiStableCoinFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x17cad83c4360ae47647c3e4eca2d337d3c876391">0x17cad83c4360ae47647c3e4eca2d337d3c876391</a></p>
<pre><code class="language-solidity">function withdraw(
        uint32 _stakeID,
        bool _full,
        uint64 _withdrawAmount
    ) external nonReentrant {
        require(
            stakeByID[_stakeID].ownerAddress == msg.sender,
            &quot;Unauthorized Stake owner&quot;
        );
        require(stakeByID[_stakeID].active == true, &quot;Stake was settled&quot;);
        uint256 elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
            uint256(stakeByID[_stakeID].startOfTerm),
            uint256(block.timestamp)
        );
        uint256 totalReturns;
        uint256 stakeReturns;
        uint256 rewardEndTime;
        if (elapsedTime &lt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm) {
            totalReturns = compound(
                (stakeByID[_stakeID].evaiAmount),
                (stakeTypes[stakeByID[_stakeID].Type].percentageReturn),
                elapsedTime
            );
            stakeReturns = totalReturns - stakeByID[_stakeID].evaiAmount;
        } else if (
            elapsedTime == stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            totalReturns = (stakeByID[_stakeID].evaiAmount *
                (stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier));
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        } else if (
            elapsedTime &gt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            uint256 daysForYearInProgress = elapsedTime.mod(
                uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
            );
            uint256 completedYears = (elapsedTime.sub(daysForYearInProgress))
                .div(uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm));

            rewardEndTime = BokkyPooBahsDateTimeLibrary.addDays(
                uint256(stakeByID[_stakeID].startOfTerm),
                uint256(
                    (completedYears + 1) *
                        uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                )
            );

            if (rewardEndTime &lt; uint256(block.timestamp)) {
                // Calculated elapsed time again
                elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
                    uint256(stakeByID[_stakeID].startOfTerm),
                    rewardEndTime
                );

                daysForYearInProgress = elapsedTime.mod(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
                completedYears = (elapsedTime.sub(daysForYearInProgress)).div(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
            }

            uint256 bMul = uint256(
                stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier
            );

            uint256 postBonusBalance = calculatePostBonusBalance(
                uint256(stakeByID[_stakeID].evaiAmount),
                completedYears,
                bMul
            );

            uint256 pReturns = stakeTypes[stakeByID[_stakeID].Type]
                .percentageReturn;

            totalReturns = compound(
                postBonusBalance,
                pReturns,
                daysForYearInProgress
            );
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        }

        if (_full == true) {
            stakeByID[_stakeID].partialWithdrawn = false;
            stakeByID[_stakeID].settlementAmount = uint64(totalReturns);
            stakeByID[_stakeID].stakeReturns = uint64(stakeReturns);
        } else {
            require(
                _withdrawAmount &lt;= uint64(totalReturns),
                &quot;Amount to claim is higher than returns&quot;
            );
            stakeByID[_stakeID].settlementAmount = _withdrawAmount;
        }

        if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            //Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            totalProfitsDistrubuted += stakeByID[_stakeID].stakeReturns;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
        } else if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            emitWithdrawStake(_stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            // Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
            // restake with the remaining amount
            uint8 Type = stakeByID[_stakeID].Type;
            uint256 reStakeAmount = totalReturns -
                (stakeByID[_stakeID].settlementAmount);
            reStake(uint64(reStakeAmount), Type, _stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            emitWithdrawStake(_stakeID);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_full == true</code></p>
<hr />
<h3>Contract : evaiStableCoinFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x17cad83c4360ae47647c3e4eca2d337d3c876391">0x17cad83c4360ae47647c3e4eca2d337d3c876391</a></p>
<pre><code class="language-solidity">function withdraw(
        uint32 _stakeID,
        bool _full,
        uint64 _withdrawAmount
    ) external nonReentrant {
        require(
            stakeByID[_stakeID].ownerAddress == msg.sender,
            &quot;Unauthorized Stake owner&quot;
        );
        require(stakeByID[_stakeID].active == true, &quot;Stake was settled&quot;);
        uint256 elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
            uint256(stakeByID[_stakeID].startOfTerm),
            uint256(block.timestamp)
        );
        uint256 totalReturns;
        uint256 stakeReturns;
        uint256 rewardEndTime;
        if (elapsedTime &lt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm) {
            totalReturns = compound(
                (stakeByID[_stakeID].evaiAmount),
                (stakeTypes[stakeByID[_stakeID].Type].percentageReturn),
                elapsedTime
            );
            stakeReturns = totalReturns - stakeByID[_stakeID].evaiAmount;
        } else if (
            elapsedTime == stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            totalReturns = (stakeByID[_stakeID].evaiAmount *
                (stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier));
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        } else if (
            elapsedTime &gt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            uint256 daysForYearInProgress = elapsedTime.mod(
                uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
            );
            uint256 completedYears = (elapsedTime.sub(daysForYearInProgress))
                .div(uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm));

            rewardEndTime = BokkyPooBahsDateTimeLibrary.addDays(
                uint256(stakeByID[_stakeID].startOfTerm),
                uint256(
                    (completedYears + 1) *
                        uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                )
            );

            if (rewardEndTime &lt; uint256(block.timestamp)) {
                // Calculated elapsed time again
                elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
                    uint256(stakeByID[_stakeID].startOfTerm),
                    rewardEndTime
                );

                daysForYearInProgress = elapsedTime.mod(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
                completedYears = (elapsedTime.sub(daysForYearInProgress)).div(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
            }

            uint256 bMul = uint256(
                stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier
            );

            uint256 postBonusBalance = calculatePostBonusBalance(
                uint256(stakeByID[_stakeID].evaiAmount),
                completedYears,
                bMul
            );

            uint256 pReturns = stakeTypes[stakeByID[_stakeID].Type]
                .percentageReturn;

            totalReturns = compound(
                postBonusBalance,
                pReturns,
                daysForYearInProgress
            );
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        }

        if (_full == true) {
            stakeByID[_stakeID].partialWithdrawn = false;
            stakeByID[_stakeID].settlementAmount = uint64(totalReturns);
            stakeByID[_stakeID].stakeReturns = uint64(stakeReturns);
        } else {
            require(
                _withdrawAmount &lt;= uint64(totalReturns),
                &quot;Amount to claim is higher than returns&quot;
            );
            stakeByID[_stakeID].settlementAmount = _withdrawAmount;
        }

        if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            //Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            totalProfitsDistrubuted += stakeByID[_stakeID].stakeReturns;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
        } else if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            emitWithdrawStake(_stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            // Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
            // restake with the remaining amount
            uint8 Type = stakeByID[_stakeID].Type;
            uint256 reStakeAmount = totalReturns -
                (stakeByID[_stakeID].settlementAmount);
            reStake(uint64(reStakeAmount), Type, _stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            emitWithdrawStake(_stakeID);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))</code></p>
<hr />
<h3>Contract : evaiStableCoinFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x17cad83c4360ae47647c3e4eca2d337d3c876391">0x17cad83c4360ae47647c3e4eca2d337d3c876391</a></p>
<pre><code class="language-solidity">function withdraw(
        uint32 _stakeID,
        bool _full,
        uint64 _withdrawAmount
    ) external nonReentrant {
        require(
            stakeByID[_stakeID].ownerAddress == msg.sender,
            &quot;Unauthorized Stake owner&quot;
        );
        require(stakeByID[_stakeID].active == true, &quot;Stake was settled&quot;);
        uint256 elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
            uint256(stakeByID[_stakeID].startOfTerm),
            uint256(block.timestamp)
        );
        uint256 totalReturns;
        uint256 stakeReturns;
        uint256 rewardEndTime;
        if (elapsedTime &lt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm) {
            totalReturns = compound(
                (stakeByID[_stakeID].evaiAmount),
                (stakeTypes[stakeByID[_stakeID].Type].percentageReturn),
                elapsedTime
            );
            stakeReturns = totalReturns - stakeByID[_stakeID].evaiAmount;
        } else if (
            elapsedTime == stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            totalReturns = (stakeByID[_stakeID].evaiAmount *
                (stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier));
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        } else if (
            elapsedTime &gt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            uint256 daysForYearInProgress = elapsedTime.mod(
                uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
            );
            uint256 completedYears = (elapsedTime.sub(daysForYearInProgress))
                .div(uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm));

            rewardEndTime = BokkyPooBahsDateTimeLibrary.addDays(
                uint256(stakeByID[_stakeID].startOfTerm),
                uint256(
                    (completedYears + 1) *
                        uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                )
            );

            if (rewardEndTime &lt; uint256(block.timestamp)) {
                // Calculated elapsed time again
                elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
                    uint256(stakeByID[_stakeID].startOfTerm),
                    rewardEndTime
                );

                daysForYearInProgress = elapsedTime.mod(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
                completedYears = (elapsedTime.sub(daysForYearInProgress)).div(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
            }

            uint256 bMul = uint256(
                stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier
            );

            uint256 postBonusBalance = calculatePostBonusBalance(
                uint256(stakeByID[_stakeID].evaiAmount),
                completedYears,
                bMul
            );

            uint256 pReturns = stakeTypes[stakeByID[_stakeID].Type]
                .percentageReturn;

            totalReturns = compound(
                postBonusBalance,
                pReturns,
                daysForYearInProgress
            );
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        }

        if (_full == true) {
            stakeByID[_stakeID].partialWithdrawn = false;
            stakeByID[_stakeID].settlementAmount = uint64(totalReturns);
            stakeByID[_stakeID].stakeReturns = uint64(stakeReturns);
        } else {
            require(
                _withdrawAmount &lt;= uint64(totalReturns),
                &quot;Amount to claim is higher than returns&quot;
            );
            stakeByID[_stakeID].settlementAmount = _withdrawAmount;
        }

        if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            //Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            totalProfitsDistrubuted += stakeByID[_stakeID].stakeReturns;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
        } else if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            emitWithdrawStake(_stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            // Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
            // restake with the remaining amount
            uint8 Type = stakeByID[_stakeID].Type;
            uint256 reStakeAmount = totalReturns -
                (stakeByID[_stakeID].settlementAmount);
            reStake(uint64(reStakeAmount), Type, _stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            emitWithdrawStake(_stakeID);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))</code></p>
<hr />
<h3>Contract : FloorCheeseburger</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdeaf3ed793d5eac9b5a6a44f9c06c12a3149db4b">0xdeaf3ed793d5eac9b5a6a44f9c06c12a3149db4b</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : TeamAnonymous</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7c994f3cae4f745eec885b5b86fc138947044ba5">0x7c994f3cae4f745eec885b5b86fc138947044ba5</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1b8aabbea1ffe9cb9f4eb7f47ae80babda4133fb">0x1b8aabbea1ffe9cb9f4eb7f47ae80babda4133fb</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1b8aabbea1ffe9cb9f4eb7f47ae80babda4133fb">0x1b8aabbea1ffe9cb9f4eb7f47ae80babda4133fb</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Paused</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb78bb3068d16803c3d643d166b69f084f46b98e4">0xb78bb3068d16803c3d643d166b69f084f46b98e4</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Paused</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb78bb3068d16803c3d643d166b69f084f46b98e4">0xb78bb3068d16803c3d643d166b69f084f46b98e4</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Paused</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb78bb3068d16803c3d643d166b69f084f46b98e4">0xb78bb3068d16803c3d643d166b69f084f46b98e4</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Paused</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb78bb3068d16803c3d643d166b69f084f46b98e4">0xb78bb3068d16803c3d643d166b69f084f46b98e4</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : TOMMY</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x491965ec0837092039550e96ca6a46fdaf9d3ca3">0x491965ec0837092039550e96ca6a46fdaf9d3ca3</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : MSDropERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6cb0e466e496e5e1d34b3550e7070b39b0d502a6">0x6cb0e466e496e5e1d34b3550e7070b39b0d502a6</a></p>
<pre><code class="language-solidity">function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bool _isAuction,
    Auction calldata _auction,
    bool _isPhysic,
    ClaimCondition[] calldata _phases,
    bool _resetClaimEligibility,
    bool update
  ) external onlyRole(MINTER_ROLE) {
    uint256 startId = nextTokenIdToMint;
    uint256 index = startId + _amount;
    if (update == true) {
      index = _amount;
    } else {
      indices.push(index);
      emit TokensLazyMinted(startId, index - 1, _baseURIForTokens, royaltyRecipient);
    }

    nextTokenIdToMint = index;
    baseURI[index] = _baseURIForTokens;
    if (_isAuction) {
      Editions[index].isAuction=_isAuction;
      Editions[index].auction=_auction;
      emit AuctionsConditionsUpdated(_phases, _auction, startId, index - 1);
    } else {
      Editions[index].isPhysic = _isPhysic;
      setClaimConditions(index, _phases, _resetClaimEligibility, startId, index - 1);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>update == true</code></p>
<hr />
<h3>Contract : MSDropERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6cb0e466e496e5e1d34b3550e7070b39b0d502a6">0x6cb0e466e496e5e1d34b3550e7070b39b0d502a6</a></p>
<pre><code class="language-solidity">function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bool _isAuction,
    Auction calldata _auction,
    bool _isPhysic,
    ClaimCondition[] calldata _phases,
    bool _resetClaimEligibility,
    bool update
  ) external onlyRole(MINTER_ROLE) {
    uint256 startId = nextTokenIdToMint;
    uint256 index = startId + _amount;
    if (update == true) {
      index = _amount;
    } else {
      indices.push(index);
      emit TokensLazyMinted(startId, index - 1, _baseURIForTokens, royaltyRecipient);
    }

    nextTokenIdToMint = index;
    baseURI[index] = _baseURIForTokens;
    if (_isAuction) {
      Editions[index].isAuction=_isAuction;
      Editions[index].auction=_auction;
      emit AuctionsConditionsUpdated(_phases, _auction, startId, index - 1);
    } else {
      Editions[index].isPhysic = _isPhysic;
      setClaimConditions(index, _phases, _resetClaimEligibility, startId, index - 1);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>update == true</code></p>
<hr />
<h3>Contract : MSDropERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6cb0e466e496e5e1d34b3550e7070b39b0d502a6">0x6cb0e466e496e5e1d34b3550e7070b39b0d502a6</a></p>
<pre><code class="language-solidity">function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bool _isAuction,
    Auction calldata _auction,
    bool _isPhysic,
    ClaimCondition[] calldata _phases,
    bool _resetClaimEligibility,
    bool update
  ) external onlyRole(MINTER_ROLE) {
    uint256 startId = nextTokenIdToMint;
    uint256 index = startId + _amount;
    if (update == true) {
      index = _amount;
    } else {
      indices.push(index);
      emit TokensLazyMinted(startId, index - 1, _baseURIForTokens, royaltyRecipient);
    }

    nextTokenIdToMint = index;
    baseURI[index] = _baseURIForTokens;
    if (_isAuction) {
      Editions[index].isAuction=_isAuction;
      Editions[index].auction=_auction;
      emit AuctionsConditionsUpdated(_phases, _auction, startId, index - 1);
    } else {
      Editions[index].isPhysic = _isPhysic;
      setClaimConditions(index, _phases, _resetClaimEligibility, startId, index - 1);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>update == true</code></p>
<hr />
<h3>Contract : MSDropERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6cb0e466e496e5e1d34b3550e7070b39b0d502a6">0x6cb0e466e496e5e1d34b3550e7070b39b0d502a6</a></p>
<pre><code class="language-solidity">function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bool _isAuction,
    Auction calldata _auction,
    bool _isPhysic,
    ClaimCondition[] calldata _phases,
    bool _resetClaimEligibility,
    bool update
  ) external onlyRole(MINTER_ROLE) {
    uint256 startId = nextTokenIdToMint;
    uint256 index = startId + _amount;
    if (update == true) {
      index = _amount;
    } else {
      indices.push(index);
      emit TokensLazyMinted(startId, index - 1, _baseURIForTokens, royaltyRecipient);
    }

    nextTokenIdToMint = index;
    baseURI[index] = _baseURIForTokens;
    if (_isAuction) {
      Editions[index].isAuction=_isAuction;
      Editions[index].auction=_auction;
      emit AuctionsConditionsUpdated(_phases, _auction, startId, index - 1);
    } else {
      Editions[index].isPhysic = _isPhysic;
      setClaimConditions(index, _phases, _resetClaimEligibility, startId, index - 1);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>update == true</code></p>
<hr />
<h3>Contract : Echoes</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xece27fabd815edcb8919a0119313d4797dfb3bf7">0xece27fabd815edcb8919a0119313d4797dfb3bf7</a></p>
<pre><code class="language-solidity">function validateSubmittedEcho(bool ok) public{
        require(_msgSender() == _owner,&quot;only the owner can refuse an echo&quot;);

        if(ok == true){ 

            if(echoes.length%6 == 0){  //making sure to mint a token every 6th echo as needed
            _mint(msg.sender,echoes.length/6); 
            }
            echoes.push(submission[0]); //update the new echo data
            contributors.push(submission[1]);
            signers.push(submission[2]);
            dates.push(submission[3]);
            colors.push(submission[4]);
        }
        delete submission; //refresh the submission array

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ok == true</code></p>
<hr />
<h3>Contract : MuskCultClassic</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb49e2a10a0c2def116dad240979b759726d54984">0xb49e2a10a0c2def116dad240979b759726d54984</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : Memefund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xddaddd4f73abc3a6552de43aba325f506232fa8a">0xddaddd4f73abc3a6552de43aba325f506232fa8a</a></p>
<pre><code class="language-solidity">function rebase(uint256 supplyDelta, bool increaseSupply) external returns (uint256) {
        require(msg.sender == rebaseOracle, &quot;Can only be executed by rebaseOracle.&quot;);

        if (supplyDelta == 0) {
            emit LogRebase(totalSupply);
            return totalSupply;
        }

        if (increaseSupply == true) {
            totalSupply = totalSupply.add(supplyDelta);
        } else {
            totalSupply = totalSupply.sub(supplyDelta);
        }

        if (totalSupply &gt; MAXSUPPLY) {
            totalSupply = MAXSUPPLY;
        }

        atomsPerMolecule = totalAtoms.div(totalSupply);

        emit LogRebase(totalSupply);
        return totalSupply;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>increaseSupply == true</code></p>
<hr />
<h3>Contract : NFTSingleNoGatingSevPrices</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5d50ee4876bad077238070e4ae2520c0de1db66e">0x5d50ee4876bad077238070e4ae2520c0de1db66e</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : Layer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1db2374bb14f81855f7b2b0ae1e3bd36350dc8e4">0x1db2374bb14f81855f7b2b0ae1e3bd36350dc8e4</a></p>
<pre><code class="language-solidity">function selectOption ( 
    uint256 tokenID,
    uint256 randomNumber,
    bool forceZeroOption
  ) public
  returns (uint256){
    if(isDefaultLayer){
      require(msg.sender == composableNFTAddress, &quot;Only NFT Contract can select option on Default Layer&quot;);
    } else {
      require(IERC721(composableNFTAddress).ownerOf(tokenID) == msg.sender, &quot;Only NFT owner can call&quot;);
    }

    // Make sure every layer has a default Zero option that is an empty layer
    // rarityStart &amp; rarityEnd should both be 0, so that is is impossible to be selected unless manually set due to specific if-then logic
    if(forceZeroOption == true){
        selectedOption[tokenID] = OptionSelection({
          optionNumber: 0,
          color1Hex: layerOptions[0].defaultColor1Hex,
          color2Hex: layerOptions[0].defaultColor2Hex
        });
        return 0;
    }

    for(uint256 i = 0; i &lt; layerOptions.length; i++){
      if(
        randomNumber &gt;= layerOptions[i].rarityStart &amp;&amp; 
        randomNumber &lt; layerOptions[i].rarityEnd
      ) {
        selectedOption[tokenID] = OptionSelection({
          optionNumber: i,
          color1Hex: layerOptions[i].defaultColor1Hex,
          color2Hex: layerOptions[i].defaultColor2Hex
        });
        return i;
      }
    }
    return 99; // should never reach here
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>forceZeroOption == true</code></p>
<hr />
<h3>Contract : LayerInstance</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1db2374bb14f81855f7b2b0ae1e3bd36350dc8e4">0x1db2374bb14f81855f7b2b0ae1e3bd36350dc8e4</a></p>
<pre><code class="language-solidity">function selectOption ( 
    uint256 tokenID,
    uint256 randomNumber,
    bool forceZeroOption
  ) public
  returns (uint256){
    if(isDefaultLayer){
      require(msg.sender == composableNFTAddress, &quot;Only NFT Contract can select option on Default Layer&quot;);
    } else {
      require(IERC721(composableNFTAddress).ownerOf(tokenID) == msg.sender, &quot;Only NFT owner can call&quot;);
    }

    // Make sure every layer has a default Zero option that is an empty layer
    // rarityStart &amp; rarityEnd should both be 0, so that is is impossible to be selected unless manually set due to specific if-then logic
    if(forceZeroOption == true){
        selectedOption[tokenID] = OptionSelection({
          optionNumber: 0,
          color1Hex: layerOptions[0].defaultColor1Hex,
          color2Hex: layerOptions[0].defaultColor2Hex
        });
        return 0;
    }

    for(uint256 i = 0; i &lt; layerOptions.length; i++){
      if(
        randomNumber &gt;= layerOptions[i].rarityStart &amp;&amp; 
        randomNumber &lt; layerOptions[i].rarityEnd
      ) {
        selectedOption[tokenID] = OptionSelection({
          optionNumber: i,
          color1Hex: layerOptions[i].defaultColor1Hex,
          color2Hex: layerOptions[i].defaultColor2Hex
        });
        return i;
      }
    }
    return 99; // should never reach here
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>forceZeroOption == true</code></p>
<hr />
<h3>Contract : SignataRight</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5e93d064008d7d3001f27e296a1b046635a58baa">0x5e93d064008d7d3001f27e296a1b046635a58baa</a></p>
<pre><code class="language-solidity">function mintRight(uint256 schemaId, address to, bool unbound) external {
        require(
            _rightsTotal != MAX_UINT256,
            &quot;SignataRight: Maximum amount of tokens already minted.&quot;
        );

        require(
            _schemaToMintingRight[schemaId] != 0,
            &quot;SignataRight: Schema ID must correspond to an existing schema.&quot;
        );

        address minter;

        if (msg.sender.isContract()) {
            minter = msg.sender;
        } else {
            minter = _signataIdentity.getIdentity(msg.sender);

            require(
                !_signataIdentity.isLocked(minter),
                &quot;SignataRight: The sender's account is locked.&quot;
            );
        }

        require(
            minter == _rightToOwner[_schemaToMintingRight[schemaId]],
            &quot;SignataRight: The sender is not the minter for the schema specified.&quot;
        );

        address recipient;

        if (to.isContract()) {
            recipient = to;
        } else if (unbound == true) {
            recipient = to;
        } else {
            recipient = _signataIdentity.getIdentity(to);
        }

        _rightsTotal += 1;
        _rightToOwner[_rightsTotal] = recipient;
        _rightToSchema[_rightsTotal] = schemaId;

        uint256 schemaToRightsLength = _schemaToRightBalance[schemaId];

        _schemaToRights[schemaId][schemaToRightsLength] = _rightsTotal;
        _schemaToRightBalance[schemaId] += 1;
        _ownerToSchemaBalance[recipient][schemaId] += 1;

        uint256 ownerToRightsLength = _ownerToRightBalance[recipient];

        _ownerToRights[recipient][ownerToRightsLength] = _rightsTotal;
        _rightToOwnerRightsIndex[_rightsTotal] = ownerToRightsLength;
        _ownerToRightBalance[recipient] += 1;

        require(
            _isSafeToTransfer(address(0), recipient, _rightsTotal, &quot;&quot;),
            &quot;SignataRight: must only transfer to ERC721Receiver implementers when recipient is a smart contract.&quot;
        );

        emit MintRight(schemaId, _rightsTotal, unbound);

        emit Transfer(address(0), to, _rightsTotal);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>unbound == true</code></p>
<hr />
<h3>Contract : MarsGenesisWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7fbb661e4117463c9321a5f23eca0ccb17ae5d89">0x7fbb661e4117463c9321a5f23eca0ccb17ae5d89</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea7934490ef8b9d2572eaefeb9d48162ea5d8">0xcafea7934490ef8b9d2572eaefeb9d48162ea5d8</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyUSTArbV4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ddc45f84078d8b54e26ace35449e65476b3723b">0x8ddc45f84078d8b54e26ace35449e65476b3723b</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyUSTArbV4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ddc45f84078d8b54e26ace35449e65476b3723b">0x8ddc45f84078d8b54e26ace35449e65476b3723b</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(_depositor, 1, 0);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrder(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrder(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdbe5c9e19878fc49c08f2d90c9f22d0f1e601264">0xdbe5c9e19878fc49c08f2d90c9f22d0f1e601264</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : proposal</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad8c00635ea9e52e76c1db65a7223dbeaa564182">0xad8c00635ea9e52e76c1db65a7223dbeaa564182</a></p>
<pre><code class="language-solidity">function vote(uint256 _proposalId, bool _vote ) external onlyHolder {
        require(proposaldetail[_proposalId].proposalStart &lt;= block.timestamp ,&quot;proposal voting time not yet started&quot;);
        require(block.timestamp &lt;= proposaldetail[_proposalId].proposalEnd ,&quot;proposal voting time ended&quot;);
        require(!_voterInfo[_proposalId][msg.sender],&quot;user already voted&quot;);



            if(_vote == true){
                count1 ++;
            }else{
                count2 ++ ; 
            }
            proposalfinal[_proposalId].__proposalId = _proposalId;
            proposalfinal[_proposalId].upvote = count1;
            proposalfinal[_proposalId].downvote = count2;
            _voterInfo[_proposalId][msg.sender]=true;
           if(block.timestamp &gt;= proposaldetail[_proposalId].proposalEnd){
               proposaldetail[_proposalId].status = &quot;close&quot;;
           }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : Angel</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x16ec8f1b704fb84509f2e3565cccef87ea8e7714">0x16ec8f1b704fb84509f2e3565cccef87ea8e7714</a></p>
<pre><code class="language-solidity">function fromBoolToString(bool _data) public pure returns (string memory) {
        if (_data == true) {
            return &quot;true&quot;;
        } else {
            return &quot;false&quot;;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_data == true</code></p>
<hr />
<h3>Contract : Treasury</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4c26f6b312dc664e48727a9391ed0578cf3286fe">0x4c26f6b312dc664e48727a9391ed0578cf3286fe</a></p>
<pre><code class="language-solidity">function setBeneficiary(address a, bool solid, uint amount, uint lastClaim, uint emission) public {
        require(msg.sender == _governance &amp;&amp; bens[a].solid == false &amp;&amp; amount&lt;=4e22 &amp;&amp; lastClaim &lt; block.number+1e6 &amp;&amp; emission &gt;= 1e2 &amp;&amp; emission &lt;=1e4);
        if(lastClaim &lt; block.number) {lastClaim = block.number;}
        if(lastClaim &lt; 12510400) {lastClaim = 12510400;}
        if(lastClaim &gt; 12510400 &amp;&amp; lastClaim &lt; 1264e4) {lastClaim = 1264e4;}//so it adds even more convenience
        if (solid == true) {bens[a].solid = true;}
        uint lc = bens[a].lastClaim;
        if (lc == 0) {bens[a].lastClaim = uint32(lastClaim+129600);} // this 3 weeks delay disallows deployer to be malicious, can be removed after the governance will have control over treasury
        if (bens[a].amount == 0 &amp;&amp; lc != 0) {bens[a].lastClaim = uint32(lastClaim);}
        bens[a].amount = uint88(amount);
        bens[a].emission = uint16(emission);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>solid == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x48c5e896d241afd1aee73ae19259a2e234256a85">0x48c5e896d241afd1aee73ae19259a2e234256a85</a></p>
<pre><code class="language-solidity">function claimComp(
        address[] memory holders,
        CToken[] memory cTokens,
        bool borrowers,
        bool suppliers
    ) public {
        for (uint256 i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true &amp;&amp; address(cToken) != getXinvAddress()) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(
                        address(cToken),
                        holders[j],
                        borrowIndex
                    );
                    compAccrued[holders[j]] = grantCompInternal(
                        holders[j],
                        compAccrued[holders[j]]
                    );
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(
                        holders[j],
                        compAccrued[holders[j]]
                    );
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true &amp;&amp; address(cToken) != getXinvAddress()</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x48c5e896d241afd1aee73ae19259a2e234256a85">0x48c5e896d241afd1aee73ae19259a2e234256a85</a></p>
<pre><code class="language-solidity">function claimComp(
        address[] memory holders,
        CToken[] memory cTokens,
        bool borrowers,
        bool suppliers
    ) public {
        for (uint256 i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true &amp;&amp; address(cToken) != getXinvAddress()) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(
                        address(cToken),
                        holders[j],
                        borrowIndex
                    );
                    compAccrued[holders[j]] = grantCompInternal(
                        holders[j],
                        compAccrued[holders[j]]
                    );
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(
                        holders[j],
                        compAccrued[holders[j]]
                    );
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x48c5e896d241afd1aee73ae19259a2e234256a85">0x48c5e896d241afd1aee73ae19259a2e234256a85</a></p>
<pre><code class="language-solidity">function claimComp(
        address[] memory holders,
        CToken[] memory cTokens,
        bool borrowers,
        bool suppliers
    ) public {
        for (uint256 i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true &amp;&amp; address(cToken) != getXinvAddress()) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(
                        address(cToken),
                        holders[j],
                        borrowIndex
                    );
                    compAccrued[holders[j]] = grantCompInternal(
                        holders[j],
                        compAccrued[holders[j]]
                    );
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(
                        holders[j],
                        compAccrued[holders[j]]
                    );
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true &amp;&amp; address(cToken) != getXinvAddress()</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x48c5e896d241afd1aee73ae19259a2e234256a85">0x48c5e896d241afd1aee73ae19259a2e234256a85</a></p>
<pre><code class="language-solidity">function claimComp(
        address[] memory holders,
        CToken[] memory cTokens,
        bool borrowers,
        bool suppliers
    ) public {
        for (uint256 i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true &amp;&amp; address(cToken) != getXinvAddress()) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(
                        address(cToken),
                        holders[j],
                        borrowIndex
                    );
                    compAccrued[holders[j]] = grantCompInternal(
                        holders[j],
                        compAccrued[holders[j]]
                    );
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint256 j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(
                        holders[j],
                        compAccrued[holders[j]]
                    );
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafeaea91ec6a2da356a05d00d46eafda28b6dd8">0xcafeaea91ec6a2da356a05d00d46eafda28b6dd8</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xab220e486fe92c385eebc87bd39bdaed70687c01">0xab220e486fe92c385eebc87bd39bdaed70687c01</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : JBController3_0_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa139d37275d1ff7275e6f33821898934bc8cb7b6">0xa139d37275d1ff7275e6f33821898934bc8cb7b6</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  )
    external
    virtual
    override
    returns (uint256 beneficiaryTokenCount)
  {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate != JBConstants.MAX_RESERVED_RATE) {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    // Add reserved tokens if needed
    if (_reservedRate &gt; 0)
      _reservedTokenBalanceOf[_projectId] += _tokenCount - beneficiaryTokenCount;

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : JBController3_0_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa139d37275d1ff7275e6f33821898934bc8cb7b6">0xa139d37275d1ff7275e6f33821898934bc8cb7b6</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  )
    external
    virtual
    override
    returns (uint256 beneficiaryTokenCount)
  {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate != JBConstants.MAX_RESERVED_RATE) {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    // Add reserved tokens if needed
    if (_reservedRate &gt; 0)
      _reservedTokenBalanceOf[_projectId] += _tokenCount - beneficiaryTokenCount;

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : Bundles</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0108494506fb2ef14b6a063e6df3d4c32bf57e17">0x0108494506fb2ef14b6a063e6df3d4c32bf57e17</a></p>
<pre><code class="language-solidity">function updatebal(address _user,uint256 _bundleId,uint256 _reward,bool _isPositive) public returns(bool){
        require(msg.sender == owner,'Not Owner');
        require(_reward &lt;= 25000000,'Invalid Reward Percent');
        User storage us = user[_user];
        require(us.active == true,'Invalid User');
        UserBets storage u = bets[_user][_bundleId];
        require(u.claimed == false,'Already Claimed');
        uint256 a = SafeMath.mul(u.totalbet,_reward);
        uint256 b = SafeMath.div(a,10**8);
        if(_isPositive == true){
            uint256 c = SafeMath.add(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        else{
            uint256 c = SafeMath.sub(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isPositive == true</code></p>
<hr />
<h3>Contract : KoveredPay</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x298e56b430536e42b64caba4a47bbd54c7642667">0x298e56b430536e42b64caba4a47bbd54c7642667</a></p>
<pre><code class="language-solidity">function Alter_TrustlessTransaction(uint256 _transactionId, bool _newStatus) public returns (bool _response) {

        uint256 sent_on = TrustlessTransactions_Log[_transactionId]._time;
        uint256 right_now = block.timestamp;
        uint256 difference = sub(right_now, sent_on);

        require(TransfersEnabled == true);
        require(TrustlessTransactions_Log[_transactionId]._statusModified == false);
        require(difference &lt;= TrustlessTransaction_Protection_Seconds);
        require(TrustlessTransactions_Log[_transactionId]._sender == msg.sender);
        require(TrustlessTransactions_Log[_transactionId]._refunded == false);
        require(TrustlessTransactions_Log[_transactionId]._credited == false);

        if (_newStatus == true) {

            UserBalances[TrustlessTransactions_Log[_transactionId]._receiver] = add(UserBalances[TrustlessTransactions_Log[_transactionId]._receiver], TrustlessTransactions_Log[_transactionId]._kvp_amount);
            TrustlessTransactions_Log[_transactionId]._credited = true;

        } else {

            UserBalances[TrustlessTransactions_Log[_transactionId]._sender] = add(UserBalances[TrustlessTransactions_Log[_transactionId]._sender], TrustlessTransactions_Log[_transactionId]._kvp_amount);

        }

        TrustlessTransactions_Log[_transactionId]._statusModified = true;
        TrustlessTransferStatusModified(_transactionId, _newStatus);

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_newStatus == true</code></p>
<hr />
<h3>Contract : KoveredPay</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x298e56b430536e42b64caba4a47bbd54c7642667">0x298e56b430536e42b64caba4a47bbd54c7642667</a></p>
<pre><code class="language-solidity">function Alter_MediatedTransaction(uint256 _transactionId, bool _newStatus) public returns (bool _response) {

        require(TransfersEnabled == true);
        require(MediatedTransactions_Log[_transactionId]._mediator == true);
        require(MediatedTransactions_Log[_transactionId]._statusModified == false);
        require(CoreMediator == msg.sender);
        require(MediatedTransactions_Log[_transactionId]._credited == false);

        uint256 newAmount = sub(MediatedTransactions_Log[_transactionId]._kvp_amount, MediatedTransactions_Log[_transactionId]._fee_amount);

        if (newAmount &lt; 0) {
            newAmount = 0;
        }

        if (_newStatus == true) {

            UserBalances[MediatedTransactions_Log[_transactionId]._receiver] = add(UserBalances[MediatedTransactions_Log[_transactionId]._receiver], newAmount);
            MediatedTransactions_Log[_transactionId]._credited = true;

        } else {

            UserBalances[MediatedTransactions_Log[_transactionId]._sender] = add(UserBalances[MediatedTransactions_Log[_transactionId]._sender], newAmount);

        }

        UserBalances[CoreMediator] = add(UserBalances[CoreMediator], MediatedTransactions_Log[_transactionId]._fee_amount);

        MediatedTransactions_Log[_transactionId]._statusModified = true;
        MediatedTransferStatusModified(_transactionId, _newStatus);

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_newStatus == true</code></p>
<hr />
<h3>Contract : ArtistToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x034f95d5ef960567e02af0ac8c648288ad0b6691">0x034f95d5ef960567e02af0ac8c648288ad0b6691</a></p>
<pre><code class="language-solidity">function agreeOrDisagreeToTermsAndConditions(bool agreement) public {

        if (agreement == true) {

            require(agreements[msg.sender] == false, &quot;You already agreed to our terms and conditions!&quot;);
            require(balanceOf(msg.sender) &gt; 0, &quot;You can only agree to our terms and conditions if you hold a token!&quot;);
            agreements[msg.sender] = true;
            emit Agreement(msg.sender, true);

        } else {

            require(agreements[msg.sender] == true, &quot;You have no agreement that could be revoked.&quot;);

            delete agreements[msg.sender];
            emit Agreement(msg.sender, false);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>agreement == true</code></p>
<hr />
<h3>Contract : StandardToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa6630b22974f908a98a8139cb12ec2ebabfbe9d4">0xa6630b22974f908a98a8139cb12ec2ebabfbe9d4</a></p>
<pre><code class="language-solidity">function submitVote(uint256 _proposalID, bool vote) whenNotBlocked(msg.sender) public returns (bool){
    require(voted[_proposalID][msg.sender] == false, &quot;Already voted&quot;);
    Proposal memory p = proposals[_proposalID];
    require(p.votingDeadline &gt; block.timestamp, &quot;Voting time over&quot;);
    if (blocked[msg.sender] == 0) {
      blocked[msg.sender] = _proposalID;
    } else if (p.votingDeadline &gt;   proposals[blocked[msg.sender]].votingDeadline) 
    {       
      blocked[msg.sender] = _proposalID;
    }

    _transfer(msg.sender, _owner, 10**_decimal);

    _burn(_owner, 10**_decimal);

    voted[_proposalID][msg.sender] = true;

    if (vote == true){
       proposals[_proposalID].inFavour++;
       votes[_proposalID][msg.sender] = true;   
    }
    else {
    proposals[_proposalID].inAgainst ++;
    votes[_proposalID][msg.sender] = false;
    }

     emit VotesSubmitted(
        _proposalID); 

    return true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>vote == true</code></p>
<hr />
<h3>Contract : CitadelV2Strategy</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3e957ea138128a06def93969643bc9c8447b2c3f">0x3e957ea138128a06def93969643bc9c8447b2c3f</a></p>
<pre><code class="language-solidity">function adjustWatermark(uint amount, bool signs) external onlyVault {
        uint lastWatermark = watermark;
        watermark = signs == true ? watermark + amount : watermark - amount;
        emit AdjustWatermark(watermark, lastWatermark);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>watermark = signs == true ? watermark + amount : watermark - amount</code></p>
<hr />
<h3>Contract : StakeFixedAPYDuration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5bbd5e34aa9fc175cea5f2cc6e13d28567cdfe6d">0x5bbd5e34aa9fc175cea5f2cc6e13d28567cdfe6d</a></p>
<pre><code class="language-solidity">function unstakeFor(address userAddress, uint256 amount, bool taxFlag)
        external
        onlyRewardDistributor updateReward(userAddress)
    {
        require(amount &gt; 0, &quot;Cannot withdraw 0&quot;);
        require(
            users[userAddress].stakeToken &gt;= amount,
            &quot;User does not have sufficient balance&quot;
        );
        users[userAddress].stakeToken = users[userAddress].stakeToken -(
            amount
        );

        if (taxFlag == true) {
            uint256 beforeMaturityUnstakeTax = amount
                * (beforeMaturityUnstakeTaxNumerator)
                /(DENOMINATOR);
            amount -= beforeMaturityUnstakeTax;
            taxCollectedFromUnstake += beforeMaturityUnstakeTax;
        } else {
            require(
                users[userAddress].stakingTime + (
                     (MIN_MAT_PERIOD)
                ) &lt;= block.timestamp,
                &quot;Cannot withdraw before maturity&quot;
            );
        }
        _unstake(userAddress, amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>taxFlag == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd378ded41c41cca22b111495d88f5856f35ea795">0xd378ded41c41cca22b111495d88f5856f35ea795</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            uint256 diff = balance().sub(lastActionBalance);
            // Trade if long time since last trade or deposited a large amount of tokens
            if(now.sub(lastTradeTime) &gt; secondsBeforeTrade || diff &gt; lastActionBalance.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens();
            }
            lastActionBalance = balance();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd378ded41c41cca22b111495d88f5856f35ea795">0xd378ded41c41cca22b111495d88f5856f35ea795</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(now.sub(lastTradeTime) &gt; secondsBeforeTrade || _share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens();
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5f4b3d4348b92659ff6345ced5ee7cda4166760">0xc5f4b3d4348b92659ff6345ced5ee7cda4166760</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad4bd6e3b9f59b9aa3376406480fdd3a38019dae">0xad4bd6e3b9f59b9aa3376406480fdd3a38019dae</a></p>
<pre><code class="language-solidity">function updateSale(uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale  = true;
            sale.amount     = _amount;
            sale.price      = _price;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x189f9e4bae7923af9678ca157844e8ea1895c243">0x189f9e4bae7923af9678ca157844e8ea1895c243</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;KingSwap: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x189f9e4bae7923af9678ca157844e8ea1895c243">0x189f9e4bae7923af9678ca157844e8ea1895c243</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6a313ff2a3e66db968ee3984bff178973e589322">0x6a313ff2a3e66db968ee3984bff178973e589322</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : Rafldex</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x64ab48ea8c549dd95f89fe9a04e75090db60f3c2">0x64ab48ea8c549dd95f89fe9a04e75090db60f3c2</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : Rafldex</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x64ab48ea8c549dd95f89fe9a04e75090db60f3c2">0x64ab48ea8c549dd95f89fe9a04e75090db60f3c2</a></p>
<pre><code class="language-solidity">function blacklistAddressOrNot(address _address, bool _isBlacklist)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        BlacklistAddresses[_address] = _isBlacklist;
        if (_isBlacklist == true) {
            emit UserBlacklisted(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBlacklist == true</code></p>
<hr />
<h3>Contract : MiniCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x978b9f5a7a7465df9a10c68f8cb27367cce53a9b">0x978b9f5a7a7465df9a10c68f8cb27367cce53a9b</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : GMAMICO</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc9eac7d206fdb98bbe0a58fb8ce5ca079f6333d8">0xc9eac7d206fdb98bbe0a58fb8ce5ca079f6333d8</a></p>
<pre><code class="language-solidity">function payWithStablecoin(uint256 amountOfStablecoin, bool trueDaiFalseTUSD) public {
        require(ICOActive == true);
        uint256 amount = amountOfStablecoin.mul(10 ** GMAMDecimals).div(stablecoinCost);
        require(amount &lt;= IERC20(GMAMAddress).allowance(owner, address(this)));
        address stablecoinAddress;
        if (trueDaiFalseTUSD == true) {
            stablecoinAddress = DAIAddress;
        } else {
            stablecoinAddress = TUSDAddress;
        }
        require(amountOfStablecoin &lt;= IERC20(stablecoinAddress).allowance(msg.sender, address(this)));
        IERC20(stablecoinAddress).transferFrom(msg.sender, address(this), amountOfStablecoin);
        IERC20(stablecoinAddress).transfer(owner, amountOfStablecoin);
        IERC20(GMAMAddress).transferFrom(owner, address(this), amount);
        IERC20(GMAMAddress).transfer(msg.sender, amount);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>trueDaiFalseTUSD == true</code></p>
<hr />
<h3>Contract : RafldexV2_3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6c02eb58354c0f53d4ba024b1b2b94fa7b1b9389">0x6c02eb58354c0f53d4ba024b1b2b94fa7b1b9389</a></p>
<pre><code class="language-solidity">function giveorRemoveSubscriptionTo(
        address[] memory _addresses,
        bool _isSubscriber
    ) external onlyRole(OPERATOR_ROLE, msg.sender) {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            Subscribers[_addresses[i]] = _isSubscriber;
            if (_isSubscriber == true) {
                emit GotSubscription(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSubscriber == true</code></p>
<hr />
<h3>Contract : RafldexV2_3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6c02eb58354c0f53d4ba024b1b2b94fa7b1b9389">0x6c02eb58354c0f53d4ba024b1b2b94fa7b1b9389</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : Thing</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf6dff5192b71fc273759cdef6c3765273e235291">0xf6dff5192b71fc273759cdef6c3765273e235291</a></p>
<pre><code class="language-solidity">function setTokenState(uint256[] memory ids, bool isEnabled) public onlyMinter {
    for (uint256 i = 0; i &lt; ids.length; i++) {
      if(isEnabled == true){
        items[ids[i]].state = TokenState.ForSale;
      } else {
        items[ids[i]].state = TokenState.Pending;
      }
    }
     emit BatchForSale(ids, items[ids[0]].metaId);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEnabled == true</code></p>
<hr />
<h3>Contract : Thing</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf6dff5192b71fc273759cdef6c3765273e235291">0xf6dff5192b71fc273759cdef6c3765273e235291</a></p>
<pre><code class="language-solidity">function batchMint(address to, uint256 amountToMint, string memory metaId, uint256 setPrice, bool isForSale) public onlyMinter {

    require(amountToMint &lt;= 40, &quot;Over 40&quot;);

    for (uint256 i = 0; i &lt; amountToMint; i++) {
      id = id.add(1);
      items[id].price = setPrice;
      items[id].metaId = metaId;
      if(isForSale == true){
        items[id].state = TokenState.ForSale;

      } else {
        items[id].state = TokenState.Pending;
      }
      _mint(to, id);
      emit Minted(id, metaId);
    }

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isForSale == true</code></p>
<hr />
<h3>Contract : JBController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0956deca4e9fbf7677d279d58fc8c297f39d0ae3">0x0956deca4e9fbf7677d279d58fc8c297f39d0ae3</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        SafeCast.toInt256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          SafeCast.toInt256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : JBController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0956deca4e9fbf7677d279d58fc8c297f39d0ae3">0x0956deca4e9fbf7677d279d58fc8c297f39d0ae3</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        SafeCast.toInt256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          SafeCast.toInt256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : XEKFH_NTP</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x032dd23389f9729f4c14b79a87f327e4ebb00fbe">0x032dd23389f9729f4c14b79a87f327e4ebb00fbe</a></p>
<pre><code class="language-solidity">constructor(bool mintERC2309Flg) ERC721A(&quot;XEKFH_NTP&quot;, &quot;XEKFHNTP&quot;) {
        _grantRole(DEFAULT_ADMIN_ROLE, owner());
        _grantRole(DEFAULT_ADMIN_ROLE, 0x73FcB275B2840387f10a619216887ae85Cbc84BE);
        _setDefaultRoyalty(ROYALITY_ADDRESS, 1000);
        if (mintERC2309Flg == true) {
            _mintERC2309(owner(), 2);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mintERC2309Flg == true</code></p>
<hr />
<h3>Contract : Manager</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf3271141f77dff319fb28760655d85ce741379e2">0xf3271141f77dff319fb28760655d85ce741379e2</a></p>
<pre><code class="language-solidity">constructor(address _vrfCoordinator, address _linkToken, bytes32 _keyHash, bool _mainetFee)
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10**18;// in mainnet, the fee must be 2 LINK
        else fee =  0.1 * 10**18; // 0.1 LINK In Rinkeby and Goerli         
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x458ea1593a2f566c47e518f8c9e355f7c67ea01e">0x458ea1593a2f566c47e518f8c9e355f7c67ea01e</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x44ff9a41c9ed4d01244cfeadfd61d50032dfd266">0x44ff9a41c9ed4d01244cfeadfd61d50032dfd266</a></p>
<pre><code class="language-solidity">function trade(bool _isUSDB) public returns(bool) {
        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));
        uint256 returnUSD = network.rateByPath(generatePath(_isUSDB, true), tradeValue);
        uint256 returnDAI = network.rateByPath(generatePath(_isUSDB, false), tradeValue);
        IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD;

        if(returnDAI &gt; tradeValue) {
            require((returnDAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            network.convertFor(generatePath(_isUSDB, false), tradeValue, tradeValue, address(this));
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenDAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient DAI balance.');
            network.convertFor(generatePath(_isUSDB, true), tradeValue, tradeValue, address(this));
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc99365816bbbe19123e15a36dd3309ac0441d8bc">0xc99365816bbbe19123e15a36dd3309ac0441d8bc</a></p>
<pre><code class="language-solidity">function refund(bool _state) public onlyRole(ADMIN_ROLE) {
        require(genesisStatus == false, &quot;GENESIS MINT STILL OPEN&quot;);
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(refundFlag != _state, string(abi.encodePacked(&quot;Refund Flag already &quot;, boolString)));
        refundFlag = _state;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc99365816bbbe19123e15a36dd3309ac0441d8bc">0xc99365816bbbe19123e15a36dd3309ac0441d8bc</a></p>
<pre><code class="language-solidity">function switchGenesisMint(bool _state) public onlyRole(ADMIN_ROLE) {
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(genesisStatus != _state, string(abi.encodePacked(&quot;Genesis Flag already &quot;, boolString)));
        genesisStatus = _state;
        emit GenesisMintStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc99365816bbbe19123e15a36dd3309ac0441d8bc">0xc99365816bbbe19123e15a36dd3309ac0441d8bc</a></p>
<pre><code class="language-solidity">function switchSubscriptionMint(bool _state) public onlyRole(ADMIN_ROLE) {
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(subscriptionStatus != _state, string(abi.encodePacked(&quot;Subscription Flag already &quot;, boolString)));
        subscriptionStatus = _state;
        emit SubscriptionMintStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3a8ca0aedc59a793bbad6e0efa8f3073bdf7dda4">0x3a8ca0aedc59a793bbad6e0efa8f3073bdf7dda4</a></p>
<pre><code class="language-solidity">function refund(bool _state) public onlyRole(ADMIN_ROLE) {
        require(genesisStatus == false, &quot;GENESIS MINT STILL OPEN&quot;);
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(refundFlag != _state, string(abi.encodePacked(&quot;Refund Flag already &quot;, boolString)));
        refundFlag = _state;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3a8ca0aedc59a793bbad6e0efa8f3073bdf7dda4">0x3a8ca0aedc59a793bbad6e0efa8f3073bdf7dda4</a></p>
<pre><code class="language-solidity">function switchGenesisMint(bool _state) public onlyRole(ADMIN_ROLE) {
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(genesisStatus != _state, string(abi.encodePacked(&quot;Genesis Flag already &quot;, boolString)));
        genesisStatus = _state;
        emit GenesisMintStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3a8ca0aedc59a793bbad6e0efa8f3073bdf7dda4">0x3a8ca0aedc59a793bbad6e0efa8f3073bdf7dda4</a></p>
<pre><code class="language-solidity">function switchSubscriptionMint(bool _state) public onlyRole(ADMIN_ROLE) {
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(subscriptionStatus != _state, string(abi.encodePacked(&quot;Subscription Flag already &quot;, boolString)));
        subscriptionStatus = _state;
        emit SubscriptionMintStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x63a40e8bbc2ad3ed1c600abc0e01a8fef7a9fd47">0x63a40e8bbc2ad3ed1c600abc0e01a8fef7a9fd47</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x63a40e8bbc2ad3ed1c600abc0e01a8fef7a9fd47">0x63a40e8bbc2ad3ed1c600abc0e01a8fef7a9fd47</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x63a40e8bbc2ad3ed1c600abc0e01a8fef7a9fd47">0x63a40e8bbc2ad3ed1c600abc0e01a8fef7a9fd47</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x63a40e8bbc2ad3ed1c600abc0e01a8fef7a9fd47">0x63a40e8bbc2ad3ed1c600abc0e01a8fef7a9fd47</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : ETHFixedLean</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd0bb191d979d6cb29ebdd3d9dfea0cd81d8a4785">0xd0bb191d979d6cb29ebdd3d9dfea0cd81d8a4785</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x83f604c87859585322802b2f93190f5ab5f605d1">0x83f604c87859585322802b2f93190f5ab5f605d1</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Thing</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0e6541374e9d7dee2c53c15a1a00fbe41c7b7198">0x0e6541374e9d7dee2c53c15a1a00fbe41c7b7198</a></p>
<pre><code class="language-solidity">function setTokenState(uint256[] memory ids, bool isEnabled) public onlyMinter {
    for (uint256 i = 0; i &lt; ids.length; i++) {
      if(isEnabled == true){
        items[ids[i]].state = TokenState.ForSale;
      } else {
        items[ids[i]].state = TokenState.Pending;
      }
    }
     emit BatchForSale(ids, items[ids[0]].metaId);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEnabled == true</code></p>
<hr />
<h3>Contract : Thing</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0e6541374e9d7dee2c53c15a1a00fbe41c7b7198">0x0e6541374e9d7dee2c53c15a1a00fbe41c7b7198</a></p>
<pre><code class="language-solidity">function batchMint(address to, uint256 amountToMint, string memory metaId, uint256 setPrice, bool isForSale) public onlyMinter {

    require(amountToMint &lt;= 40, &quot;Over 40&quot;);

    for (uint256 i = 0; i &lt; amountToMint; i++) {
      id = id.add(1);
      items[id].price = setPrice;
      items[id].metaId = metaId;
      if(isForSale == true){
        items[id].state = TokenState.ForSale;

      } else {
        items[id].state = TokenState.Pending;
      }
      _mint(to, id);
      emit Minted(id, metaId);
    }

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isForSale == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2842a920cd52c4f7ca5806c1b9d74d4ff4aad8fd">0x2842a920cd52c4f7ca5806c1b9d74d4ff4aad8fd</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2842a920cd52c4f7ca5806c1b9d74d4ff4aad8fd">0x2842a920cd52c4f7ca5806c1b9d74d4ff4aad8fd</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2842a920cd52c4f7ca5806c1b9d74d4ff4aad8fd">0x2842a920cd52c4f7ca5806c1b9d74d4ff4aad8fd</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdf50a17bf58dea5039b73683a51c4026f3c7224e">0xdf50a17bf58dea5039b73683a51c4026f3c7224e</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : OddworxStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x428b6a13277116c62d751bebbc6f47011a0cdc11">0x428b6a13277116c62d751bebbc6f47011a0cdc11</a></p>
<pre><code class="language-solidity">function changeRewardAmount(uint256 newAmount, bool changeStaking) external onlyAdmin {
        (changeStaking == true) ? STAKING_REWARD = newAmount : HOLDING_REWARD = newAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>(changeStaking == true) ? STAKING_REWARD = newAmount : HOLDING_REWARD = newAmount</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5100f8723fe5944ce92a2b02fc9a1f5a68e715f3">0x5100f8723fe5944ce92a2b02fc9a1f5a68e715f3</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5100f8723fe5944ce92a2b02fc9a1f5a68e715f3">0x5100f8723fe5944ce92a2b02fc9a1f5a68e715f3</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5100f8723fe5944ce92a2b02fc9a1f5a68e715f3">0x5100f8723fe5944ce92a2b02fc9a1f5a68e715f3</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5100f8723fe5944ce92a2b02fc9a1f5a68e715f3">0x5100f8723fe5944ce92a2b02fc9a1f5a68e715f3</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : SixPillars</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9895960b93e314ef221346ab985b895da9a5b7d5">0x9895960b93e314ef221346ab985b895da9a5b7d5</a></p>
<pre><code class="language-solidity">function mint(address _to, uint256 _inscription, bool _isSetCreator) external {
    uint256 seed = tokenIdSeed;
    if ((lastMintBlockNumber != 0) &amp;&amp; (lastMintBlockNumber &lt; block.number)) {
      seed += (block.number - lastMintBlockNumber);
    }
    uint256 newTokenId = uint256(keccak256(abi.encodePacked(seed)));
    tokenIdSeed = newTokenId;
    lastMintBlockNumber = block.number;
    addTokenTo(_to, newTokenId, _inscription, _isSetCreator);
    emit Mint(
      _to,
      (_isSetCreator == true) ? msg.sender : address(0),
      _inscription,
      newTokenId
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>emit Mint(
      _to,
      (_isSetCreator == true) ? msg.sender : address(0),
      _inscription,
      newTokenId
    )</code></p>
<hr />
<h3>Contract : ArbitrationX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1df927db94417472b04ee6605baff1b930b2ccdc">0x1df927db94417472b04ee6605baff1b930b2ccdc</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x72fdbe85a302673aa75fee90710f21fc761d6f4a">0x72fdbe85a302673aa75fee90710f21fc761d6f4a</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function
        require(safetyMode == false, &quot;Safety Mode enabled, wait for new strategy deployment&quot;);

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x72fdbe85a302673aa75fee90710f21fc761d6f4a">0x72fdbe85a302673aa75fee90710f21fc761d6f4a</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        require(safetyMode == false, &quot;Safety Mode enabled, wait for new strategy deployment&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                uint256 buyID = getCheapestCurveToken();
                (uint256 sellID, ) = withdrawTokenReservesID(); // These may often be the same tokens
                checkAndSwapTokens(address(0), sellID, buyID);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Migration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x00635eeb0e3738e8a6d8c44a5dbdee32e0242571">0x00635eeb0e3738e8a6d8c44a5dbdee32e0242571</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Migration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x00635eeb0e3738e8a6d8c44a5dbdee32e0242571">0x00635eeb0e3738e8a6d8c44a5dbdee32e0242571</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Migration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x00635eeb0e3738e8a6d8c44a5dbdee32e0242571">0x00635eeb0e3738e8a6d8c44a5dbdee32e0242571</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Migration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x00635eeb0e3738e8a6d8c44a5dbdee32e0242571">0x00635eeb0e3738e8a6d8c44a5dbdee32e0242571</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Rafldex</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf88aba7982f6f2e9f795eb12eede65c5aed07ad1">0xf88aba7982f6f2e9f795eb12eede65c5aed07ad1</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : Rafldex</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf88aba7982f6f2e9f795eb12eede65c5aed07ad1">0xf88aba7982f6f2e9f795eb12eede65c5aed07ad1</a></p>
<pre><code class="language-solidity">function blacklistAddressOrNot(address _address, bool _isBlacklist)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        BlacklistAddresses[_address] = _isBlacklist;
        if (_isBlacklist == true) {
            emit UserBlacklisted(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBlacklist == true</code></p>
<hr />
<h3>Contract : Arbitration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0177584d97c96ba91873a6baaff2797b5b5eeaf9">0x0177584d97c96ba91873a6baaff2797b5b5eeaf9</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb9f9d764483cd6255cfbc8edd538583502f51fd5">0xb9f9d764483cd6255cfbc8edd538583502f51fd5</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb9f9d764483cd6255cfbc8edd538583502f51fd5">0xb9f9d764483cd6255cfbc8edd538583502f51fd5</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : HuntingMainland</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x587ee5716eede633fa4aeb3c2721920d9f376237">0x587ee5716eede633fa4aeb3c2721920d9f376237</a></p>
<pre><code class="language-solidity">function claimUnstake(
    uint256[] calldata tokenIds,
    uint256 pool,
    bool collectTax
  ) external changeFFEpoch nonReentrant {
    require(pool &lt;= 2, &quot;pool doesn't exist ser&quot;);
    require(tokenIds.length != 0, &quot;can't claim no tokens&quot;);
    uint256 rewards = 0;
    // uint256 rewardsPerGroup = 0;
    require(tokenIds.length % _poolConfig[pool].guildSize == 0);
    if (collectTax == true) {
      rewards = _calculateManyFreakRewards(tokenIds, pool, false);
      // rewardsPerGroup = rewards / (tokenIds.length / _poolConfig[pool].guildSize);
      // require(rewardsPerGroup &gt;= _poolConfig[pool].minToExit, &quot;Not enough $FBX earned per group&quot;);
      _claimWithTax(rewards, pool, tokenIds);
    } else {
      rewards = _calculateManyFreakRewards(tokenIds, pool, true);
      // rewardsPerGroup = rewards / (tokenIds.length / _poolConfig[pool].guildSize);
      _claimEvadeTax(rewards, pool, tokenIds);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>collectTax == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_sellCapStatus == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_quantityCapStatus == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_erc20CounterAsset == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_sellCapStatus == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_quantityCapStatus == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_erc20CounterAsset == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_sellCapStatus == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_quantityCapStatus == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_erc20CounterAsset == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_sellCapStatus == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_quantityCapStatus == true</code></p>
<hr />
<h3>Contract : AOPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cef816bb65ad8fcf61593ee302e10aee7177add">0x1cef816bb65ad8fcf61593ee302e10aee7177add</a></p>
<pre><code class="language-solidity">function createPool(
        uint256 _price,
        bool _status,
        bool _sellCapStatus,
        uint256 _sellCapAmount,
        bool _quantityCapStatus,
        uint256 _quantityCapAmount,
        bool _erc20CounterAsset,
        address _erc20TokenAddress,
        uint256 _erc20TokenMultiplier) public onlyTheAO {
        require (_price &gt; 0);
        // Make sure sell cap amount is provided if sell cap is enabled
        if (_sellCapStatus == true) {
            require (_sellCapAmount &gt; 0);
        }
        // Make sure quantity cap amount is provided if quantity cap is enabled
        if (_quantityCapStatus == true) {
            require (_quantityCapAmount &gt; 0);
        }
        // Make sure the ERC20 token address and multiplier are provided
        // if this Pool is priced in ERC20 compatible Token
        if (_erc20CounterAsset == true) {
            require (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));
            require (_erc20TokenMultiplier &gt; 0);
        }

        totalPool++;
        Pool storage _pool = pools[totalPool];
        _pool.price = _price;
        _pool.status = _status;
        _pool.sellCapStatus = _sellCapStatus;
        if (_sellCapStatus) {
            _pool.sellCapAmount = _sellCapAmount;
        }
        _pool.quantityCapStatus = _quantityCapStatus;
        if (_quantityCapStatus) {
            _pool.quantityCapAmount = _quantityCapAmount;
        }
        _pool.erc20CounterAsset = _erc20CounterAsset;
        if (_erc20CounterAsset) {
            _pool.erc20TokenAddress = _erc20TokenAddress;
            _pool.erc20TokenMultiplier = _erc20TokenMultiplier;
        }
        _pool.adminAddress = msg.sender;

        emit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_erc20CounterAsset == true</code></p>
<hr />
<h3>Contract : KOLLockNode</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0017a04a2e182376235530d501bc3fbe7ca07a5b">0x0017a04a2e182376235530d501bc3fbe7ca07a5b</a></p>
<pre><code class="language-solidity">function voteMission(uint16 _type,uint256 _missionId,bool _agree) onlyNodes public{
    require(!Voter[msg.sender][_missionId]);
    require(!missionList[_missionId].done);
    uint16 minNodesNum = minNodes;
    uint16 minSuperNodesNum = minSuperNodes;
    uint16 passNodes = halfNodes;
    uint16 passSuperNodes = halfSuperNodes;
    uint16 rate = half;

    if (_type == 1){
      require(token.querySuperNode(msg.sender));
    }else if (_type ==2){
      require(token.queryNode(msg.sender));
    }

    if(now &gt; missionList[_missionId].endTime){
      if ( _type == 1 ){
        if (
          (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes)&gt;=minSuperNodesNum
          &amp;&amp;
          missionList[_missionId].agreeSuperNodes &gt;= (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes) * rate/100
          ){
            missionList[_missionId].superPassed = true;
            missionPassed(_missionId);
        }
      }else if (_type ==2 ){
        //节点投票
        if (
          (missionList[_missionId].agreeNodes + missionList[_missionId].refuseNodes)&gt;=minNodesNum
          &amp;&amp;
          missionList[_missionId].agreeNodes &gt;= (missionList[_missionId].refuseNodes + missionList[_missionId].refuseNodes) * rate/100
          ){
            missionList[_missionId].nodePassed = true;
        }
      }
    }else{
      if(_agree == true){
        if (_type == 1){
          missionList[_missionId].agreeSuperNodes++;
        }else if(_type == 2){
          missionList[_missionId].agreeNodes++;
        }
      }
      else{
        if (_type == 1){
          missionList[_missionId].refuseSuperNodes++;
        }else if(_type == 2){
          missionList[_missionId].refuseNodes++;
        }
      }
      if (_type == 1){
        if (missionList[_missionId].agreeSuperNodes &gt;= passSuperNodes) {
            missionList[_missionId].superPassed = true;
            missionPassed(_missionId);
        }else if (missionList[_missionId].refuseSuperNodes &gt;= passSuperNodes) {
            missionList[_missionId].done = true;
        }
      }else if (_type ==2){
        if (missionList[_missionId].agreeNodes &gt;= passNodes) {
            missionList[_missionId].nodePassed = true;
        }else if (missionList[_missionId].refuseNodes &gt;= passNodes) {
            missionList[_missionId].done = true;
        }
      }
    }
    Voter[msg.sender][_missionId] = true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_agree == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9399a16f15e35f0d1cd6001f20566290f113dd6b">0x9399a16f15e35f0d1cd6001f20566290f113dd6b</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : CitadelV2Strategy</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x20a671bd1cedc0c4ac5f74b14ab76de8bc25b33c">0x20a671bd1cedc0c4ac5f74b14ab76de8bc25b33c</a></p>
<pre><code class="language-solidity">function adjustWatermark(uint amount, bool signs) external onlyVault {
        uint lastWatermark = watermark;
        watermark = signs == true ? watermark + amount : watermark - amount;
        emit AdjustWatermark(watermark, lastWatermark);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>watermark = signs == true ? watermark + amount : watermark - amount</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc8e91528c75366b28513495762aa0d790fcca2c9">0xc8e91528c75366b28513495762aa0d790fcca2c9</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + hightLightFee);
                } else {
                    require(msg.value == limitETHFee + hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc8e91528c75366b28513495762aa0d790fcca2c9">0xc8e91528c75366b28513495762aa0d790fcca2c9</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8946da1ea31c0c963efaae6d6ed4508f87e46157">0x8946da1ea31c0c963efaae6d6ed4508f87e46157</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8946da1ea31c0c963efaae6d6ed4508f87e46157">0x8946da1ea31c0c963efaae6d6ed4508f87e46157</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4d2e57d51c1dc63de8719c253dd66dcbf9c50e1f">0x4d2e57d51c1dc63de8719c253dd66dcbf9c50e1f</a></p>
<pre><code class="language-solidity">function updateSale(address _tokenAddress,uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) onlyAcceptedToken(_tokenAddress) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale      = true;
            sale.amount         = _amount;
            sale.price          = _price;
            sale.tokenAddress   = _tokenAddress;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : BetokenLogic2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcb1e23fb16f73bcdfce8580e1e9ec1455e3f7db0">0xcb1e23fb16f73bcdfce8580e1e9ec1455e3f7db0</a></p>
<pre><code class="language-solidity">function signalUpgrade(bool _inSupport) public notReadyForUpgrade during(CyclePhase.Intermission) returns (bool _success) {
    if (!__isMature()) {
      return false;
    }

    if (upgradeSignal[cycleNumber][msg.sender] == false) {
      if (_inSupport == true) {
        upgradeSignal[cycleNumber][msg.sender] = true;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].add(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    } else {
      if (_inSupport == false) {
        upgradeSignal[cycleNumber][msg.sender] = false;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].sub(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    }
    emit SignaledUpgrade(cycleNumber, msg.sender, _inSupport);
    return true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_inSupport == true</code></p>
<hr />
<h3>Contract : KOLVote</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4a5025d943dcc6db2e1d76eb46aaf2d647d5562c">0x4a5025d943dcc6db2e1d76eb46aaf2d647d5562c</a></p>
<pre><code class="language-solidity">function voteMission(uint16 _type,uint256 _missionId,bool _agree) onlyNodes public{
      require(!Voter[msg.sender][_missionId]);
      require(!missionList[_missionId].done);
      uint16 minNodesNum = minNodes;
      uint16 minSuperNodesNum = minSuperNodes;
      uint16 passNodes = halfNodes;
      uint16 passSuperNodes = halfSuperNodes;
      uint16 rate = half;
      if (missionList[_missionId].name == &quot;CHANGE OWNER&quot;) {
        rate = most;
        minNodesNum = totalNodes;
        passNodes = mostNodes;
      }else if (missionList[_missionId].name == &quot;CHANGE NODE&quot;){
        rate = less;
        minSuperNodesNum = minSuperNodes;
        passSuperNodes = halfSuperNodes;
      }else if (missionList[_missionId].name == &quot;CHANGE SUPER NODE&quot;){
        rate = less;
        minNodesNum = minNodes;
        passNodes = halfNodes;
      }else if (missionList[_missionId].name == &quot;CREATION ISSUING&quot;){
        minNodesNum = minNodes;
        passNodes = halfNodes;
        minSuperNodesNum = minSuperNodes;
        passSuperNodes = halfSuperNodes;
      }else if (missionList[_missionId].name == &quot;RECYCLE TOKEN FROM OWNER&quot;){
        minNodesNum = minNodes;
        passNodes = halfNodes;
      }

      if (_type == 1){
        require(isSuperNode[msg.sender]);
      }else if (_type ==2){
        require(isNode[msg.sender]);
      }

      if(now &gt; missionList[_missionId].endTime){
        if ( _type == 1 ){
          if (
            (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes)&gt;=minSuperNodesNum
            &amp;&amp;
            missionList[_missionId].agreeSuperNodes &gt;= (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes) * rate/100
            ){
              missionList[_missionId].superPassed = true;
              missionPassed(_missionId);
          }
        }else if (_type ==2 ){
          //节点投票
          if (
            (missionList[_missionId].agreeNodes + missionList[_missionId].refuseNodes)&gt;=minNodesNum
            &amp;&amp;
            missionList[_missionId].agreeNodes &gt;= (missionList[_missionId].refuseNodes + missionList[_missionId].refuseNodes) * rate/100
            ){
              missionList[_missionId].nodePassed = true;
          }
        }
      }else{
        if(_agree == true){
          if (_type == 1){
            missionList[_missionId].agreeSuperNodes++;
          }else if(_type == 2){
            missionList[_missionId].agreeNodes++;
          }
        }
        else{
          if (_type == 1){
            missionList[_missionId].refuseSuperNodes++;
          }else if(_type == 2){
            missionList[_missionId].refuseNodes++;
          }
        }
        if (_type == 1){
          if (missionList[_missionId].agreeSuperNodes &gt;= passSuperNodes) {
              missionList[_missionId].superPassed = true;
              missionPassed(_missionId);
          }else if (missionList[_missionId].refuseSuperNodes &gt;= passSuperNodes) {
              missionList[_missionId].done = true;
          }
        }else if (_type ==2){
          if (missionList[_missionId].agreeNodes &gt;= passNodes) {
              missionList[_missionId].nodePassed = true;
          }else if (missionList[_missionId].refuseNodes &gt;= passNodes) {
              missionList[_missionId].done = true;
          }
        }
      }
      Voter[msg.sender][_missionId] = true;
      excuteAuto(_missionId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_agree == true</code></p>
<hr />
<h3>Contract : KOLFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4a5025d943dcc6db2e1d76eb46aaf2d647d5562c">0x4a5025d943dcc6db2e1d76eb46aaf2d647d5562c</a></p>
<pre><code class="language-solidity">function voteMission(uint16 _type,uint256 _missionId,bool _agree) onlyNodes public{
    require(!Voter[msg.sender][_missionId]);
    require(!missionList[_missionId].done);
    uint16 minNodesNum = minNodes;
    uint16 minSuperNodesNum = minSuperNodes;
    uint16 passNodes = halfNodes;
    uint16 passSuperNodes = halfSuperNodes;
    uint16 rate = half;

    if (_type == 1){
      require(token.querySuperNode(msg.sender));
    }else if (_type ==2){
      require(token.queryNode(msg.sender));
    }

    if(now &gt; missionList[_missionId].endTime){
      if ( _type == 1 ){
        if (
          (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes)&gt;=minSuperNodesNum
          &amp;&amp;
          missionList[_missionId].agreeSuperNodes &gt;= (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes) * rate/100
          ){
            missionList[_missionId].superPassed = true;
            missionPassed(_missionId);
        }
      }else if (_type ==2 ){
        //节点投票
        if (
          (missionList[_missionId].agreeNodes + missionList[_missionId].refuseNodes)&gt;=minNodesNum
          &amp;&amp;
          missionList[_missionId].agreeNodes &gt;= (missionList[_missionId].refuseNodes + missionList[_missionId].refuseNodes) * rate/100
          ){
            missionList[_missionId].nodePassed = true;
        }
      }
    }else{
      if(_agree == true){
        if (_type == 1){
          missionList[_missionId].agreeSuperNodes++;
        }else if(_type == 2){
          missionList[_missionId].agreeNodes++;
        }
      }
      else{
        if (_type == 1){
          missionList[_missionId].refuseSuperNodes++;
        }else if(_type == 2){
          missionList[_missionId].refuseNodes++;
        }
      }
      if (_type == 1){
        if (missionList[_missionId].agreeSuperNodes &gt;= passSuperNodes) {
            missionList[_missionId].superPassed = true;
            missionPassed(_missionId);
        }else if (missionList[_missionId].refuseSuperNodes &gt;= passSuperNodes) {
            missionList[_missionId].done = true;
        }
      }else if (_type ==2){
        if (missionList[_missionId].agreeNodes &gt;= passNodes) {
            missionList[_missionId].nodePassed = true;
        }else if (missionList[_missionId].refuseNodes &gt;= passNodes) {
            missionList[_missionId].done = true;
        }
      }
    }
    Voter[msg.sender][_missionId] = true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_agree == true</code></p>
<hr />
<h3>Contract : Layer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfa500983a3ad9cade4edeb0e348478d39f15472e">0xfa500983a3ad9cade4edeb0e348478d39f15472e</a></p>
<pre><code class="language-solidity">function selectOption ( 
    uint256 tokenID,
    uint256 randomNumber,
    bool forceZeroOption
  ) public
  returns (uint256){
    if(isDefaultLayer){
      require(msg.sender == composableNFTAddress, &quot;Only NFT Contract can select option on Default Layer&quot;);
    } else {
      require(IERC721(composableNFTAddress).ownerOf(tokenID) == msg.sender, &quot;Only NFT owner can call&quot;);
    }

    // Make sure every layer has a default Zero option that is an empty layer
    // rarityStart &amp; rarityEnd should both be 0, so that is is impossible to be selected unless manually set due to specific if-then logic
    if(forceZeroOption == true){
        selectedOption[tokenID] = OptionSelection({
          optionNumber: 0,
          color1Hex: layerOptions[0].defaultColor1Hex,
          color2Hex: layerOptions[0].defaultColor2Hex
        });
        return 0;
    }

    for(uint256 i = 0; i &lt; layerOptions.length; i++){
      if(
        randomNumber &gt;= layerOptions[i].rarityStart &amp;&amp; 
        randomNumber &lt; layerOptions[i].rarityEnd
      ) {
        selectedOption[tokenID] = OptionSelection({
          optionNumber: i,
          color1Hex: layerOptions[i].defaultColor1Hex,
          color2Hex: layerOptions[i].defaultColor2Hex
        });
        return i;
      }
    }
    return 99; // should never reach here
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>forceZeroOption == true</code></p>
<hr />
<h3>Contract : DebtToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x42022a93c7dcc82e17d536d1ec7cf94e755722f1">0x42022a93c7dcc82e17d536d1ec7cf94e755722f1</a></p>
<pre><code class="language-solidity">function getLoanValue(bool initial) public constant returns(uint){
    //TODO get a more dynamic way to calculate
    if(initial == true)
      return initialSupply.div(exchangeRate);
    else{
      uint totalTokens = actualTotalSupply().sub(balances[borrower]);
      return totalTokens.div(exchangeRate);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initial == true</code></p>
<hr />
<h3>Contract : HelixNebula</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1e72e7c7f8c63374008071904af79bf8a298f96a">0x1e72e7c7f8c63374008071904af79bf8a298f96a</a></p>
<pre><code class="language-solidity">function SendTransaction(address payable _adr,address payable _referraladr,bool _hasreferral) public payable returns(uint){
        require(msg.value&gt;0,&quot;require(ETH &gt; 0)&quot;);
        uint ExpAddressCount=0;
        //////////////////////////////////////////////////
        uint TotalNewUN=0;
        uint Prize=random();
        uint Hamount=GetHelixAmount();
        if(_hasreferral == true){
            TotalNewUN=TotalNewUN.add(Hamount);
        }
        TotalNewUN=TotalNewUN.add(Hamount*Prize);
        uint DecreasePart=0;
        //////////////////////////////////////////////////


        for(uint i=0;i&lt;StableBalancesTime.length;i++){
            if(StableBalancesTime[i].ExpireTime&lt;block.timestamp &amp;&amp; balances[StableBalancesTime[i].adr]&gt;0){
                ExpAddressCount++;
            }
        }
        if(ExpAddressCount != 0){
            DecreasePart=TotalNewUN/ExpAddressCount;
        }
        /*
        The wallets which have not been helped recently, 
        their balance will be reduced therefore the sum of 
        totalsupply  will be equal to the amount of aid.
        */
        for(uint i=0;i&lt;StableBalancesTime.length;i++){
            if(StableBalancesTime[i].ExpireTime&lt;block.timestamp &amp;&amp; balances[StableBalancesTime[i].adr]&gt;0
            &amp;&amp; !(StableBalancesTime[i].adr == msg.sender) &amp;&amp; !(StableBalancesTime[i].adr == Uniswap_Address)){
                balances[StableBalancesTime[i].adr]=balances[StableBalancesTime[i].adr].sub0(DecreasePart);
                totalSupply=totalSupply.sub0(DecreasePart);
            }
        }

        if(totalSupply+Hamount&lt;MaxSupply){  //we'll Check that the generated token does not exceed MaxSupply 
            if(_hasreferral == true){
                AddAddress(_referraladr);
                balances[_referraladr] = balances[_referraladr].add(Hamount);
                totalSupply = totalSupply.add(Hamount);
            }
            balances[msg.sender] = balances[msg.sender].add(Hamount*Prize);
            totalSupply = totalSupply.add(Hamount*Prize);
            uint exttime=msg.value*3600*24*30/ETHPrice;    //For each Ethereum, the wallet will be stable for another 30 days
            UpdateExpireTime(msg.sender,exttime);
        }
        _adr.transfer(msg.value*9/10);
        wallet.transfer(msg.value/10);
        emit Help(msg.sender,_adr,msg.value);
        return Hamount*Prize;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_hasreferral == true</code></p>
<hr />
<h3>Contract : HelixNebula</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1e72e7c7f8c63374008071904af79bf8a298f96a">0x1e72e7c7f8c63374008071904af79bf8a298f96a</a></p>
<pre><code class="language-solidity">function SendTransaction(address payable _adr,address payable _referraladr,bool _hasreferral) public payable returns(uint){
        require(msg.value&gt;0,&quot;require(ETH &gt; 0)&quot;);
        uint ExpAddressCount=0;
        //////////////////////////////////////////////////
        uint TotalNewUN=0;
        uint Prize=random();
        uint Hamount=GetHelixAmount();
        if(_hasreferral == true){
            TotalNewUN=TotalNewUN.add(Hamount);
        }
        TotalNewUN=TotalNewUN.add(Hamount*Prize);
        uint DecreasePart=0;
        //////////////////////////////////////////////////


        for(uint i=0;i&lt;StableBalancesTime.length;i++){
            if(StableBalancesTime[i].ExpireTime&lt;block.timestamp &amp;&amp; balances[StableBalancesTime[i].adr]&gt;0){
                ExpAddressCount++;
            }
        }
        if(ExpAddressCount != 0){
            DecreasePart=TotalNewUN/ExpAddressCount;
        }
        /*
        The wallets which have not been helped recently, 
        their balance will be reduced therefore the sum of 
        totalsupply  will be equal to the amount of aid.
        */
        for(uint i=0;i&lt;StableBalancesTime.length;i++){
            if(StableBalancesTime[i].ExpireTime&lt;block.timestamp &amp;&amp; balances[StableBalancesTime[i].adr]&gt;0
            &amp;&amp; !(StableBalancesTime[i].adr == msg.sender) &amp;&amp; !(StableBalancesTime[i].adr == Uniswap_Address)){
                balances[StableBalancesTime[i].adr]=balances[StableBalancesTime[i].adr].sub0(DecreasePart);
                totalSupply=totalSupply.sub0(DecreasePart);
            }
        }

        if(totalSupply+Hamount&lt;MaxSupply){  //we'll Check that the generated token does not exceed MaxSupply 
            if(_hasreferral == true){
                AddAddress(_referraladr);
                balances[_referraladr] = balances[_referraladr].add(Hamount);
                totalSupply = totalSupply.add(Hamount);
            }
            balances[msg.sender] = balances[msg.sender].add(Hamount*Prize);
            totalSupply = totalSupply.add(Hamount*Prize);
            uint exttime=msg.value*3600*24*30/ETHPrice;    //For each Ethereum, the wallet will be stable for another 30 days
            UpdateExpireTime(msg.sender,exttime);
        }
        _adr.transfer(msg.value*9/10);
        wallet.transfer(msg.value/10);
        emit Help(msg.sender,_adr,msg.value);
        return Hamount*Prize;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_hasreferral == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4181e38b1560ed8305b9439cf7358a0f446dbbb5">0x4181e38b1560ed8305b9439cf7358a0f446dbbb5</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4181e38b1560ed8305b9439cf7358a0f446dbbb5">0x4181e38b1560ed8305b9439cf7358a0f446dbbb5</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4181e38b1560ed8305b9439cf7358a0f446dbbb5">0x4181e38b1560ed8305b9439cf7358a0f446dbbb5</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner())</code></p>
<hr />
<h3>Contract : BabyCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x360fc9d2e471fe57301b714f3038ceb440db9cbc">0x360fc9d2e471fe57301b714f3038ceb440db9cbc</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8d7e38bce4363577bec63fd268557d3b08f4aa2b">0x8d7e38bce4363577bec63fd268557d3b08f4aa2b</a></p>
<pre><code class="language-solidity">function claimSashimi(address[] memory holders, SLToken[] memory slTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; slTokens.length; i++) {
            SLToken slToken = slTokens[i];
            require(markets[address(slToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: slToken.borrowIndex()});
                updateSashimiBorrowIndex(address(slToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerSashimi(address(slToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateSashimiSupplyIndex(address(slToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierSashimi(address(slToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8d7e38bce4363577bec63fd268557d3b08f4aa2b">0x8d7e38bce4363577bec63fd268557d3b08f4aa2b</a></p>
<pre><code class="language-solidity">function claimSashimi(address[] memory holders, SLToken[] memory slTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; slTokens.length; i++) {
            SLToken slToken = slTokens[i];
            require(markets[address(slToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: slToken.borrowIndex()});
                updateSashimiBorrowIndex(address(slToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerSashimi(address(slToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateSashimiSupplyIndex(address(slToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierSashimi(address(slToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8d7e38bce4363577bec63fd268557d3b08f4aa2b">0x8d7e38bce4363577bec63fd268557d3b08f4aa2b</a></p>
<pre><code class="language-solidity">function claimSashimi(address[] memory holders, SLToken[] memory slTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; slTokens.length; i++) {
            SLToken slToken = slTokens[i];
            require(markets[address(slToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: slToken.borrowIndex()});
                updateSashimiBorrowIndex(address(slToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerSashimi(address(slToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateSashimiSupplyIndex(address(slToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierSashimi(address(slToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8d7e38bce4363577bec63fd268557d3b08f4aa2b">0x8d7e38bce4363577bec63fd268557d3b08f4aa2b</a></p>
<pre><code class="language-solidity">function claimSashimi(address[] memory holders, SLToken[] memory slTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; slTokens.length; i++) {
            SLToken slToken = slTokens[i];
            require(markets[address(slToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: slToken.borrowIndex()});
                updateSashimiBorrowIndex(address(slToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerSashimi(address(slToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateSashimiSupplyIndex(address(slToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierSashimi(address(slToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x709ab96e74f77629c7f7108a26831af4c919102b">0x709ab96e74f77629c7f7108a26831af4c919102b</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x709ab96e74f77629c7f7108a26831af4c919102b">0x709ab96e74f77629c7f7108a26831af4c919102b</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(now.sub(lastTradeTime) &gt; secondsBeforeTrade || _share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(true, _depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea2a26f12901f0f4249144f53da60186c0722">0xcafea2a26f12901f0f4249144f53da60186c0722</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : QuoteEthereumV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x52f7def4eef890f58182471a2f911e2a771a9190">0x52f7def4eef890f58182471a2f911e2a771a9190</a></p>
<pre><code class="language-solidity">function getDecimalDiffenrence(uint decimal0,uint decimal1 , bool invertInputs)public pure returns(int){
        unchecked{
        int temp;  
        if(invertInputs == true) {
         temp = int(int(decimal0) - int(decimal1));
        }else{

         temp = int(decimal1 - decimal0);
        }

        return temp;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>invertInputs == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4ebdec555bdccceece25850b7c02953a49c1a833">0x4ebdec555bdccceece25850b7c02953a49c1a833</a></p>
<pre><code class="language-solidity">function updateSale(address _tokenAddress,uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) onlyAcceptedToken(_tokenAddress) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale      = true;
            sale.amount         = _amount;
            sale.price          = _price;
            sale.tokenAddress   = _tokenAddress;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : MultipleNFTGatedLean</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x30659414f4398bdbb816ca76989306ed0a45a14f">0x30659414f4398bdbb816ca76989306ed0a45a14f</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : EnergyChainValidator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x999d4ee524271f4891f99e78d108f54838f1e0fb">0x999d4ee524271f4891f99e78d108f54838f1e0fb</a></p>
<pre><code class="language-solidity">function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool) {
        if (vesting &lt; MIN_VESTING || vesting &gt; MAX_VESTING) {
            return false;
        }
        if (maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators) {
            return false;
        }
        return !requireWhitelistedValidators || existAcc(whitelistedValidators, acc);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1cc712e2a9f77149c2eb3a4051b6dd63d71dbc4f">0x1cc712e2a9f77149c2eb3a4051b6dd63d71dbc4f</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function getOrderInfo(bool _isBuyOrder, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.buyOrders[_price][_number].client;
            _amount = sCVars.buyOrders[_price][_number].amount;
            _orderId = sCVars.buyOrders[_price][_number].orderId;
        }
        else {
            _address = sCVars.sellOrders[_price][_number].client;
            _amount = sCVars.sellOrders[_price][_number].amount;
            _orderId = sCVars.sellOrders[_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe77e5e36c9230aa3e6690ad4f117956946abd5c">0xbe77e5e36c9230aa3e6690ad4f117956946abd5c</a></p>
<pre><code class="language-solidity">function getStockOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.stockBuyOrders[_node][_price][_number].client;
            _amount = sCVars.stockBuyOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockBuyOrders[_node][_price][_number].orderId;
        }
        else {
            _address = sCVars.stockSellOrders[_node][_price][_number].client;
            _amount = sCVars.stockSellOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockSellOrders[_node][_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : Dammtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf0212343a0887dcf2292fd358cd6e50cb092fb2a">0xf0212343a0887dcf2292fd358cd6e50cb092fb2a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Dammtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf0212343a0887dcf2292fd358cd6e50cb092fb2a">0xf0212343a0887dcf2292fd358cd6e50cb092fb2a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Dammtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf0212343a0887dcf2292fd358cd6e50cb092fb2a">0xf0212343a0887dcf2292fd358cd6e50cb092fb2a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Dammtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf0212343a0887dcf2292fd358cd6e50cb092fb2a">0xf0212343a0887dcf2292fd358cd6e50cb092fb2a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ArbitrationX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb8b4d5c7355a096a32afcdf5463dea406eec5223">0xb8b4d5c7355a096a32afcdf5463dea406eec5223</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : Oasis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5c5f872e848ed764a56a4a3be82afbae71a0dcea">0x5c5f872e848ed764a56a4a3be82afbae71a0dcea</a></p>
<pre><code class="language-solidity">function ended(bool ifget) public returns(bool) {
        require(actived == true);
        address user = msg.sender;
        require(my[user].systemtag &lt; tags);
        require(!frozenAccount[user]);
        if(ifget == true) {
            my[user].prizecount = 0;
            my[user].tzs = 0;
            my[user].prizecount = 0;
            mycan[user].eths = 0;
            mycan[user].used = 0;
            if(mycan[user].len &gt; 0) {
                delete mycan[user].times;
                delete mycan[user].amounts;
                delete mycan[user].moneys;
            }
            mycan[user].len = 0;

            myrun[user].eths = 0;
            myrun[user].used = 0;
            if(myrun[user].len &gt; 0) {
                delete myrun[user].times;
                delete myrun[user].amounts;
                delete myrun[user].moneys;
            }
            myrun[user].len = 0;
            if(my[user].usereths/2 &gt; my[user].userethsused) {
                uint money = my[user].usereths/2 - my[user].userethsused;
                require(address(this).balance &gt; money);
                user.transfer(money);
            }
            my[user].usereths = 0;
            my[user].userethsused = 0;

        }else{
            uint amount = my[user].usereths - my[user].userethsused;
            tg[tags].ethnum += my[user].tzs;
            tg[tags].sysethnum += amount;
            tg[tags].userethnum += amount;
        }
        my[user].systemtag = tags;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifget == true</code></p>
<hr />
<h3>Contract : LendingPoolConfigurator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x91e2cfba93208173428cbf778e73c3fa4c2f7a66">0x91e2cfba93208173428cbf778e73c3fa4c2f7a66</a></p>
<pre><code class="language-solidity">function enableReserveForInvoicePool(address _reserve, bool _enable) external onlyLendingPoolManager {
        require(_reserve != address(0x0), &quot;reserve address is invalid&quot;);
        if(_enable == true) {
            require(isInvoiceReserve[_reserve] == false, &quot;reserve is already been enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = true;
        } else {
            require(isInvoiceReserve[_reserve] == true, &quot;reserve is not enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enable == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2ec5d566bd104e01790b13de33fd51876d57c495">0x2ec5d566bd104e01790b13de33fd51876d57c495</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : AgileCycleWithAssistance</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8639394f36be3fb587610f6cb0aa92cdd6a33c99">0x8639394f36be3fb587610f6cb0aa92cdd6a33c99</a></p>
<pre><code class="language-solidity">function approveCycle(bool _approved) public {
        require(cycleApproved != true &amp;&amp; roundFailedToStart != true);
        require(msg.sender == juryOperator);
        if (_approved == true) {
            cycleApproved = true;
        } else {
            roundFailedToStart = true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approved == true</code></p>
<hr />
<h3>Contract : AgileArbitrationWithAssistance</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8639394f36be3fb587610f6cb0aa92cdd6a33c99">0x8639394f36be3fb587610f6cb0aa92cdd6a33c99</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa4428439ec214cc68240552ec93298d1da391114">0xa4428439ec214cc68240552ec93298d1da391114</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc927a1e4c431babb798d705988ab036e2bdcf640">0xc927a1e4c431babb798d705988ab036e2bdcf640</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : InvestmentNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3f322a4c4a5d00a480dffedf7e4749fb8116d29b">0x3f322a4c4a5d00a480dffedf7e4749fb8116d29b</a></p>
<pre><code class="language-solidity">function setApprovalForAll(address operator, bool approved) public override {
        if(approved == true &amp;&amp; isOperatorBlocked[operator]) {
            revert(&quot;Operator is blocked&quot;);
        }
        super.setApprovalForAll(operator, approved);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>approved == true &amp;&amp; isOperatorBlocked[operator]</code></p>
<hr />
<h3>Contract : LiquidityProvision</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x96b602f3f7733a1476f71c72f89299f6c1a52509">0x96b602f3f7733a1476f71c72f89299f6c1a52509</a></p>
<pre><code class="language-solidity">function withdraw(uint256 amount, bool payingCharges) public override nonReentrant updateReward(msg.sender)  {
        require(amount &gt; minimumWithdraw, &quot;Cannot withdraw 0&quot;);
        if(payingCharges == true){
            _balances[msg.sender] = _balances[msg.sender].sub(amount);
            _totalSupply = _totalSupply.sub(amount);
            uint256 fee = amount.mul(withdrawCharges).div(100);
            stakingToken.safeTransfer(wallet, fee);
            amount = amount.sub(fee);
            stakingToken.safeTransfer(msg.sender, amount);
            emit Withdrawn(msg.sender, amount);
        }
        else{
            if(requestedAmount[msg.sender] != amount){
            requestedAmount[msg.sender] = amount;
            requestedTime[msg.sender] = block.timestamp;
        }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>payingCharges == true</code></p>
<hr />
<h3>Contract : LiquidityProvision</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x96b602f3f7733a1476f71c72f89299f6c1a52509">0x96b602f3f7733a1476f71c72f89299f6c1a52509</a></p>
<pre><code class="language-solidity">function claim(bool payingCharges) public nonReentrant updateReward(msg.sender) {
        uint256 amount = requestedAmount[msg.sender];
        if(payingCharges == true){
            _balances[msg.sender] = _balances[msg.sender].sub(amount);
            _totalSupply = _totalSupply.sub(amount);
            uint256 fee = amount.mul(withdrawCharges).div(100);
            stakingToken.safeTransfer(wallet, fee);
            amount = amount.sub(fee);
        }
        else{
            require(requestedTime[msg.sender].add(coolDownPeriod) &lt;= block.timestamp, 'You can withdraw after 8 days of requesting otherwise pay charges first');
            _balances[msg.sender] = _balances[msg.sender].sub(amount);
            _totalSupply = _totalSupply.sub(amount);
        }
        stakingToken.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
        requestedTime[msg.sender] = 0;
        requestedAmount[msg.sender] = 0;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>payingCharges == true</code></p>
<hr />
<h3>Contract : BaseVault</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9728af00a204e8989139f0ded04183de9eb8c403">0x9728af00a204e8989139f0ded04183de9eb8c403</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value, bytes32 _initData) external override moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                IModule(_module).init(address(this), _initData);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: cannot remove last module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdb746e5dc4f0953e854a5ae4e61ab04ce4b3949b">0xdb746e5dc4f0953e854a5ae4e61ab04ce4b3949b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdb746e5dc4f0953e854a5ae4e61ab04ce4b3949b">0xdb746e5dc4f0953e854a5ae4e61ab04ce4b3949b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdb746e5dc4f0953e854a5ae4e61ab04ce4b3949b">0xdb746e5dc4f0953e854a5ae4e61ab04ce4b3949b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdb746e5dc4f0953e854a5ae4e61ab04ce4b3949b">0xdb746e5dc4f0953e854a5ae4e61ab04ce4b3949b</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : BabyGrok</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde5a3d9be5a0432879a9d7014a9c4f4bd1d174e9">0xde5a3d9be5a0432879a9d7014a9c4f4bd1d174e9</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            staker[msg.sender].stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }

        staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(
            _amount
        );
        staker[msg.sender].lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
            return;
        }

        staker[msg.sender].unstakeStartTime = block.timestamp;
        staker[msg.sender].pendingAmount =
            staker[msg.sender].pendingAmount +
            outAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : BabyGrok</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde5a3d9be5a0432879a9d7014a9c4f4bd1d174e9">0xde5a3d9be5a0432879a9d7014a9c4f4bd1d174e9</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            staker[msg.sender].stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }

        staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(
            _amount
        );
        staker[msg.sender].lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
            return;
        }

        staker[msg.sender].unstakeStartTime = block.timestamp;
        staker[msg.sender].pendingAmount =
            staker[msg.sender].pendingAmount +
            outAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6455f1828725859c267fdddb4577a3ee1b8b97f5">0x6455f1828725859c267fdddb4577a3ee1b8b97f5</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;KingSwap: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : KingSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6455f1828725859c267fdddb4577a3ee1b8b97f5">0x6455f1828725859c267fdddb4577a3ee1b8b97f5</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;KingSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : TAStrategy</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xba652a84ec10fefb0ef1fdb228ab0781b53522d5">0xba652a84ec10fefb0ef1fdb228ab0781b53522d5</a></p>
<pre><code class="language-solidity">function adjustWatermark(uint amount, bool signs) external onlyVault {
        uint lastWatermark = watermark;
        watermark = signs == true ? watermark + amount : watermark - amount;
        emit AdjustWatermark(watermark, lastWatermark);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>watermark = signs == true ? watermark + amount : watermark - amount</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc0b6eed9589380c3e3258e3a00a15c898541da5c">0xc0b6eed9589380c3e3258e3a00a15c898541da5c</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : OasisAuctionHouse</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd322fa1e343b9866b1b729bd8374de0cff0519e2">0xd322fa1e343b9866b1b729bd8374de0cff0519e2</a></p>
<pre><code class="language-solidity">function createBid(uint256 _currentTokenId, bool _standing) external payable nonReentrant  onlyUnpaused {

        IAuctionHouse.Auction memory _auction = auction; 
        address payable lastBidder = _auction.bidder;
        uint256 _bidAmount;

        // Check that the auction is live
        require(_currentTokenId == _auction.tokenId, 'Bid on wrong tokenId.');
        require(block.timestamp &lt; _auction.endTime, &quot;Auction has ended&quot;);
        require(block.timestamp &gt; _auction.startTime, &quot;Auction has not started&quot;);


        // if not standing bid, and not current bidder: refund high bidder
        if (lastBidder != address(0) &amp;&amp; Bids[lastBidder].standing == false &amp;&amp; Bids[lastBidder].refunded == false &amp;&amp; lastBidder != msg.sender) {
            _safeTransferETH(lastBidder, _auction.amount);
            Bids[lastBidder].refunded = true;
        }

        // upsert this bid
        if (lastBidder == msg.sender || (Bids[msg.sender].standing == true &amp;&amp; Bids[msg.sender].refunded == false)) {
            // if current high bidder or losing standing bid:  update the Bid struct
            _bidAmount = Bids[msg.sender].amount + msg.value;
            require(
                (
                    _bidAmount &gt;= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100)
                )
                ||
                (
                    buyNowPrices[_currentTokenId] &gt; 0 &amp;&amp; _bidAmount &gt;= buyNowPrices[_currentTokenId] 
                ), 
                &quot;Bid is too low.&quot;
            );
            Bids[msg.sender].amount = _bidAmount;
            Bids[msg.sender].timestamp = block.timestamp;
            Bids[msg.sender].refunded = false;

            // if bidder is changing standing status, update standingBidders array
            if (_standing == true &amp;&amp; Bids[msg.sender].standing == false) {
                standingBidders.push(msg.sender);
            } else if (_standing == false &amp;&amp; Bids[msg.sender].standing == true) {
                // loop through standing bidders and remove the address
                for (uint i = 0; i &lt; standingBidders.length; i++) {
                    if (standingBidders[i] == msg.sender) {
                        standingBidders[i] = standingBidders[standingBidders.length - 1];
                        standingBidders.pop();
                        break;
                    }
                }
            }
            Bids[msg.sender].standing = _standing;

        } else {
            require(
                (
                    msg.value &gt;= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100)
                )
                ||
                (
                    buyNowPrices[_currentTokenId] &gt; 0 &amp;&amp; msg.value &gt;= buyNowPrices[_currentTokenId]
                ), 
                &quot;Bid is too low.&quot;
            );
            require(msg.value &gt;= minimumBid, &quot;Bid is too low.&quot;); 
            // else, add new bid to Bid struct
            _bidAmount = msg.value;
            Bid memory new_bid;
            new_bid.bidder = payable(msg.sender);
            new_bid.amount = _bidAmount;
            new_bid.timestamp = block.timestamp;
            new_bid.winner = false;
            new_bid.refunded = false;
            new_bid.standing = _standing;
            Bids[msg.sender] = new_bid;

            if (_standing == true) {
                standingBidders.push(msg.sender);
            }
        }

        // Update the auction state with the new bid bidder and the new amount
        auction.bidder = payable(msg.sender);
        auction.amount = _bidAmount;

        // Extend the auction if the bid was received within the time buffer
        bool extended = _auction.endTime - block.timestamp &lt; timeBuffer;
        if (extended) {
            auction.endTime = _auction.endTime = _auction.endTime + timeBuffer;
            auction.extendedTime = _auction.extendedTime + timeBuffer;
        }

        emit AuctionBid(currentTokenId, msg.sender, _bidAmount, _standing, extended, false); 

        if (extended) {
            emit AuctionExtended(currentTokenId, _auction.endTime);
        }

        // if this bid &gt;= buy it now price:
        //   set duration to clsoetime -now + duration
        //   set close time to now
        if (buyNowPrices[_currentTokenId] &gt; 0 &amp;&amp; _bidAmount &gt;= buyNowPrices[_currentTokenId]) {
            duration = _auction.endTime - block.timestamp + duration;
            auction.endTime = _auction.endTime = block.timestamp;
            emit BuyNow(_currentTokenId, msg.sender, _bidAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_standing == true &amp;&amp; Bids[msg.sender].standing == false</code></p>
<hr />
<h3>Contract : OasisAuctionHouse</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd322fa1e343b9866b1b729bd8374de0cff0519e2">0xd322fa1e343b9866b1b729bd8374de0cff0519e2</a></p>
<pre><code class="language-solidity">function createBid(uint256 _currentTokenId, bool _standing) external payable nonReentrant  onlyUnpaused {

        IAuctionHouse.Auction memory _auction = auction; 
        address payable lastBidder = _auction.bidder;
        uint256 _bidAmount;

        // Check that the auction is live
        require(_currentTokenId == _auction.tokenId, 'Bid on wrong tokenId.');
        require(block.timestamp &lt; _auction.endTime, &quot;Auction has ended&quot;);
        require(block.timestamp &gt; _auction.startTime, &quot;Auction has not started&quot;);


        // if not standing bid, and not current bidder: refund high bidder
        if (lastBidder != address(0) &amp;&amp; Bids[lastBidder].standing == false &amp;&amp; Bids[lastBidder].refunded == false &amp;&amp; lastBidder != msg.sender) {
            _safeTransferETH(lastBidder, _auction.amount);
            Bids[lastBidder].refunded = true;
        }

        // upsert this bid
        if (lastBidder == msg.sender || (Bids[msg.sender].standing == true &amp;&amp; Bids[msg.sender].refunded == false)) {
            // if current high bidder or losing standing bid:  update the Bid struct
            _bidAmount = Bids[msg.sender].amount + msg.value;
            require(
                (
                    _bidAmount &gt;= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100)
                )
                ||
                (
                    buyNowPrices[_currentTokenId] &gt; 0 &amp;&amp; _bidAmount &gt;= buyNowPrices[_currentTokenId] 
                ), 
                &quot;Bid is too low.&quot;
            );
            Bids[msg.sender].amount = _bidAmount;
            Bids[msg.sender].timestamp = block.timestamp;
            Bids[msg.sender].refunded = false;

            // if bidder is changing standing status, update standingBidders array
            if (_standing == true &amp;&amp; Bids[msg.sender].standing == false) {
                standingBidders.push(msg.sender);
            } else if (_standing == false &amp;&amp; Bids[msg.sender].standing == true) {
                // loop through standing bidders and remove the address
                for (uint i = 0; i &lt; standingBidders.length; i++) {
                    if (standingBidders[i] == msg.sender) {
                        standingBidders[i] = standingBidders[standingBidders.length - 1];
                        standingBidders.pop();
                        break;
                    }
                }
            }
            Bids[msg.sender].standing = _standing;

        } else {
            require(
                (
                    msg.value &gt;= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100)
                )
                ||
                (
                    buyNowPrices[_currentTokenId] &gt; 0 &amp;&amp; msg.value &gt;= buyNowPrices[_currentTokenId]
                ), 
                &quot;Bid is too low.&quot;
            );
            require(msg.value &gt;= minimumBid, &quot;Bid is too low.&quot;); 
            // else, add new bid to Bid struct
            _bidAmount = msg.value;
            Bid memory new_bid;
            new_bid.bidder = payable(msg.sender);
            new_bid.amount = _bidAmount;
            new_bid.timestamp = block.timestamp;
            new_bid.winner = false;
            new_bid.refunded = false;
            new_bid.standing = _standing;
            Bids[msg.sender] = new_bid;

            if (_standing == true) {
                standingBidders.push(msg.sender);
            }
        }

        // Update the auction state with the new bid bidder and the new amount
        auction.bidder = payable(msg.sender);
        auction.amount = _bidAmount;

        // Extend the auction if the bid was received within the time buffer
        bool extended = _auction.endTime - block.timestamp &lt; timeBuffer;
        if (extended) {
            auction.endTime = _auction.endTime = _auction.endTime + timeBuffer;
            auction.extendedTime = _auction.extendedTime + timeBuffer;
        }

        emit AuctionBid(currentTokenId, msg.sender, _bidAmount, _standing, extended, false); 

        if (extended) {
            emit AuctionExtended(currentTokenId, _auction.endTime);
        }

        // if this bid &gt;= buy it now price:
        //   set duration to clsoetime -now + duration
        //   set close time to now
        if (buyNowPrices[_currentTokenId] &gt; 0 &amp;&amp; _bidAmount &gt;= buyNowPrices[_currentTokenId]) {
            duration = _auction.endTime - block.timestamp + duration;
            auction.endTime = _auction.endTime = block.timestamp;
            emit BuyNow(_currentTokenId, msg.sender, _bidAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_standing == false &amp;&amp; Bids[msg.sender].standing == true</code></p>
<hr />
<h3>Contract : OasisAuctionHouse</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd322fa1e343b9866b1b729bd8374de0cff0519e2">0xd322fa1e343b9866b1b729bd8374de0cff0519e2</a></p>
<pre><code class="language-solidity">function createBid(uint256 _currentTokenId, bool _standing) external payable nonReentrant  onlyUnpaused {

        IAuctionHouse.Auction memory _auction = auction; 
        address payable lastBidder = _auction.bidder;
        uint256 _bidAmount;

        // Check that the auction is live
        require(_currentTokenId == _auction.tokenId, 'Bid on wrong tokenId.');
        require(block.timestamp &lt; _auction.endTime, &quot;Auction has ended&quot;);
        require(block.timestamp &gt; _auction.startTime, &quot;Auction has not started&quot;);


        // if not standing bid, and not current bidder: refund high bidder
        if (lastBidder != address(0) &amp;&amp; Bids[lastBidder].standing == false &amp;&amp; Bids[lastBidder].refunded == false &amp;&amp; lastBidder != msg.sender) {
            _safeTransferETH(lastBidder, _auction.amount);
            Bids[lastBidder].refunded = true;
        }

        // upsert this bid
        if (lastBidder == msg.sender || (Bids[msg.sender].standing == true &amp;&amp; Bids[msg.sender].refunded == false)) {
            // if current high bidder or losing standing bid:  update the Bid struct
            _bidAmount = Bids[msg.sender].amount + msg.value;
            require(
                (
                    _bidAmount &gt;= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100)
                )
                ||
                (
                    buyNowPrices[_currentTokenId] &gt; 0 &amp;&amp; _bidAmount &gt;= buyNowPrices[_currentTokenId] 
                ), 
                &quot;Bid is too low.&quot;
            );
            Bids[msg.sender].amount = _bidAmount;
            Bids[msg.sender].timestamp = block.timestamp;
            Bids[msg.sender].refunded = false;

            // if bidder is changing standing status, update standingBidders array
            if (_standing == true &amp;&amp; Bids[msg.sender].standing == false) {
                standingBidders.push(msg.sender);
            } else if (_standing == false &amp;&amp; Bids[msg.sender].standing == true) {
                // loop through standing bidders and remove the address
                for (uint i = 0; i &lt; standingBidders.length; i++) {
                    if (standingBidders[i] == msg.sender) {
                        standingBidders[i] = standingBidders[standingBidders.length - 1];
                        standingBidders.pop();
                        break;
                    }
                }
            }
            Bids[msg.sender].standing = _standing;

        } else {
            require(
                (
                    msg.value &gt;= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100)
                )
                ||
                (
                    buyNowPrices[_currentTokenId] &gt; 0 &amp;&amp; msg.value &gt;= buyNowPrices[_currentTokenId]
                ), 
                &quot;Bid is too low.&quot;
            );
            require(msg.value &gt;= minimumBid, &quot;Bid is too low.&quot;); 
            // else, add new bid to Bid struct
            _bidAmount = msg.value;
            Bid memory new_bid;
            new_bid.bidder = payable(msg.sender);
            new_bid.amount = _bidAmount;
            new_bid.timestamp = block.timestamp;
            new_bid.winner = false;
            new_bid.refunded = false;
            new_bid.standing = _standing;
            Bids[msg.sender] = new_bid;

            if (_standing == true) {
                standingBidders.push(msg.sender);
            }
        }

        // Update the auction state with the new bid bidder and the new amount
        auction.bidder = payable(msg.sender);
        auction.amount = _bidAmount;

        // Extend the auction if the bid was received within the time buffer
        bool extended = _auction.endTime - block.timestamp &lt; timeBuffer;
        if (extended) {
            auction.endTime = _auction.endTime = _auction.endTime + timeBuffer;
            auction.extendedTime = _auction.extendedTime + timeBuffer;
        }

        emit AuctionBid(currentTokenId, msg.sender, _bidAmount, _standing, extended, false); 

        if (extended) {
            emit AuctionExtended(currentTokenId, _auction.endTime);
        }

        // if this bid &gt;= buy it now price:
        //   set duration to clsoetime -now + duration
        //   set close time to now
        if (buyNowPrices[_currentTokenId] &gt; 0 &amp;&amp; _bidAmount &gt;= buyNowPrices[_currentTokenId]) {
            duration = _auction.endTime - block.timestamp + duration;
            auction.endTime = _auction.endTime = block.timestamp;
            emit BuyNow(_currentTokenId, msg.sender, _bidAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_standing == true</code></p>
<hr />
<h3>Contract : CompetitionETHAsPrize</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb61cf66c9cb1f42fe178e9f38c948b6f0ba91373">0xb61cf66c9cb1f42fe178e9f38c948b6f0ba91373</a></p>
<pre><code class="language-solidity">constructor(
        address _blacklistManager,
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10**18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10**18; // 0.1 LINK In Rinkeby and Goerli

        blackListManager = BlackListManager(_blacklistManager);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : DeFineVotingPortal</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x506a5dcf47a27f6a48a23512afa6b32b0f612ce7">0x506a5dcf47a27f6a48a23512afa6b32b0f612ce7</a></p>
<pre><code class="language-solidity">function setExecute(uint256 proposalId, bool status) public payable governance {
        Proposal storage proposal = proposals[proposalId];
        proposal.executed = status;
        if (status == true) {
            emit ProposalExecuted(proposalId);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>status == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x568ba39bafe4d9b0c8f48970ba33b7c74ac048c6">0x568ba39bafe4d9b0c8f48970ba33b7c74ac048c6</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            checkAndSellStables();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x568ba39bafe4d9b0c8f48970ba33b7c74ac048c6">0x568ba39bafe4d9b0c8f48970ba33b7c74ac048c6</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // When a user withdraws, we need to pull the tokens out of the contract
        if(nonContract == true){
            checkAndSellStables();
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }        

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : N2MERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x314abe031467b4ef02c5055e59753fea62181de6">0x314abe031467b4ef02c5055e59753fea62181de6</a></p>
<pre><code class="language-solidity">function initialize(
        string memory tokenName,
        string memory tokenSymbol,
        uint256 iMintPrice,
        bytes32 baseURICIDHash,
        bytes32 placeholderImageCIDHash,
        RevenueAddress[] calldata revenueAddresses,
        address iErc20PaymentAddress,
        uint32 iTotalSupply,
        uint16 iRoyaltyFee,
        bool soulboundCollection,
        MintingType iMintingType
    ) public payable override initializer {
        __ERC721_init(tokenName, tokenSymbol);

        if (iTotalSupply == 0) revert TotalSupplyMustBeGreaterThanZero();
        if (baseURICIDHash != 0 &amp;&amp; placeholderImageCIDHash != 0) revert CantSetBaseURIAndPlaceholderAtTheSameTime();
        if (iRoyaltyFee &gt; 10_00) revert RoyaltyFeeTooHigh();

        _collectionSize = iTotalSupply;
        if (baseURICIDHash == 0) {
            if (placeholderImageCIDHash == 0) {
                if (iMintingType != MintingType.CUSTOM_URI)
                    revert NoBaseURINorPlaceholderSet();
            } else {
                _placeholderImageCIDHash = placeholderImageCIDHash;
            }
        } else {
            _baseURICIDHash = baseURICIDHash;
        }

        _mintPrice = iMintPrice;
        _royaltyFee = iRoyaltyFee;
        if (iMintingType != MintingType.SEQUENTIAL) {
            _mintingType = iMintingType;
        }
        if (iErc20PaymentAddress != address(0)) {
            _isERC20Payment = true;
            _erc20PaymentAddress = iErc20PaymentAddress;
        }
        if (soulboundCollection == true) {
            _soulboundCollection = true;
        }

        if (revenueAddresses.length &gt; 0) {
            uint256 revenuePercentageTotal;
            for (uint256 i; i &lt; revenueAddresses.length; ) {
                revenuePercentageTotal += revenueAddresses[i].percentage;
                unchecked {
                    ++i;
                }
            }
            _revenueInfo = revenueAddresses;
            if (revenuePercentageTotal &gt; 100_00 - N2M_FEE) revert InvalidRevenuePercentage();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>soulboundCollection == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7f84798fbe2e99457948e58920988e615eb6996a">0x7f84798fbe2e99457948e58920988e615eb6996a</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + hightLightFee);
                } else {
                    require(msg.value == limitETHFee + hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7f84798fbe2e99457948e58920988e615eb6996a">0x7f84798fbe2e99457948e58920988e615eb6996a</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : StabilizeStrategyUSTFlashArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4d7ef4fbc8ed5d30a3f0b8ba282a993dd6843bfd">0x4d7ef4fbc8ed5d30a3f0b8ba282a993dd6843bfd</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyUSTFlashArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4d7ef4fbc8ed5d30a3f0b8ba282a993dd6843bfd">0x4d7ef4fbc8ed5d30a3f0b8ba282a993dd6843bfd</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(_depositor, false);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrder(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrder(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : Collateral</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x264ee56916aecc7a799317a84f3f6f17a4fba492">0x264ee56916aecc7a799317a84f3f6f17a4fba492</a></p>
<pre><code class="language-solidity">function provideCollateralRelief(uint256 _amount, uint256 _rate, uint _option, bool _addRelief) external {
        require(msg.sender == owner);
        require(_rate &gt; 0 &amp;&amp; _rate &lt;= 10000);

        if(_addRelief == true) {
            require(_getAvailableFunds(ERC20(aToken[_option]), _option) &gt;= _amount);
            collateralRelief[_option][_rate] += _amount;
            totalRelief[_option] += _amount;
            StoreHubInterface(storeHub[_option]).callEvent(address(0), _amount, _rate, true, 1);
        }
        else {
            require(collateralRelief[_option][_rate] &gt;= _amount);
            collateralRelief[_option][_rate] -= _amount;
            totalRelief[_option] -= _amount;
            StoreHubInterface(storeHub[_option]).callEvent(address(0), _amount, _rate, false, 1);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_addRelief == true</code></p>
<hr />
<h3>Contract : Collateral</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x264ee56916aecc7a799317a84f3f6f17a4fba492">0x264ee56916aecc7a799317a84f3f6f17a4fba492</a></p>
<pre><code class="language-solidity">function receiveCollateral(uint256 _amount, uint256 _rate, uint _option, bool _isTrade) external {
        require(StoreHubInterface(storeHub[0]).isValidStore(address(msg.sender))  == true);

        if(_isTrade == true){
            require(collateralRelief[_option][_rate] == _amount);
            collateralRelief[_option][_rate] = 0;
            totalRelief[_option] -= _amount;
        }

        collateral[_option] += _amount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isTrade == true</code></p>
<hr />
<h3>Contract : General</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x264ee56916aecc7a799317a84f3f6f17a4fba492">0x264ee56916aecc7a799317a84f3f6f17a4fba492</a></p>
<pre><code class="language-solidity">function provideCollateralRelief(uint256 _amount, uint256 _rate, uint _option, bool _addRelief) external {
        require(msg.sender == owner);
        require(_rate &gt; 0 &amp;&amp; _rate &lt;= 10000);

        if(_addRelief == true) {
            require(_getAvailableFunds(ERC20(aToken[_option]), _option) &gt;= _amount);
            collateralRelief[_option][_rate] += _amount;
            totalRelief[_option] += _amount;
            StoreHubInterface(storeHub[_option]).callEvent(address(0), _amount, _rate, true, 1);
        }
        else {
            require(collateralRelief[_option][_rate] &gt;= _amount);
            collateralRelief[_option][_rate] -= _amount;
            totalRelief[_option] -= _amount;
            StoreHubInterface(storeHub[_option]).callEvent(address(0), _amount, _rate, false, 1);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_addRelief == true</code></p>
<hr />
<h3>Contract : General</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x264ee56916aecc7a799317a84f3f6f17a4fba492">0x264ee56916aecc7a799317a84f3f6f17a4fba492</a></p>
<pre><code class="language-solidity">function receiveCollateral(uint256 _amount, uint256 _rate, uint _option, bool _isTrade) external {
        require(StoreHubInterface(storeHub[0]).isValidStore(address(msg.sender))  == true);

        if(_isTrade == true){
            require(collateralRelief[_option][_rate] == _amount);
            collateralRelief[_option][_rate] = 0;
            totalRelief[_option] -= _amount;
        }

        collateral[_option] += _amount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isTrade == true</code></p>
<hr />
<h3>Contract : Mona_Lisa_Original</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfcca30504374f54eddd0b5c43a07f170b75df42a">0xfcca30504374f54eddd0b5c43a07f170b75df42a</a></p>
<pre><code class="language-solidity">function mintForAll(uint256 amount, bool _isUK) external payable {
        require(block.timestamp &gt;= MINT_START_TIME, &quot;Minting is not yet open.&quot;);
        require(amount &lt;= MAX_MINT_PER_ACCOUNT, &quot;Amount Exceeds Maximum Mints Allowed Per Account.&quot;);
        require(userNftCount[msg.sender] + amount &lt;= MAX_MINT_PER_ACCOUNT, &quot;You can not mint more than Max Mint Limit.&quot;);
        require(_totalMinted() + amount &lt;= MAX_SUPPLY , &quot;Exceeds Maximum Supply&quot; );
        uint totalCost = amount * mintPrice;
        if (_isUK == true) {
            totalCost = totalCost * 120 / 100; // add 20% VAT tax for UK
        }        
        require( msg.value &gt;= totalCost, &quot;Ether sent is not correct.&quot; );
        _mint(msg.sender, amount);
        userNftCount[msg.sender] += amount;
        if (msg.value &gt; totalCost) {
            payable(msg.sender).transfer(msg.value - totalCost);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isUK == true</code></p>
<hr />
<h3>Contract : MarsGenesisWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc1604fc3f9309abc4239591cce1a349fd80b86c3">0xc1604fc3f9309abc4239591cce1a349fd80b86c3</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x959ee2fc3bce6a0f008deabcab5bf30a809d94a1">0x959ee2fc3bce6a0f008deabcab5bf30a809d94a1</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x959ee2fc3bce6a0f008deabcab5bf30a809d94a1">0x959ee2fc3bce6a0f008deabcab5bf30a809d94a1</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x959ee2fc3bce6a0f008deabcab5bf30a809d94a1">0x959ee2fc3bce6a0f008deabcab5bf30a809d94a1</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x959ee2fc3bce6a0f008deabcab5bf30a809d94a1">0x959ee2fc3bce6a0f008deabcab5bf30a809d94a1</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : BabyCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe1a6e6bdc0713a7c0ad241c1eaecb482a3f230cb">0xe1a6e6bdc0713a7c0ad241c1eaecb482a3f230cb</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x00000045cdfe2dc2623170b3d6ebaa0b446a243a">0x00000045cdfe2dc2623170b3d6ebaa0b446a243a</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : StonksStrategy</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb103f669e87f67376fb9458a67226f2774a0b4fd">0xb103f669e87f67376fb9458a67226f2774a0b4fd</a></p>
<pre><code class="language-solidity">function adjustWatermark(uint amount, bool signs) external onlyVault {
        uint lastWatermark = watermark;
        watermark = signs == true ? watermark + amount : watermark - amount;
        emit AdjustWatermark(watermark, lastWatermark);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>watermark = signs == true ? watermark + amount : watermark - amount</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6b71d30c1c0a3ccbd61977007225dee749901ca6">0x6b71d30c1c0a3ccbd61977007225dee749901ca6</a></p>
<pre><code class="language-solidity">function updateSale(address _tokenAddress,uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) onlyAcceptedToken(_tokenAddress) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale      = true;
            sale.amount         = _amount;
            sale.price          = _price;
            sale.tokenAddress   = _tokenAddress;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : EthFoundation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6766bd2f2c269e581504675fe4c8fdb787f8d98b">0x6766bd2f2c269e581504675fe4c8fdb787f8d98b</a></p>
<pre><code class="language-solidity">function lockUser(address ethAddress, bool isLock)  onlyAdmin {

        //require ((msg.sender == 0x8b24767bc01a8fd1969344aaaac886e8f31e905c),&quot;&quot;);

        User user = userMapping[ethAddress];
        if(isLock == true){
            user.isLock = true;
            userMapping[user.ethAddress] =  user;
        }
        else if(isLock == false){
            user.isLock = false;
            userMapping[user.ethAddress] =  user;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isLock == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1d09a6d1c45d1a9eb8cb8a8354bcd78e225f06d3">0x1d09a6d1c45d1a9eb8cb8a8354bcd78e225f06d3</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external override moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                IModule(_module).init(address(this));
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : OMNIS</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x82b9eb75d6e8e6b4a296cf8fde9a7c23ee4b89ec">0x82b9eb75d6e8e6b4a296cf8fde9a7c23ee4b89ec</a></p>
<pre><code class="language-solidity">function answerPaymentRequest(uint _orderId, bool _answer) external returns(bool) {
        //Get Payment Handler
        Payment storage payment = payments[_orderId];

        require(payment.status == PaymentStatus.Requested, 'Ticket wrong status, expected &quot;Requested&quot;');
        require(payment.customer == msg.sender, 'You are not allowed to manage this ticket');

        if (_answer == true) {

            address _to = address(this);

            balances[payment.provider] = balances[payment.provider].sub(payment.value);
            balances[_to] = balances[_to].add(payment.value);
            emit Transfer(payment.provider, _to, payment.value);

            //STAKING RELATED//////////////////////////////////////////////
            if (transferIns[payment.provider].length &gt; 0) delete transferIns[payment.provider];
            uint64 _now = uint64(now);
            transferIns[payment.provider].push(transferInStruct(uint128(balances[payment.provider]), _now));
            ///////////////////////////////////////////////////////////////

            payments[_orderId].status = PaymentStatus.Pending;

            emit PaymentUpdate(_orderId, payment.provider, payment.customer, payment.value, PaymentStatus.Pending);

        } else {

            payments[_orderId].status = PaymentStatus.Rejected;

            emit PaymentUpdate(_orderId, payment.provider, payment.customer, payment.value, PaymentStatus.Rejected);

        }

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_answer == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea2d407f1307d1413e84b2730f0870fd72dc0">0xcafea2d407f1307d1413e84b2730f0870fd72dc0</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyDSDESDArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc2da2859901fdb615ebf4449983b96beca238c57">0xc2da2859901fdb615ebf4449983b96beca238c57</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyDSDESDArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc2da2859901fdb615ebf4449983b96beca238c57">0xc2da2859901fdb615ebf4449983b96beca238c57</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(address(0));
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : MarsGenesisMartiansWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe80d47ec59fbff0c05b6268f21ccc5bcc9ec169d">0xe80d47ec59fbff0c05b6268f21ccc5bcc9ec169d</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x982edd74fb8a7d04c95eda20e475fc57d92af0a9">0x982edd74fb8a7d04c95eda20e475fc57d92af0a9</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x982edd74fb8a7d04c95eda20e475fc57d92af0a9">0x982edd74fb8a7d04c95eda20e475fc57d92af0a9</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5d1df39f8c8278cc95d078c992eff355870c5d38">0x5d1df39f8c8278cc95d078c992eff355870c5d38</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5d1df39f8c8278cc95d078c992eff355870c5d38">0x5d1df39f8c8278cc95d078c992eff355870c5d38</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x66177502f06f3723093baf11a8ff130d3de8d438">0x66177502f06f3723093baf11a8ff130d3de8d438</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x66177502f06f3723093baf11a8ff130d3de8d438">0x66177502f06f3723093baf11a8ff130d3de8d438</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x66177502f06f3723093baf11a8ff130d3de8d438">0x66177502f06f3723093baf11a8ff130d3de8d438</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x66177502f06f3723093baf11a8ff130d3de8d438">0x66177502f06f3723093baf11a8ff130d3de8d438</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4c858f58547e9d5d50488092dd561db790c57e1a">0x4c858f58547e9d5d50488092dd561db790c57e1a</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            checkAndSellStables(true);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4c858f58547e9d5d50488092dd561db790c57e1a">0x4c858f58547e9d5d50488092dd561db790c57e1a</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // When a user withdraws, we need to pull the tokens out of the contract
        if(nonContract == true){
            checkAndSellStables(true);
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }        

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe99ef129649343c7cdf14d8febd86c811b8eb43a">0xe99ef129649343c7cdf14d8febd86c811b8eb43a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe99ef129649343c7cdf14d8febd86c811b8eb43a">0xe99ef129649343c7cdf14d8febd86c811b8eb43a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe99ef129649343c7cdf14d8febd86c811b8eb43a">0xe99ef129649343c7cdf14d8febd86c811b8eb43a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe99ef129649343c7cdf14d8febd86c811b8eb43a">0xe99ef129649343c7cdf14d8febd86c811b8eb43a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe99ef129649343c7cdf14d8febd86c811b8eb43a">0xe99ef129649343c7cdf14d8febd86c811b8eb43a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe99ef129649343c7cdf14d8febd86c811b8eb43a">0xe99ef129649343c7cdf14d8febd86c811b8eb43a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe99ef129649343c7cdf14d8febd86c811b8eb43a">0xe99ef129649343c7cdf14d8febd86c811b8eb43a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe99ef129649343c7cdf14d8febd86c811b8eb43a">0xe99ef129649343c7cdf14d8febd86c811b8eb43a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Presale</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdd3b8c64b1852a2147b0ed2e5bc8bb399463b166">0xdd3b8c64b1852a2147b0ed2e5bc8bb399463b166</a></p>
<pre><code class="language-solidity">function buy(
        address _token,
        uint256 _amount,
        address _onBehalfOf,
        address _refWallet,
        bool _stakeIt
    ) public payable nonReentrant returns (uint256) {
        require(presaleOpen, &quot;presale is closed&quot;);
        require(_token != address(0), &quot;Invalid _token address&quot;);
        require(_onBehalfOf != address(0), &quot;Invalid onBehalfOf address&quot;);
        require(_amount &gt; 0, &quot;Amount should be more than 0&quot;);
        require(_refWallet != address(0), &quot;Invalid refWallet address&quot;);
        require(_refWallet != _onBehalfOf, &quot;buyer can not refer themself&quot;);

        AggregatorV3Interface priceFeed;
        bool found = false;
        uint256 decimals;
        for (uint i = 0; i &lt; paymentTokens.length; i++) {
            if (paymentTokens[i].token == _token) {
                priceFeed = paymentTokens[i].priceFeed;
                decimals = paymentTokens[i].decimals;
                found = true;
                break;
            }
        }
        require(found, &quot;Payment token not supported&quot;);

        uint256 amountInUSD = convertPaymentTokenToUsd(
            _amount,
            priceFeed,
            decimals
        );

        if (_token == eth) {
            require(_amount == msg.value, &quot;Amount does not match&quot;);
            (bool sent, ) = treasury.call{value: _amount}(&quot;&quot;);
            require(sent, &quot;Failed to send Ether&quot;);
        } else {
            SafeERC20.safeTransferFrom(
                IERC20(_token),
                msg.sender,
                treasury,
                _amount
            );
        }

        uint256 tokens = (amountInUSD * (10 ** 18)) / tokenPriceUSD;
        balances[_onBehalfOf] += tokens;
        totalBoughtTokens += tokens;

        uint256 refAmount = (tokens * refPercentage) / 100;
        referrals[_refWallet] += refAmount;
        totalReferralTokens += refAmount;

        if (_stakeIt == true) {
            _stake(_onBehalfOf, tokens);
        }

        emit PurchaseMade(
            _token,
            _amount,
            _onBehalfOf,
            tokens,
            _refWallet,
            _stakeIt
        );

        return tokens;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_stakeIt == true</code></p>
<hr />
<h3>Contract : LendingPoolConfigurator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x18a60fc294bf180cffe589247a2e473418fa0b0e">0x18a60fc294bf180cffe589247a2e473418fa0b0e</a></p>
<pre><code class="language-solidity">function enableReserveForInvoicePool(address _reserve, bool _enable) external onlyLendingPoolManager {
        require(_reserve != address(0x0), &quot;reserve address is invalid&quot;);
        if(_enable == true) {
            require(isInvoiceReserve[_reserve] == false, &quot;reserve is already been enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = true;
        } else {
            require(isInvoiceReserve[_reserve] == true, &quot;reserve is not enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enable == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa35457437995267bf4943fb214df7e77edcc0376">0xa35457437995267bf4943fb214df7e77edcc0376</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa35457437995267bf4943fb214df7e77edcc0376">0xa35457437995267bf4943fb214df7e77edcc0376</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa35457437995267bf4943fb214df7e77edcc0376">0xa35457437995267bf4943fb214df7e77edcc0376</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa35457437995267bf4943fb214df7e77edcc0376">0xa35457437995267bf4943fb214df7e77edcc0376</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : JBController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe29059b4a169091ed982b0546df9f79b330eea85">0xe29059b4a169091ed982b0546df9f79b330eea85</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        SafeCast.toInt256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          SafeCast.toInt256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : JBController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe29059b4a169091ed982b0546df9f79b330eea85">0xe29059b4a169091ed982b0546df9f79b330eea85</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        SafeCast.toInt256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          SafeCast.toInt256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : Tougenkyou</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1fc12a099ea4cf718289472908cc6ee8c0c05bad">0x1fc12a099ea4cf718289472908cc6ee8c0c05bad</a></p>
<pre><code class="language-solidity">constructor(bool mintERC2309Flg) ERC721A(&quot;Tougenkyou&quot;, &quot;MOMO&quot;) {
        _setDefaultRoyalty(0x37df2D6523265a68975e2429e74E841d524b6BB9, 1000);
        if (mintERC2309Flg == true) {
            _mintERC2309(0x0495F6b0C4273E233DFd48D5AFE347ef7Ee595BA, 198);
            _initializeOwnershipAt(50);
            _initializeOwnershipAt(100);
            _initializeOwnershipAt(150);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mintERC2309Flg == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7f4742a8be482ac56c20cc02485f97d074952c00">0x7f4742a8be482ac56c20cc02485f97d074952c00</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7f4742a8be482ac56c20cc02485f97d074952c00">0x7f4742a8be482ac56c20cc02485f97d074952c00</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9a86b5a9224243039e057bd2f837a150fde3f45c">0x9a86b5a9224243039e057bd2f837a150fde3f45c</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9a86b5a9224243039e057bd2f837a150fde3f45c">0x9a86b5a9224243039e057bd2f837a150fde3f45c</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : LPStakingRewards</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x957e5d3ab1d24cf7ebaf6e2f8a29f3a69ffd19db">0x957e5d3ab1d24cf7ebaf6e2f8a29f3a69ffd19db</a></p>
<pre><code class="language-solidity">function stake(uint _amount, bool claim) external updateReward(msg.sender) {
        require(_amount &gt; 0, &quot;amount = 0&quot;);
        stakingToken.transferFrom(msg.sender, address(this), _amount);
        balanceOf[msg.sender] += _amount;
        totalSupply += _amount;
        if (claim == true) {
            getReward();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim == true</code></p>
<hr />
<h3>Contract : LPStakingRewards</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x957e5d3ab1d24cf7ebaf6e2f8a29f3a69ffd19db">0x957e5d3ab1d24cf7ebaf6e2f8a29f3a69ffd19db</a></p>
<pre><code class="language-solidity">function withdraw(uint _amount, bool claim) external updateReward(msg.sender) {
        require(_amount &gt; 0, &quot;amount = 0&quot;);
        balanceOf[msg.sender] -= _amount;
        totalSupply -= _amount;
        stakingToken.transfer(msg.sender, _amount);
        if (claim == true) {
            getReward();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xebdd9752be578c03491ff1083c0f738aa8687d48">0xebdd9752be578c03491ff1083c0f738aa8687d48</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : MarsGenesisCore</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x467439207d53530505e5eb40edd6debbaff3e063">0x467439207d53530505e5eb40edd6debbaff3e063</a></p>
<pre><code class="language-solidity">function mintLand(bool isPromo, string memory topLeftLatLong, string memory bottomRightLatLong, bytes memory signature, string memory ipfsHash, string memory metadataURI, uint cardId, address promoOwner) external payable returns (uint) {
        if (isPromo == true) {
            require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
            require(hashes[ipfsHash] != 1, &quot;HASH_EXISTS&quot;);
            require(_promoTokenIdTracker.current() &lt; MAX_PROMO_LANDS, &quot;LIMIT_REACHED&quot;);
            _promoTokenIdTracker.increment();
        } else {
            require(msg.value &gt;= _currentPrice(), &quot;PAYMENT_TOO_LOW&quot;);
            require(hashes[ipfsHash] != 1, &quot;HASH_EXISTS&quot;);
            bytes32 hash = keccak256(abi.encodePacked(topLeftLatLong, bottomRightLatLong, address(this), cardId));
            address signer = _recoverSigner(hash, signature);
            require(signer == _deployerAddress, &quot;INVALID_SIGNATURE&quot;);
        }
        address landOwner;
        if (isPromo == true) {
            landOwner = promoOwner;
        } else {
            landOwner = _msgSender();
        }

        uint newTokenId = _mintLand(landOwner, topLeftLatLong, bottomRightLatLong, ipfsHash, metadataURI, cardId);
        return newTokenId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isPromo == true</code></p>
<hr />
<h3>Contract : MarsGenesisCore</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x467439207d53530505e5eb40edd6debbaff3e063">0x467439207d53530505e5eb40edd6debbaff3e063</a></p>
<pre><code class="language-solidity">function mintLand(bool isPromo, string memory topLeftLatLong, string memory bottomRightLatLong, bytes memory signature, string memory ipfsHash, string memory metadataURI, uint cardId, address promoOwner) external payable returns (uint) {
        if (isPromo == true) {
            require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
            require(hashes[ipfsHash] != 1, &quot;HASH_EXISTS&quot;);
            require(_promoTokenIdTracker.current() &lt; MAX_PROMO_LANDS, &quot;LIMIT_REACHED&quot;);
            _promoTokenIdTracker.increment();
        } else {
            require(msg.value &gt;= _currentPrice(), &quot;PAYMENT_TOO_LOW&quot;);
            require(hashes[ipfsHash] != 1, &quot;HASH_EXISTS&quot;);
            bytes32 hash = keccak256(abi.encodePacked(topLeftLatLong, bottomRightLatLong, address(this), cardId));
            address signer = _recoverSigner(hash, signature);
            require(signer == _deployerAddress, &quot;INVALID_SIGNATURE&quot;);
        }
        address landOwner;
        if (isPromo == true) {
            landOwner = promoOwner;
        } else {
            landOwner = _msgSender();
        }

        uint newTokenId = _mintLand(landOwner, topLeftLatLong, bottomRightLatLong, ipfsHash, metadataURI, cardId);
        return newTokenId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isPromo == true</code></p>
<hr />
<h3>Contract : MarsGenesisWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x467439207d53530505e5eb40edd6debbaff3e063">0x467439207d53530505e5eb40edd6debbaff3e063</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x466cf3ea420237cd1669d78efd9519caafe5a73a">0x466cf3ea420237cd1669d78efd9519caafe5a73a</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x466cf3ea420237cd1669d78efd9519caafe5a73a">0x466cf3ea420237cd1669d78efd9519caafe5a73a</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x466cf3ea420237cd1669d78efd9519caafe5a73a">0x466cf3ea420237cd1669d78efd9519caafe5a73a</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x466cf3ea420237cd1669d78efd9519caafe5a73a">0x466cf3ea420237cd1669d78efd9519caafe5a73a</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PresaleV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x216caaffc9c445039d7df23dcdc90b826dae7e3d">0x216caaffc9c445039d7df23dcdc90b826dae7e3d</a></p>
<pre><code class="language-solidity">function buy(
        address _token,
        uint256 _amount,
        address _onBehalfOf,
        address _refWallet,
        bool _stakeIt
    ) public payable nonReentrant returns (uint256) {
        require(presaleOpen, &quot;presale is closed&quot;);
        require(_token != address(0), &quot;Invalid _token address&quot;);
        require(_onBehalfOf != address(0), &quot;Invalid onBehalfOf address&quot;);
        require(_amount &gt; 0, &quot;Amount should be more than 0&quot;);
        require(_refWallet != address(0), &quot;Invalid refWallet address&quot;);
        require(_refWallet != _onBehalfOf, &quot;buyer can not refer themself&quot;);

        if (originalReferrer[_onBehalfOf] == address(0)) {
            originalReferrer[_onBehalfOf] = _refWallet;
            referrerToBuyers[_refWallet].push(_onBehalfOf);
        } else {
            _refWallet = originalReferrer[_onBehalfOf];
        }

        AggregatorV3Interface priceFeed;
        bool found = false;
        uint256 decimals;
        for (uint i = 0; i &lt; paymentTokens.length; i++) {
            if (paymentTokens[i].token == _token) {
                priceFeed = paymentTokens[i].priceFeed;
                decimals = paymentTokens[i].decimals;
                found = true;
                break;
            }
        }
        require(found, &quot;Payment token not supported&quot;);

        uint256 amountInUSD = convertPaymentTokenToUsd(
            _amount,
            priceFeed,
            decimals
        );

        uint256 refEarnedinUSD = (paymentTokenReferralPercentage *
            amountInUSD) / 100;

        uint256 paymentTokenReferralAmount = (paymentTokenReferralPercentage *
            _amount) / 100;

        uint256 forTreasury = _amount - paymentTokenReferralAmount;

        if (_token == eth) {
            (bool sent, ) = treasury.call{value: forTreasury}(&quot;&quot;);
            require(sent, &quot;Failed to send Ether&quot;);
        } else {
            SafeERC20.safeTransferFrom(
                IERC20(_token),
                msg.sender,
                treasury,
                forTreasury
            );
            SafeERC20.safeTransferFrom(
                IERC20(_token),
                msg.sender,
                address(this),
                paymentTokenReferralAmount
            );
        }

        uint256 tokens = (amountInUSD * (10 ** 18)) / tokenPriceUSD;
        balances[_onBehalfOf] += tokens;
        totalBoughtTokens += tokens;

        uint256 refAmount = (tokens * refPercentage) / 100;
        referrals[_refWallet] += refAmount;
        totalReferralTokens += refAmount;

        earnedInUSD[_refWallet] += refEarnedinUSD;

        if (_stakeIt == true) {
            _stake(_onBehalfOf, tokens);
        }

        emit PurchaseMade(
            _token,
            _amount,
            _onBehalfOf,
            tokens,
            _refWallet,
            _stakeIt
        );

        paymentTokenReferralRewards[_refWallet][
            _token
        ] += paymentTokenReferralAmount;

        totalRewardsByPaymentToken[_token] += paymentTokenReferralAmount;

        emit PaymentTokenReferralRewardAdded(
            _refWallet,
            _token,
            paymentTokenReferralAmount,
            refEarnedinUSD,
            _onBehalfOf
        );

        return tokens;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_stakeIt == true</code></p>
<hr />
<h3>Contract : PoP</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5c8b75429089bcc36fc71988d53ba7da05364206">0x5c8b75429089bcc36fc71988d53ba7da05364206</a></p>
<pre><code class="language-solidity">function updateNextWindowAdjustmentRatio (int256 numerator, bool updateFront) public {
        require (msg.sender == author);
        require (numerator &gt;= 1000);
        require (numerator &lt;= 2718);
        require ((updateFront &amp;&amp; canUpdateFrontWindowAdjustmentRatio) || (!updateFront &amp;&amp; canUpdateBackWindowAdjustmentRatio));

        if(updateFront == true) {
            nextFrontWindowAdjustmentRatio = FixedPoint.fromFraction(numerator, 1000);
        } else {
            nextBackWindowAdjustmentRatio = FixedPoint.fromFraction(numerator, 1000);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>updateFront == true</code></p>
<hr />
<h3>Contract : TestNet3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd05090fb80cd02fdbf1962088dd57f400af8b42c">0xd05090fb80cd02fdbf1962088dd57f400af8b42c</a></p>
<pre><code class="language-solidity">function tradeTokensBatch(address token,
        uint256 amount,
        uint24 poolFee,
        bool convertToWeth
    ) public payable checkAddress() returns (uint256 totalSwapped) {
        address firstToken;
        address secondToken;

        if(convertToWeth == true) {
            firstToken = token;
            secondToken = WETH;
        } else {
            firstToken = WETH;
            secondToken = token;
        }

        for (uint256 i = 0; i &lt; wallets.length; i++) {
            uint256 tokenAmount = swapExactInputSingle(firstToken, secondToken, wallets[i], amount, poolFee);
            totalSwapped += tokenAmount;
        }

        return (totalSwapped);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>convertToWeth == true</code></p>
<hr />
<h3>Contract : AnchorAccount</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf4dfb64ad4f7ee82193f3a94a61910ad8ce9f089">0xf4dfb64ad4f7ee82193f3a94a61910ad8ce9f089</a></p>
<pre><code class="language-solidity">function finishDepositStable(bool _isCustodyEnabled) public onlyAuthSender checkFinish terraAddressSet {
        if (_isCustodyEnabled == true) {
            (bool success, bytes memory data) = address(this).delegatecall(abi.encodeWithSignature(&quot;finishDepositStableCustody()&quot;));
            require(success == true, string(data));
        }
        else {
            (bool success, bytes memory data) = address(this).delegatecall(abi.encodeWithSignature(&quot;finishDepositStable()&quot;));
            require(success == true, string(data));
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isCustodyEnabled == true</code></p>
<hr />
<h3>Contract : AnchorAccount</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf4dfb64ad4f7ee82193f3a94a61910ad8ce9f089">0xf4dfb64ad4f7ee82193f3a94a61910ad8ce9f089</a></p>
<pre><code class="language-solidity">function initRedeemStable(uint256 amount, bool _isCustodyEnabled) public onlyAuthSender checkInit terraAddressSet {
        if (_isCustodyEnabled == true) {
            (bool success, bytes memory data) = address(this).delegatecall(abi.encodeWithSignature(&quot;initRedeemStableCustody(uint256)&quot;, amount));
            require(success == true, string(data));
        }
        else {
            (bool success, bytes memory data) = address(this).delegatecall(abi.encodeWithSignature(&quot;initRedeemStable(uint256)&quot;, amount));
            require(success == true, string(data));
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isCustodyEnabled == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x04c762a5df2fa02fe868f25359e0c259fb811cfe">0x04c762a5df2fa02fe868f25359e0c259fb811cfe</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(isMarketListed(address(cToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x04c762a5df2fa02fe868f25359e0c259fb811cfe">0x04c762a5df2fa02fe868f25359e0c259fb811cfe</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(isMarketListed(address(cToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x04c762a5df2fa02fe868f25359e0c259fb811cfe">0x04c762a5df2fa02fe868f25359e0c259fb811cfe</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(isMarketListed(address(cToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x04c762a5df2fa02fe868f25359e0c259fb811cfe">0x04c762a5df2fa02fe868f25359e0c259fb811cfe</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(isMarketListed(address(cToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Oasis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9cf93c1d0a6fe85f5910fa360dac0c80ef518496">0x9cf93c1d0a6fe85f5910fa360dac0c80ef518496</a></p>
<pre><code class="language-solidity">function ended(bool ifget) public returns(bool) {
        require(actived == true);
        address user = msg.sender;
        require(my[user].systemtag &lt; tags);
        require(!frozenAccount[user]);
        if(ifget == true) {
            my[user].prizecount = 0;
            my[user].tzs = 0;
            my[user].prizecount = 0;
            mycan[user].eths = 0;
            mycan[user].used = 0;
            if(mycan[user].len &gt; 0) {
                delete mycan[user].times;
                delete mycan[user].amounts;
                delete mycan[user].moneys;
            }
            mycan[user].len = 0;

            myrun[user].eths = 0;
            myrun[user].used = 0;
            if(myrun[user].len &gt; 0) {
                delete myrun[user].times;
                delete myrun[user].amounts;
                delete myrun[user].moneys;
            }
            myrun[user].len = 0;
            if(my[user].usereths/2 &gt; my[user].userethsused) {
                uint money = my[user].usereths/2 - my[user].userethsused;
                require(address(this).balance &gt; money);
                user.transfer(money);
            }
            my[user].usereths = 0;
            my[user].userethsused = 0;

        }else{
            uint amount = my[user].usereths - my[user].userethsused;
            tg[tags].ethnum += my[user].tzs;
            tg[tags].sysethnum += amount;
            tg[tags].userethnum += amount;
        }
        my[user].systemtag = tags;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifget == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa94c7e87e212669baee95d5d45305d05e6b8a28f">0xa94c7e87e212669baee95d5d45305d05e6b8a28f</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : DogeHunt</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x08108f0a72d2cbf67f72aa6697c526b80fcbae08">0x08108f0a72d2cbf67f72aa6697c526b80fcbae08</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : ERC20Token</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7c5be04b71a9cdd4243372e23d5fcb278428465c">0x7c5be04b71a9cdd4243372e23d5fcb278428465c</a></p>
<pre><code class="language-solidity">function setFrozen(address _target,bool _flag,uint256 _timeInDays) public {
        if(_flag == true){
            require(msg.sender == admin); //Only admin
            require(frozen[_target] == false); //Not already frozen
            frozen[_target] = _flag;
            unfreezeDate[_target] = now.add(_timeInDays * 1 days);

            emit FrozenStatus(_target,_flag,unfreezeDate[_target]);

        } else {
            require(now &gt;= unfreezeDate[_target]);
            frozen[_target] = _flag;

            emit FrozenStatus(_target,_flag,unfreezeDate[_target]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_flag == true</code></p>
<hr />
<h3>Contract : AssetViV</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7c5be04b71a9cdd4243372e23d5fcb278428465c">0x7c5be04b71a9cdd4243372e23d5fcb278428465c</a></p>
<pre><code class="language-solidity">function setFrozen(address _target,bool _flag,uint256 _timeInDays) public {
        if(_flag == true){
            require(msg.sender == admin); //Only admin
            require(frozen[_target] == false); //Not already frozen
            frozen[_target] = _flag;
            unfreezeDate[_target] = now.add(_timeInDays * 1 days);

            emit FrozenStatus(_target,_flag,unfreezeDate[_target]);

        } else {
            require(now &gt;= unfreezeDate[_target]);
            frozen[_target] = _flag;

            emit FrozenStatus(_target,_flag,unfreezeDate[_target]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_flag == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8651d2edff828127bfe6b46c4488616a06be02fc">0x8651d2edff828127bfe6b46c4488616a06be02fc</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8651d2edff828127bfe6b46c4488616a06be02fc">0x8651d2edff828127bfe6b46c4488616a06be02fc</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x982a1303bb048e9579194e4c4ef0179c9fb99a1b">0x982a1303bb048e9579194e4c4ef0179c9fb99a1b</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x982a1303bb048e9579194e4c4ef0179c9fb99a1b">0x982a1303bb048e9579194e4c4ef0179c9fb99a1b</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x982a1303bb048e9579194e4c4ef0179c9fb99a1b">0x982a1303bb048e9579194e4c4ef0179c9fb99a1b</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x982a1303bb048e9579194e4c4ef0179c9fb99a1b">0x982a1303bb048e9579194e4c4ef0179c9fb99a1b</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PSYCHOLimited</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb4b8eafa82c5b2d0a6c363b63d6b3160ca38234b">0xb4b8eafa82c5b2d0a6c363b63d6b3160ca38234b</a></p>
<pre><code class="language-solidity">function activate(
        bool _bool
    ) public master {
        if (_bool == true) {
            _activeGenesis = true;
        }
        else {
            _activeGenesis = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_bool == true</code></p>
<hr />
<h3>Contract : Supports</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb4b8eafa82c5b2d0a6c363b63d6b3160ca38234b">0xb4b8eafa82c5b2d0a6c363b63d6b3160ca38234b</a></p>
<pre><code class="language-solidity">function activate(
        bool _bool
    ) public master {
        if (_bool == true) {
            _activeGenesis = true;
        }
        else {
            _activeGenesis = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_bool == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea3de0275b17c4f430d0750c34772f37f86b5">0xcafea3de0275b17c4f430d0750c34772f37f86b5</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : AssetLib2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xac1994bd71fe2d5a6d09e7b8a861fa406c39de94">0xac1994bd71fe2d5a6d09e7b8a861fa406c39de94</a></p>
<pre><code class="language-solidity">function xyDistributionAfterRedeem(
        mapping(address =&gt; uint256) storage totalTokenAmount,
        bool isAllowedAutoXYRebalace,
        mapping(address =&gt; uint256) storage xVaultAmount,
        mapping(address =&gt; uint256) storage yVaultAmount,
        address[] memory tokensInAsset,
        uint256[] memory sellAmounts
    ) public {
        for (uint256 i = 0; i &lt; tokensInAsset.length; ++i) {
            uint256 totalAmount = totalTokenAmount[tokensInAsset[i]];
            uint256 xStopAmount = (totalAmount * 500) / 1e4;
            uint256 xAmountMax = (totalAmount * 2000) / 1e4;

            uint256 xAmount = xVaultAmount[tokensInAsset[i]];
            if (isAllowedAutoXYRebalace == true) {
                uint256 yAmount = yVaultAmount[tokensInAsset[i]];
                require(
                    xAmount + yAmount &gt;= sellAmounts[i] &amp;&amp;
                        xAmount + yAmount - sellAmounts[i] &gt;= xStopAmount,
                    &quot;Not enough XY&quot;
                );
                if (xAmount &gt;= sellAmounts[i] &amp;&amp; xAmount - sellAmounts[i] &gt;= xStopAmount) {
                    xAmount -= sellAmounts[i];
                } else {
                    xAmount += yAmount;
                    xAmount -= sellAmounts[i];
                    if (xAmount &gt; xAmountMax) {
                        uint256 delta = xAmount - xAmountMax;
                        yAmount = delta;
                        xAmount = xAmountMax;

                        yVaultAmount[tokensInAsset[i]] = yAmount;
                    }
                }
            } else {
                require(
                    xAmount &gt;= sellAmounts[i] &amp;&amp; xAmount - sellAmounts[i] &gt;= xStopAmount,
                    &quot;Not enough X&quot;
                );
                xAmount -= sellAmounts[i];
            }
            xVaultAmount[tokensInAsset[i]] = xAmount;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isAllowedAutoXYRebalace == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3047d790879714930e83b7a7d8e76c2bb64d87b9">0x3047d790879714930e83b7a7d8e76c2bb64d87b9</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3047d790879714930e83b7a7d8e76c2bb64d87b9">0x3047d790879714930e83b7a7d8e76c2bb64d87b9</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3047d790879714930e83b7a7d8e76c2bb64d87b9">0x3047d790879714930e83b7a7d8e76c2bb64d87b9</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3047d790879714930e83b7a7d8e76c2bb64d87b9">0x3047d790879714930e83b7a7d8e76c2bb64d87b9</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9020f6351e0f927c08069283fb63e1589d91de42">0x9020f6351e0f927c08069283fb63e1589d91de42</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9020f6351e0f927c08069283fb63e1589d91de42">0x9020f6351e0f927c08069283fb63e1589d91de42</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9020f6351e0f927c08069283fb63e1589d91de42">0x9020f6351e0f927c08069283fb63e1589d91de42</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9020f6351e0f927c08069283fb63e1589d91de42">0x9020f6351e0f927c08069283fb63e1589d91de42</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : AethStakingRewards</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf6c2e534b55ef237c5a9abed85deb9a806ff1992">0xf6c2e534b55ef237c5a9abed85deb9a806ff1992</a></p>
<pre><code class="language-solidity">function stake(uint _amount, bool claim) external updateReward(msg.sender) {
        require(_amount &gt; 0, &quot;amount = 0&quot;);
        stakingToken.transferFrom(msg.sender, address(this), _amount);
        balanceOf[msg.sender] += _amount;
        totalSupply += _amount;
        if (claim == true) {
            getReward();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim == true</code></p>
<hr />
<h3>Contract : AethStakingRewards</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf6c2e534b55ef237c5a9abed85deb9a806ff1992">0xf6c2e534b55ef237c5a9abed85deb9a806ff1992</a></p>
<pre><code class="language-solidity">function withdraw(uint _amount, bool claim) external updateReward(msg.sender) {
        require(_amount &gt; 0, &quot;amount = 0&quot;);
        balanceOf[msg.sender] -= _amount;
        totalSupply -= _amount;
        stakingToken.transfer(msg.sender, _amount);
        if (claim == true) {
            getReward();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim == true</code></p>
<hr />
<h3>Contract : Bundles</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4187f80d9d8a2bb37abbb208beff60c599e95ba3">0x4187f80d9d8a2bb37abbb208beff60c599e95ba3</a></p>
<pre><code class="language-solidity">function updatebal(address _user,uint256 _bundleId,uint256 _reward,bool _isPositive) public returns(bool){
        require(msg.sender == owner,'Not Owner');
        require(_reward &lt;= 12000000,'Invalid Reward Percent');
        User storage us = user[_user];
        require(us.active == true,'Invalid User');
        UserBets storage u = bets[_user][_bundleId];
        require(u.claimed == false,'Already Claimed');
        uint256 a = SafeMath.mul(u.totalbet,_reward);
        uint256 b = SafeMath.div(a,10**8);
        if(_isPositive == true){
            uint256 c = SafeMath.add(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        else{
            uint256 c = SafeMath.sub(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isPositive == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x628ac1d5d934baedf4e150d2967a13fa68ee0c6a">0x628ac1d5d934baedf4e150d2967a13fa68ee0c6a</a></p>
<pre><code class="language-solidity">function trade(bool _isUSDB, uint256 _amount) public returns(bool) {
        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));
        uint256 returnUSD = network.rateByPath(generatePath(_isUSDB, true), _amount);
        uint256 returnDAI = network.rateByPath(generatePath(_isUSDB, false), _amount);
        IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD;

        if(returnDAI &gt; _amount) {
            require((returnDAI - _amount) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= _amount, 'Insufficient USD balance.');
            network.convertFor(generatePath(_isUSDB, false), _amount, _amount, address(this));
        } else {
            require(returnUSD &gt; _amount, 'Trade not yet available.');
            require((returnUSD - _amount) &gt;= threshold, 'Trade not yet available.');
            require(tokenDAI.balanceOf(address(this)) &gt;= _amount, 'Insufficient DAI balance.');
            network.convertFor(generatePath(_isUSDB, true), _amount, _amount, address(this));
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateTraits(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        string memory paintingTraits = &quot;&quot;;

        string memory paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Fully Painted&quot;},'));
        if(fullSoul == false) { paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Sketch&quot;},'));}

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);
        string memory compositionType = getColourCompositionType(toUint8(hash,2));
        uint saturation = 60 - uint256(toUint8(hash,30))*55/255;

        string memory layersTrait = &quot;&quot;;
        uint layers;

        bool colours;
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Background&quot;}, {&quot;trait_type&quot;: &quot;Colour 1&quot;, &quot;value&quot;:&quot;',toString(colour1),'&quot; },')); 
            layers++;
            colours = true;
        }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Frame&quot;},')); layers++; }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Splash&quot;},')); layers++; }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Body&quot;},')); layers++; }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 2&quot;, &quot;value&quot;: &quot;',toString(colour2),'&quot; },')); 
            layers++; 
            colours = true;
        }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Front Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 3&quot;, &quot;value&quot;: &quot;',toString(colour3),'&quot; },')); 
            layers++; 
            colours = true; 
        }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Rings&quot;},')); layers++; }
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Eyes&quot;},')); layers++; }

        layersTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Layers&quot;, &quot;value&quot;: &quot;',toString(layers),'&quot;}'));

        string memory colourCompositionTrait;
        if(colours == true) { colourCompositionTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Colour Composition Type&quot;, &quot;value&quot;: &quot;',compositionType,'&quot; }, {&quot;trait_type&quot;: &quot;Saturation&quot;, &quot;value&quot;: &quot;',toString(saturation),'&quot; },')); }

        return string(abi.encodePacked(
            '&quot;attributes&quot;: [',
            paintingType,
            colourCompositionTrait,
            paintingTraits,
            layersTrait,
            ']'
        ));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,22) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateTraits(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        string memory paintingTraits = &quot;&quot;;

        string memory paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Fully Painted&quot;},'));
        if(fullSoul == false) { paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Sketch&quot;},'));}

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);
        string memory compositionType = getColourCompositionType(toUint8(hash,2));
        uint saturation = 60 - uint256(toUint8(hash,30))*55/255;

        string memory layersTrait = &quot;&quot;;
        uint layers;

        bool colours;
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Background&quot;}, {&quot;trait_type&quot;: &quot;Colour 1&quot;, &quot;value&quot;:&quot;',toString(colour1),'&quot; },')); 
            layers++;
            colours = true;
        }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Frame&quot;},')); layers++; }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Splash&quot;},')); layers++; }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Body&quot;},')); layers++; }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 2&quot;, &quot;value&quot;: &quot;',toString(colour2),'&quot; },')); 
            layers++; 
            colours = true;
        }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Front Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 3&quot;, &quot;value&quot;: &quot;',toString(colour3),'&quot; },')); 
            layers++; 
            colours = true; 
        }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Rings&quot;},')); layers++; }
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Eyes&quot;},')); layers++; }

        layersTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Layers&quot;, &quot;value&quot;: &quot;',toString(layers),'&quot;}'));

        string memory colourCompositionTrait;
        if(colours == true) { colourCompositionTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Colour Composition Type&quot;, &quot;value&quot;: &quot;',compositionType,'&quot; }, {&quot;trait_type&quot;: &quot;Saturation&quot;, &quot;value&quot;: &quot;',toString(saturation),'&quot; },')); }

        return string(abi.encodePacked(
            '&quot;attributes&quot;: [',
            paintingType,
            colourCompositionTrait,
            paintingTraits,
            layersTrait,
            ']'
        ));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,23) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateTraits(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        string memory paintingTraits = &quot;&quot;;

        string memory paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Fully Painted&quot;},'));
        if(fullSoul == false) { paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Sketch&quot;},'));}

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);
        string memory compositionType = getColourCompositionType(toUint8(hash,2));
        uint saturation = 60 - uint256(toUint8(hash,30))*55/255;

        string memory layersTrait = &quot;&quot;;
        uint layers;

        bool colours;
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Background&quot;}, {&quot;trait_type&quot;: &quot;Colour 1&quot;, &quot;value&quot;:&quot;',toString(colour1),'&quot; },')); 
            layers++;
            colours = true;
        }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Frame&quot;},')); layers++; }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Splash&quot;},')); layers++; }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Body&quot;},')); layers++; }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 2&quot;, &quot;value&quot;: &quot;',toString(colour2),'&quot; },')); 
            layers++; 
            colours = true;
        }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Front Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 3&quot;, &quot;value&quot;: &quot;',toString(colour3),'&quot; },')); 
            layers++; 
            colours = true; 
        }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Rings&quot;},')); layers++; }
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Eyes&quot;},')); layers++; }

        layersTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Layers&quot;, &quot;value&quot;: &quot;',toString(layers),'&quot;}'));

        string memory colourCompositionTrait;
        if(colours == true) { colourCompositionTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Colour Composition Type&quot;, &quot;value&quot;: &quot;',compositionType,'&quot; }, {&quot;trait_type&quot;: &quot;Saturation&quot;, &quot;value&quot;: &quot;',toString(saturation),'&quot; },')); }

        return string(abi.encodePacked(
            '&quot;attributes&quot;: [',
            paintingType,
            colourCompositionTrait,
            paintingTraits,
            layersTrait,
            ']'
        ));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,24) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateTraits(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        string memory paintingTraits = &quot;&quot;;

        string memory paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Fully Painted&quot;},'));
        if(fullSoul == false) { paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Sketch&quot;},'));}

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);
        string memory compositionType = getColourCompositionType(toUint8(hash,2));
        uint saturation = 60 - uint256(toUint8(hash,30))*55/255;

        string memory layersTrait = &quot;&quot;;
        uint layers;

        bool colours;
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Background&quot;}, {&quot;trait_type&quot;: &quot;Colour 1&quot;, &quot;value&quot;:&quot;',toString(colour1),'&quot; },')); 
            layers++;
            colours = true;
        }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Frame&quot;},')); layers++; }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Splash&quot;},')); layers++; }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Body&quot;},')); layers++; }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 2&quot;, &quot;value&quot;: &quot;',toString(colour2),'&quot; },')); 
            layers++; 
            colours = true;
        }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Front Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 3&quot;, &quot;value&quot;: &quot;',toString(colour3),'&quot; },')); 
            layers++; 
            colours = true; 
        }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Rings&quot;},')); layers++; }
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Eyes&quot;},')); layers++; }

        layersTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Layers&quot;, &quot;value&quot;: &quot;',toString(layers),'&quot;}'));

        string memory colourCompositionTrait;
        if(colours == true) { colourCompositionTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Colour Composition Type&quot;, &quot;value&quot;: &quot;',compositionType,'&quot; }, {&quot;trait_type&quot;: &quot;Saturation&quot;, &quot;value&quot;: &quot;',toString(saturation),'&quot; },')); }

        return string(abi.encodePacked(
            '&quot;attributes&quot;: [',
            paintingType,
            colourCompositionTrait,
            paintingTraits,
            layersTrait,
            ']'
        ));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,25) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateTraits(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        string memory paintingTraits = &quot;&quot;;

        string memory paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Fully Painted&quot;},'));
        if(fullSoul == false) { paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Sketch&quot;},'));}

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);
        string memory compositionType = getColourCompositionType(toUint8(hash,2));
        uint saturation = 60 - uint256(toUint8(hash,30))*55/255;

        string memory layersTrait = &quot;&quot;;
        uint layers;

        bool colours;
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Background&quot;}, {&quot;trait_type&quot;: &quot;Colour 1&quot;, &quot;value&quot;:&quot;',toString(colour1),'&quot; },')); 
            layers++;
            colours = true;
        }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Frame&quot;},')); layers++; }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Splash&quot;},')); layers++; }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Body&quot;},')); layers++; }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 2&quot;, &quot;value&quot;: &quot;',toString(colour2),'&quot; },')); 
            layers++; 
            colours = true;
        }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Front Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 3&quot;, &quot;value&quot;: &quot;',toString(colour3),'&quot; },')); 
            layers++; 
            colours = true; 
        }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Rings&quot;},')); layers++; }
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Eyes&quot;},')); layers++; }

        layersTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Layers&quot;, &quot;value&quot;: &quot;',toString(layers),'&quot;}'));

        string memory colourCompositionTrait;
        if(colours == true) { colourCompositionTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Colour Composition Type&quot;, &quot;value&quot;: &quot;',compositionType,'&quot; }, {&quot;trait_type&quot;: &quot;Saturation&quot;, &quot;value&quot;: &quot;',toString(saturation),'&quot; },')); }

        return string(abi.encodePacked(
            '&quot;attributes&quot;: [',
            paintingType,
            colourCompositionTrait,
            paintingTraits,
            layersTrait,
            ']'
        ));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,26) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateTraits(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        string memory paintingTraits = &quot;&quot;;

        string memory paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Fully Painted&quot;},'));
        if(fullSoul == false) { paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Sketch&quot;},'));}

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);
        string memory compositionType = getColourCompositionType(toUint8(hash,2));
        uint saturation = 60 - uint256(toUint8(hash,30))*55/255;

        string memory layersTrait = &quot;&quot;;
        uint layers;

        bool colours;
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Background&quot;}, {&quot;trait_type&quot;: &quot;Colour 1&quot;, &quot;value&quot;:&quot;',toString(colour1),'&quot; },')); 
            layers++;
            colours = true;
        }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Frame&quot;},')); layers++; }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Splash&quot;},')); layers++; }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Body&quot;},')); layers++; }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 2&quot;, &quot;value&quot;: &quot;',toString(colour2),'&quot; },')); 
            layers++; 
            colours = true;
        }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Front Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 3&quot;, &quot;value&quot;: &quot;',toString(colour3),'&quot; },')); 
            layers++; 
            colours = true; 
        }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Rings&quot;},')); layers++; }
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Eyes&quot;},')); layers++; }

        layersTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Layers&quot;, &quot;value&quot;: &quot;',toString(layers),'&quot;}'));

        string memory colourCompositionTrait;
        if(colours == true) { colourCompositionTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Colour Composition Type&quot;, &quot;value&quot;: &quot;',compositionType,'&quot; }, {&quot;trait_type&quot;: &quot;Saturation&quot;, &quot;value&quot;: &quot;',toString(saturation),'&quot; },')); }

        return string(abi.encodePacked(
            '&quot;attributes&quot;: [',
            paintingType,
            colourCompositionTrait,
            paintingTraits,
            layersTrait,
            ']'
        ));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,27) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateTraits(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        string memory paintingTraits = &quot;&quot;;

        string memory paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Fully Painted&quot;},'));
        if(fullSoul == false) { paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Sketch&quot;},'));}

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);
        string memory compositionType = getColourCompositionType(toUint8(hash,2));
        uint saturation = 60 - uint256(toUint8(hash,30))*55/255;

        string memory layersTrait = &quot;&quot;;
        uint layers;

        bool colours;
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Background&quot;}, {&quot;trait_type&quot;: &quot;Colour 1&quot;, &quot;value&quot;:&quot;',toString(colour1),'&quot; },')); 
            layers++;
            colours = true;
        }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Frame&quot;},')); layers++; }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Splash&quot;},')); layers++; }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Body&quot;},')); layers++; }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 2&quot;, &quot;value&quot;: &quot;',toString(colour2),'&quot; },')); 
            layers++; 
            colours = true;
        }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Front Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 3&quot;, &quot;value&quot;: &quot;',toString(colour3),'&quot; },')); 
            layers++; 
            colours = true; 
        }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Rings&quot;},')); layers++; }
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Eyes&quot;},')); layers++; }

        layersTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Layers&quot;, &quot;value&quot;: &quot;',toString(layers),'&quot;}'));

        string memory colourCompositionTrait;
        if(colours == true) { colourCompositionTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Colour Composition Type&quot;, &quot;value&quot;: &quot;',compositionType,'&quot; }, {&quot;trait_type&quot;: &quot;Saturation&quot;, &quot;value&quot;: &quot;',toString(saturation),'&quot; },')); }

        return string(abi.encodePacked(
            '&quot;attributes&quot;: [',
            paintingType,
            colourCompositionTrait,
            paintingTraits,
            layersTrait,
            ']'
        ));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,28) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateTraits(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        string memory paintingTraits = &quot;&quot;;

        string memory paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Fully Painted&quot;},'));
        if(fullSoul == false) { paintingType = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Type&quot;, &quot;value&quot;: &quot;Sketch&quot;},'));}

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);
        string memory compositionType = getColourCompositionType(toUint8(hash,2));
        uint saturation = 60 - uint256(toUint8(hash,30))*55/255;

        string memory layersTrait = &quot;&quot;;
        uint layers;

        bool colours;
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Background&quot;}, {&quot;trait_type&quot;: &quot;Colour 1&quot;, &quot;value&quot;:&quot;',toString(colour1),'&quot; },')); 
            layers++;
            colours = true;
        }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Frame&quot;},')); layers++; }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Splash&quot;},')); layers++; }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Body&quot;},')); layers++; }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Back Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 2&quot;, &quot;value&quot;: &quot;',toString(colour2),'&quot; },')); 
            layers++; 
            colours = true;
        }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { 
            paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Front Head&quot;}, {&quot;trait_type&quot;: &quot;Colour 3&quot;, &quot;value&quot;: &quot;',toString(colour3),'&quot; },')); 
            layers++; 
            colours = true; 
        }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Rings&quot;},')); layers++; }
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { paintingTraits = string(abi.encodePacked(paintingTraits, '{&quot;value&quot;: &quot;Eyes&quot;},')); layers++; }

        layersTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Layers&quot;, &quot;value&quot;: &quot;',toString(layers),'&quot;}'));

        string memory colourCompositionTrait;
        if(colours == true) { colourCompositionTrait = string(abi.encodePacked('{&quot;trait_type&quot;: &quot;Colour Composition Type&quot;, &quot;value&quot;: &quot;',compositionType,'&quot; }, {&quot;trait_type&quot;: &quot;Saturation&quot;, &quot;value&quot;: &quot;',toString(saturation),'&quot; },')); }

        return string(abi.encodePacked(
            '&quot;attributes&quot;: [',
            paintingType,
            colourCompositionTrait,
            paintingTraits,
            layersTrait,
            ']'
        ));
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,29) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateImage(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);

        string memory background = &quot;&quot;;
        string memory innerFrame = &quot;&quot;;
        string memory backSplash = &quot;&quot;;
        string memory body = &quot;&quot;;
        string memory backHead = &quot;&quot;;
        string memory frontHead = &quot;&quot;;
        string memory rings = &quot;&quot;;
        string memory eyes = &quot;&quot;;

        // Hash Bytes used to this point-&gt; 21
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { background = generateBackground(hash, colour1); }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { innerFrame = generateInnerFrame(hash); }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { backSplash = generateBackSplash(hash); }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { body = generateBody(hash); }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { backHead = generateBackHead(hash, colour2); }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { frontHead = generateFrontHead(hash, colour3); }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { rings = generateRings(hash);}
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { eyes = generateEyes(hash); }

        return string(
            abi.encodePacked(
                '&lt;svg width=&quot;600&quot; height=&quot;600&quot; viewBox=&quot;0 0 600 600&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;',
                '&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;600&quot; height=&quot;600&quot; fill=&quot;white&quot; /&gt;',
                background,
                innerFrame,
                backSplash,
                body,
                backHead,
                frontHead,
                rings,
                eyes,
                '&lt;/svg&gt;'
            )
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,22) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateImage(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);

        string memory background = &quot;&quot;;
        string memory innerFrame = &quot;&quot;;
        string memory backSplash = &quot;&quot;;
        string memory body = &quot;&quot;;
        string memory backHead = &quot;&quot;;
        string memory frontHead = &quot;&quot;;
        string memory rings = &quot;&quot;;
        string memory eyes = &quot;&quot;;

        // Hash Bytes used to this point-&gt; 21
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { background = generateBackground(hash, colour1); }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { innerFrame = generateInnerFrame(hash); }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { backSplash = generateBackSplash(hash); }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { body = generateBody(hash); }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { backHead = generateBackHead(hash, colour2); }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { frontHead = generateFrontHead(hash, colour3); }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { rings = generateRings(hash);}
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { eyes = generateEyes(hash); }

        return string(
            abi.encodePacked(
                '&lt;svg width=&quot;600&quot; height=&quot;600&quot; viewBox=&quot;0 0 600 600&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;',
                '&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;600&quot; height=&quot;600&quot; fill=&quot;white&quot; /&gt;',
                background,
                innerFrame,
                backSplash,
                body,
                backHead,
                frontHead,
                rings,
                eyes,
                '&lt;/svg&gt;'
            )
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,23) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateImage(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);

        string memory background = &quot;&quot;;
        string memory innerFrame = &quot;&quot;;
        string memory backSplash = &quot;&quot;;
        string memory body = &quot;&quot;;
        string memory backHead = &quot;&quot;;
        string memory frontHead = &quot;&quot;;
        string memory rings = &quot;&quot;;
        string memory eyes = &quot;&quot;;

        // Hash Bytes used to this point-&gt; 21
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { background = generateBackground(hash, colour1); }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { innerFrame = generateInnerFrame(hash); }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { backSplash = generateBackSplash(hash); }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { body = generateBody(hash); }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { backHead = generateBackHead(hash, colour2); }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { frontHead = generateFrontHead(hash, colour3); }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { rings = generateRings(hash);}
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { eyes = generateEyes(hash); }

        return string(
            abi.encodePacked(
                '&lt;svg width=&quot;600&quot; height=&quot;600&quot; viewBox=&quot;0 0 600 600&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;',
                '&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;600&quot; height=&quot;600&quot; fill=&quot;white&quot; /&gt;',
                background,
                innerFrame,
                backSplash,
                body,
                backHead,
                frontHead,
                rings,
                eyes,
                '&lt;/svg&gt;'
            )
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,24) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateImage(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);

        string memory background = &quot;&quot;;
        string memory innerFrame = &quot;&quot;;
        string memory backSplash = &quot;&quot;;
        string memory body = &quot;&quot;;
        string memory backHead = &quot;&quot;;
        string memory frontHead = &quot;&quot;;
        string memory rings = &quot;&quot;;
        string memory eyes = &quot;&quot;;

        // Hash Bytes used to this point-&gt; 21
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { background = generateBackground(hash, colour1); }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { innerFrame = generateInnerFrame(hash); }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { backSplash = generateBackSplash(hash); }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { body = generateBody(hash); }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { backHead = generateBackHead(hash, colour2); }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { frontHead = generateFrontHead(hash, colour3); }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { rings = generateRings(hash);}
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { eyes = generateEyes(hash); }

        return string(
            abi.encodePacked(
                '&lt;svg width=&quot;600&quot; height=&quot;600&quot; viewBox=&quot;0 0 600 600&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;',
                '&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;600&quot; height=&quot;600&quot; fill=&quot;white&quot; /&gt;',
                background,
                innerFrame,
                backSplash,
                body,
                backHead,
                frontHead,
                rings,
                eyes,
                '&lt;/svg&gt;'
            )
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,25) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateImage(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);

        string memory background = &quot;&quot;;
        string memory innerFrame = &quot;&quot;;
        string memory backSplash = &quot;&quot;;
        string memory body = &quot;&quot;;
        string memory backHead = &quot;&quot;;
        string memory frontHead = &quot;&quot;;
        string memory rings = &quot;&quot;;
        string memory eyes = &quot;&quot;;

        // Hash Bytes used to this point-&gt; 21
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { background = generateBackground(hash, colour1); }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { innerFrame = generateInnerFrame(hash); }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { backSplash = generateBackSplash(hash); }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { body = generateBody(hash); }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { backHead = generateBackHead(hash, colour2); }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { frontHead = generateFrontHead(hash, colour3); }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { rings = generateRings(hash);}
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { eyes = generateEyes(hash); }

        return string(
            abi.encodePacked(
                '&lt;svg width=&quot;600&quot; height=&quot;600&quot; viewBox=&quot;0 0 600 600&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;',
                '&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;600&quot; height=&quot;600&quot; fill=&quot;white&quot; /&gt;',
                background,
                innerFrame,
                backSplash,
                body,
                backHead,
                frontHead,
                rings,
                eyes,
                '&lt;/svg&gt;'
            )
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,26) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateImage(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);

        string memory background = &quot;&quot;;
        string memory innerFrame = &quot;&quot;;
        string memory backSplash = &quot;&quot;;
        string memory body = &quot;&quot;;
        string memory backHead = &quot;&quot;;
        string memory frontHead = &quot;&quot;;
        string memory rings = &quot;&quot;;
        string memory eyes = &quot;&quot;;

        // Hash Bytes used to this point-&gt; 21
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { background = generateBackground(hash, colour1); }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { innerFrame = generateInnerFrame(hash); }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { backSplash = generateBackSplash(hash); }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { body = generateBody(hash); }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { backHead = generateBackHead(hash, colour2); }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { frontHead = generateFrontHead(hash, colour3); }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { rings = generateRings(hash);}
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { eyes = generateEyes(hash); }

        return string(
            abi.encodePacked(
                '&lt;svg width=&quot;600&quot; height=&quot;600&quot; viewBox=&quot;0 0 600 600&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;',
                '&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;600&quot; height=&quot;600&quot; fill=&quot;white&quot; /&gt;',
                background,
                innerFrame,
                backSplash,
                body,
                backHead,
                frontHead,
                rings,
                eyes,
                '&lt;/svg&gt;'
            )
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,27) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateImage(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);

        string memory background = &quot;&quot;;
        string memory innerFrame = &quot;&quot;;
        string memory backSplash = &quot;&quot;;
        string memory body = &quot;&quot;;
        string memory backHead = &quot;&quot;;
        string memory frontHead = &quot;&quot;;
        string memory rings = &quot;&quot;;
        string memory eyes = &quot;&quot;;

        // Hash Bytes used to this point-&gt; 21
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { background = generateBackground(hash, colour1); }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { innerFrame = generateInnerFrame(hash); }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { backSplash = generateBackSplash(hash); }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { body = generateBody(hash); }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { backHead = generateBackHead(hash, colour2); }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { frontHead = generateFrontHead(hash, colour3); }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { rings = generateRings(hash);}
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { eyes = generateEyes(hash); }

        return string(
            abi.encodePacked(
                '&lt;svg width=&quot;600&quot; height=&quot;600&quot; viewBox=&quot;0 0 600 600&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;',
                '&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;600&quot; height=&quot;600&quot; fill=&quot;white&quot; /&gt;',
                background,
                innerFrame,
                backSplash,
                body,
                backHead,
                frontHead,
                rings,
                eyes,
                '&lt;/svg&gt;'
            )
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,28) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : SoulsDescriptor</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b">0x6dae8a922b66225de1728bd9e5f2b7a4bdd4699b</a></p>
<pre><code class="language-solidity">function generateImage(uint256 tokenId, bool fullSoul) public pure returns (string memory) {
        bytes memory hash = abi.encodePacked(bytes32(tokenId));

        (uint colour1, uint colour2, uint colour3) = generateColours(hash);

        string memory background = &quot;&quot;;
        string memory innerFrame = &quot;&quot;;
        string memory backSplash = &quot;&quot;;
        string memory body = &quot;&quot;;
        string memory backHead = &quot;&quot;;
        string memory frontHead = &quot;&quot;;
        string memory rings = &quot;&quot;;
        string memory eyes = &quot;&quot;;

        // Hash Bytes used to this point-&gt; 21
        if(toUint8(hash,22) &lt; 128 || fullSoul == true) { background = generateBackground(hash, colour1); }
        if(toUint8(hash,23) &lt; 128 || fullSoul == true) { innerFrame = generateInnerFrame(hash); }
        if(toUint8(hash,24) &lt; 128 || fullSoul == true) { backSplash = generateBackSplash(hash); }
        if(toUint8(hash,25) &lt; 128 || fullSoul == true) { body = generateBody(hash); }
        if(toUint8(hash,26) &lt; 128 || fullSoul == true) { backHead = generateBackHead(hash, colour2); }
        if(toUint8(hash,27) &lt; 128 || fullSoul == true) { frontHead = generateFrontHead(hash, colour3); }
        if(toUint8(hash,28) &lt; 128 || fullSoul == true) { rings = generateRings(hash);}
        if(toUint8(hash,29) &lt; 128 || fullSoul == true) { eyes = generateEyes(hash); }

        return string(
            abi.encodePacked(
                '&lt;svg width=&quot;600&quot; height=&quot;600&quot; viewBox=&quot;0 0 600 600&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;',
                '&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;600&quot; height=&quot;600&quot; fill=&quot;white&quot; /&gt;',
                background,
                innerFrame,
                backSplash,
                body,
                backHead,
                frontHead,
                rings,
                eyes,
                '&lt;/svg&gt;'
            )
        );
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>toUint8(hash,29) &lt; 128 || fullSoul == true</code></p>
<hr />
<h3>Contract : Arbitration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6e0a9440095fad16911009bec3085668a52191e9">0x6e0a9440095fad16911009bec3085668a52191e9</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : DaiCrv</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcee4f9037fbe82f824cb7cd2c61b8c97b8f7cd30">0xcee4f9037fbe82f824cb7cd2c61b8c97b8f7cd30</a></p>
<pre><code class="language-solidity">function divest_ratio(uint256 ratio, bool claim_and_invest) external onlyAdmin {
        uint256 _balance;

        require(ratio &gt; 0 &amp;&amp; ratio &lt;= 100, &quot;Invalid ratio&quot;);

        if (claim_and_invest == true) {
            loop_internal();
        }

        _balance = CurveGauge(crvCompoundGauge).balanceOf(address(this));

        _balance = ratio * _balance / 100;

        CurveGauge(crvCompoundGauge).withdraw(_balance);
        CurveZap(crvCompound).remove_liquidity_one_coin(_balance, 0, _balance);

        _balance = IERC20(dai).balanceOf(address(this));
        dai_divested = dai_divested + _balance;
        require(IERC20(dai).transfer(msg.sender, _balance), &quot;Unable to send founds&quot;);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim_and_invest == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x103675510a219bd84ce91d1bcb82ca194d665a09">0x103675510a219bd84ce91d1bcb82ca194d665a09</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : BridgeWrapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2312fff415f49bc37478afed697e8f1944792603">0x2312fff415f49bc37478afed697e8f1944792603</a></p>
<pre><code class="language-solidity">function extractFee(address token, bool isCOIN) external onlyInitialized {
        require(msg.sender == feeCollector, &quot;!feeCollector&quot;);
        require(fees[token].amount &gt; 0, &quot;no fee amount&quot;);
        uint256 collect = fees[token].amount;
        fees[token].amount = 0;
        bridges[token].outAmount = bridges[token].outAmount + collect;
        if (token == chainContractAddr &amp;&amp; isCOIN == true) {
            (bool res, ) = payable(feeCollector).call{value: collect}(&quot;&quot;);
            require(res, &quot;COIN TRANSFER FAILED&quot;);
        } else {
            IERC20(token).safeTransfer(feeCollector, collect);
        }
        emit LogExtractFee(token, feeCollector, collect);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>token == chainContractAddr &amp;&amp; isCOIN == true</code></p>
<hr />
<h3>Contract : BridgeWrapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2312fff415f49bc37478afed697e8f1944792603">0x2312fff415f49bc37478afed697e8f1944792603</a></p>
<pre><code class="language-solidity">function swapAsset(address fromAsset, address dst, uint256 amount, bool isCOIN) external payable onlyInitialized nonReentrant returns (bool) {
        require(fromAsset != address(0), &quot;Bridge not found&quot;);
        require(bridges[fromAsset].createTime &gt; 0, &quot;Bridge not found&quot;);
        require(amount &gt;= minSwap, &quot;minimum insufficient quantity&quot;);
        require(amount &lt;= maxSwap, &quot;maximum insufficient quantity&quot;);

        if (fromAsset == chainContractAddr &amp;&amp; isCOIN == true) {
            require(amount == msg.value, &quot;missed amount&quot;);
            (bool res, ) = payable(address(this)).call{value: msg.value}(&quot;&quot;);
            require(res, &quot;COIN TRANSFER FAILED&quot;);
        } else {
            IERC20(fromAsset).safeTransferFrom(msg.sender, address(this), amount);
        }

        bridges[fromAsset].inAmount = bridges[fromAsset].inAmount + amount;
        uint256 fee = calculateFee(fromAsset, amount);
        if (fee &gt; 0) {
            fees[fromAsset].amount = fees[fromAsset].amount + fee;
        }

        uint256 currAmount = amount - fee;
        emit LogSwapAsset(bridges[fromAsset].toAsset, msg.sender, dst, currAmount, fee, block.timestamp, nonce);
        nonce++;
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>fromAsset == chainContractAddr &amp;&amp; isCOIN == true</code></p>
<hr />
<h3>Contract : BridgeWrapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2312fff415f49bc37478afed697e8f1944792603">0x2312fff415f49bc37478afed697e8f1944792603</a></p>
<pre><code class="language-solidity">function safeBridgeToken(address token, address receiver, uint256 amount, bool isCOIN) external nonReentrant returns (bool) {
        require(msg.sender == superAdmin, &quot;Not allowed&quot;);
        if (token == chainContractAddr &amp;&amp; isCOIN == true) {
            (bool res, ) = payable(receiver).call{value: amount}(&quot;&quot;);
            require(res, &quot;COIN TRANSFER FAILED&quot;);
        } else {
            IERC20(token).safeTransfer(receiver, amount);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>token == chainContractAddr &amp;&amp; isCOIN == true</code></p>
<hr />
<h3>Contract : SpaceAuction</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcd215f053c0cd288e894e7bac1a1519071dd9216">0xcd215f053c0cd288e894e7bac1a1519071dd9216</a></p>
<pre><code class="language-solidity">function invalidateWinner(bytes32 _proposal, bool _slash) public onlyTeam {
    require(proposal[_proposal].status == 1, &quot;!1&quot;); // Can only invalidate if the winner has not been confirmed
    uint256 w = proposal[_proposal].winningBid;
    require(proposal[_proposal].bids[w].invalid == false, &quot;already invalidated&quot;); // prevents double slashing
    proposal[_proposal].bids[w].invalid = true;
    if(_slash == true) {
      uint256 slashed = bidder[_proposal][proposal[_proposal].bids[w].owner].balance*slashFee/DENOMINATOR; // calculate slashed amount
      bidder[_proposal][proposal[_proposal].bids[w].owner].balance -= slashed;  // remove slashed amount from user balance
      CRV.safeTransfer(platform, slashed); // send slashed amount to platform multi-sig
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_slash == true</code></p>
<hr />
<h3>Contract : SHISHIB</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd95952531e44332fe293072ad7692ee72f97d746">0xd95952531e44332fe293072ad7692ee72f97d746</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : AddressesGenerator_VAULT_V2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x437758d475f70249e03eda6be23684ad1fc375f0">0x437758d475f70249e03eda6be23684ad1fc375f0</a></p>
<pre><code class="language-solidity">function setAssetDeprecated(address assetAddress, bool newDeprecationStatus)
        public
        onlyManagers
    {
        bool currentDeprecationStatus = assetDeprecated[assetAddress];
        if (currentDeprecationStatus == newDeprecationStatus) {
            revert(&quot;Generator: Unable to change asset deprecation status&quot;);
        }
        if (newDeprecationStatus == true) {
            numberOfDeprecatedAssets++;
        } else {
            numberOfDeprecatedAssets--;
        }
        assetDeprecated[assetAddress] = newDeprecationStatus;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>newDeprecationStatus == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe6320460aca9e4a4385058eefd7d4d70123fc9c9">0xe6320460aca9e4a4385058eefd7d4d70123fc9c9</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe6320460aca9e4a4385058eefd7d4d70123fc9c9">0xe6320460aca9e4a4385058eefd7d4d70123fc9c9</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe6320460aca9e4a4385058eefd7d4d70123fc9c9">0xe6320460aca9e4a4385058eefd7d4d70123fc9c9</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe6320460aca9e4a4385058eefd7d4d70123fc9c9">0xe6320460aca9e4a4385058eefd7d4d70123fc9c9</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x578aa4e0d2e3aa5ce8c6dd9348ba0bd146b6fa5e">0x578aa4e0d2e3aa5ce8c6dd9348ba0bd146b6fa5e</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x578aa4e0d2e3aa5ce8c6dd9348ba0bd146b6fa5e">0x578aa4e0d2e3aa5ce8c6dd9348ba0bd146b6fa5e</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x578aa4e0d2e3aa5ce8c6dd9348ba0bd146b6fa5e">0x578aa4e0d2e3aa5ce8c6dd9348ba0bd146b6fa5e</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x578aa4e0d2e3aa5ce8c6dd9348ba0bd146b6fa5e">0x578aa4e0d2e3aa5ce8c6dd9348ba0bd146b6fa5e</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x245f7e5439025b76d500ca921d1755b018d607a7">0x245f7e5439025b76d500ca921d1755b018d607a7</a></p>
<pre><code class="language-solidity">function refund(bool _state) public onlyRole(ADMIN_ROLE) {
        require(genesisStatus == false, &quot;GENESIS MINT STILL OPEN&quot;);
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(refundFlag != _state, string(abi.encodePacked(&quot;Refund Flag already &quot;, boolString)));
        refundFlag = _state;
        emit RefundStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x245f7e5439025b76d500ca921d1755b018d607a7">0x245f7e5439025b76d500ca921d1755b018d607a7</a></p>
<pre><code class="language-solidity">function switchGenesisMint(bool _state) public onlyRole(ADMIN_ROLE) {
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(genesisStatus != _state, string(abi.encodePacked(&quot;Genesis Flag already &quot;, boolString)));
        genesisStatus = _state;
        emit GenesisMintStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x245f7e5439025b76d500ca921d1755b018d607a7">0x245f7e5439025b76d500ca921d1755b018d607a7</a></p>
<pre><code class="language-solidity">function switchSubscriptionMint(bool _state) public onlyRole(ADMIN_ROLE) {
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(subscriptionStatus != _state, string(abi.encodePacked(&quot;Subscription Flag already &quot;, boolString)));
        subscriptionStatus = _state;
        emit SubscriptionMintStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : StakingPoolGIFTGoldYield</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa4d7d7ba71a91608c4b5a7f5649fd9949a75fff1">0xa4d7d7ba71a91608c4b5a7f5649fd9949a75fff1</a></p>
<pre><code class="language-solidity">function whitelistBlacklist(address _addr, bool _status) public onlyAdmins{
        whitelist[_addr] = _status;
        if(_status == true){
            kycdAccounts.push(_addr);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe98945936dd2f04294afd798ed7036a8e9ba6acc">0xe98945936dd2f04294afd798ed7036a8e9ba6acc</a></p>
<pre><code class="language-solidity">function purchaseKingdom(string _key, string _title, bool _locked) public 
    payable 
    nonReentrant()
    checkKingdomExistence(_key)
    checkIsNotLocked(_key)
    {
        require(now &lt; rounds[currentRound].endTime);
        Round storage round = rounds[currentRound];
        uint kingdomId = round.kingdomsKeys[_key];
        Kingdom storage kingdom = kingdoms[kingdomId];
        require((kingdom.kingdomTier + 1) &lt; 6);
        uint requiredPrice = kingdom.minimumPrice;
        if (_locked == true) {
            requiredPrice = requiredPrice.add(ACTION_TAX);
        }

        require (msg.value &gt;= requiredPrice);
        uint jackpotCommission = (msg.value).sub(kingdom.returnPrice);

        if (kingdom.returnPrice &gt; 0) {
            round.nbKingdoms[kingdom.owner]--;
            if (kingdom.kingdomType == 1) {
                round.nbKingdomsType1[kingdom.owner]--;
            } else if (kingdom.kingdomType == 2) {
                round.nbKingdomsType2[kingdom.owner]--;
            } else if (kingdom.kingdomType == 3) {
                round.nbKingdomsType3[kingdom.owner]--;
            } else if (kingdom.kingdomType == 4) {
                round.nbKingdomsType4[kingdom.owner]--;
            } else if (kingdom.kingdomType == 5) {
                round.nbKingdomsType5[kingdom.owner]--;
            }

            compensateLatestMonarch(kingdom.lastTransaction, kingdom.returnPrice);
        }

        uint jackpotSplitted = jackpotCommission.mul(50).div(100);
        round.globalJackpot.balance = round.globalJackpot.balance.add(jackpotSplitted);

        kingdom.kingdomTier++;
        kingdom.title = _title;

        if (kingdom.kingdomTier == 5) {
            kingdom.returnPrice = 0;
        } else {
            kingdom.returnPrice = kingdom.minimumPrice.mul(2);
            kingdom.minimumPrice = kingdom.minimumPrice.add(kingdom.minimumPrice.mul(2));
        }

        kingdom.owner = msg.sender;
        kingdom.locked = _locked;

        uint transactionId = kingdomTransactions.push(Transaction(&quot;&quot;, msg.sender, msg.value, 0, jackpotSplitted)) - 1;
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdom.transactionCount++;
        kingdom.lastTransaction = transactionId;

        setNewJackpot(kingdom.kingdomType, jackpotSplitted, msg.sender);
        LandPurchasedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe98945936dd2f04294afd798ed7036a8e9ba6acc">0xe98945936dd2f04294afd798ed7036a8e9ba6acc</a></p>
<pre><code class="language-solidity">function setLock(string _key, bool _locked) public payable checkKingdomExistence(_key) onlyKingdomOwner(_key, msg.sender) {
        if (_locked == true) { require(msg.value &gt;= ACTION_TAX); }
        kingdoms[rounds[currentRound].kingdomsKeys[_key]].locked = _locked;
        if (msg.value &gt; 0) { asyncSend(bookerAddress, msg.value); }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe98945936dd2f04294afd798ed7036a8e9ba6acc">0xe98945936dd2f04294afd798ed7036a8e9ba6acc</a></p>
<pre><code class="language-solidity">function createKingdom(address owner, string _key, string _title, uint _type, bool _locked) onlyForRemainingKingdoms() public payable {
        require(now &lt; rounds[currentRound].endTime);
        require(_type &gt; 0);
        require(_type &lt; 6);
        uint basePrice = STARTING_CLAIM_PRICE_WEI;
        uint requiredPrice = basePrice;
        if (_locked == true) { requiredPrice = requiredPrice.add(ACTION_TAX); }
        require(msg.value &gt;= requiredPrice);
        require(rounds[currentRound].kingdomsCreated[_key] == false);
        uint refundPrice = STARTING_CLAIM_PRICE_WEI.mul(2);
        uint nextMinimumPrice = STARTING_CLAIM_PRICE_WEI.add(refundPrice);
        uint kingdomId = kingdoms.push(Kingdom(&quot;&quot;, &quot;&quot;, 1, _type, 0, 0, 1, refundPrice, address(0), false)) - 1;

        kingdoms[kingdomId].title = _title;
        kingdoms[kingdomId].owner = owner;
        kingdoms[kingdomId].key = _key;
        kingdoms[kingdomId].minimumPrice = nextMinimumPrice;
        kingdoms[kingdomId].locked = _locked;

        rounds[currentRound].kingdomsKeys[_key] = kingdomId;
        rounds[currentRound].kingdomsCreated[_key] = true;

        asyncSend(bookerAddress, ACTION_TAX);

        uint jackpotSplitted = basePrice.mul(50).div(100);
        rounds[currentRound].globalJackpot.balance = rounds[currentRound].globalJackpot.balance.add(jackpotSplitted);

        uint transactionId = kingdomTransactions.push(Transaction(&quot;&quot;, msg.sender, msg.value, 0, jackpotSplitted)) - 1;
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdoms[kingdomId].lastTransaction = transactionId;

        setNewJackpot(_type, jackpotSplitted, msg.sender);
        LandCreatedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : PH</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1a2add18cb212db1c478595237831850e4a44d4e">0x1a2add18cb212db1c478595237831850e4a44d4e</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaa50311a317fe2272e8077708f7a852a175b78d4">0xaa50311a317fe2272e8077708f7a852a175b78d4</a></p>
<pre><code class="language-solidity">function addorRemoveTokens(address[] memory _addresses, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            TokenAddresses[_addresses[i]] = _isAdded;
            if (_isAdded == true) {
                emit TokenAdded(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaa50311a317fe2272e8077708f7a852a175b78d4">0xaa50311a317fe2272e8077708f7a852a175b78d4</a></p>
<pre><code class="language-solidity">function giveorRemoveSubscriptionTo(
        address[] memory _addresses,
        bool _isSubscriber
    ) external onlyRole(OPERATOR_ROLE, msg.sender) {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            Subscribers[_addresses[i]] = _isSubscriber;
            if (_isSubscriber == true) {
                emit GotSubscription(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSubscriber == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaa50311a317fe2272e8077708f7a852a175b78d4">0xaa50311a317fe2272e8077708f7a852a175b78d4</a></p>
<pre><code class="language-solidity">function addTokenPayments(address[] memory _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        for (uint256 i = 0; i &lt; _address.length; i++) {
            TokenPaymentAddresses[_address[i]] = _isAdded;
            if (_isAdded == true) {
                emit AddedTokenPayment(_address[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : Zapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd6a9c6c24789500c788e6047652dcd8878d8ad30">0xd6a9c6c24789500c788e6047652dcd8878d8ad30</a></p>
<pre><code class="language-solidity">function zapIn(
        uint256 stableCoinAmount,
        uint256 cycles,
        uint256 archMinAmount,
        uint256 ousdMinAmount,
        uint16 maxSlippageAllowed,
        address addressBaseStable,
        bool useUserArch
    ) external returns (uint256) {
        // Whats needs to happen?
        // -1) validate input
        // 0) transfer funds from user to this address
        // 1) figure out how much of stable goes to collateral and how much to pay as arch tokens
        // 2) exchange stable for Arch/ Take from user wallet
        // 3) exchange stable for OUSD
        // 4) open position
        // 5) return NFT to user

        /// validate input
        require(stableCoinAmount &gt; 0, &quot;err:stableCoinAmount==0&quot;);
        require(maxSlippageAllowed &lt; 1000, &quot;err:slippage&gt;1000&quot;);
        require(maxSlippageAllowed &gt; 959, &quot;err:slippage&lt;980&quot;);

        // Now we apply slippage. We increase the min of Arch and reduce the min of OUSD
        // This is because we need to always have enough Arch to pay so better to have a bit less OUSD and more Arch than
        // the other way around
        // archMinAmount = (archMinAmount * 1000) / maxSlippageAllowed;
        ousdMinAmount = (ousdMinAmount * maxSlippageAllowed) / 1000;

        /// transfer base stable coin from user to this address
        _transferFromSender(addressBaseStable, stableCoinAmount);

        /// Setup
        address[] memory path = _getPath(addressBaseStable);
        uint256 collateralInBaseStableAmount = stableCoinAmount;

        if (useUserArch == false) {
            // Need to buy Arch tokens. We already know how much Arch tokens we want. We still need to know the Max in stable that
            // we are willing to pay. For that, we're running the splitEstimate again and adding a small buffer
            uint256 coinsToPayForArchAmount;
            (collateralInBaseStableAmount, coinsToPayForArchAmount) = _splitStableCoinAmount(stableCoinAmount, cycles, path, addressBaseStable);
            /// since we basivally add a buffer for max stable to take, its actually a built in limit on how much slippage is allowed.
            /// In this case up to 5%
            uint256 maxStableToPayForArch = (coinsToPayForArchAmount * 1000) / maxSlippageAllowed;
            // Now swap exact archMinAmount for a maximum of maxStableToPayForArch in stable coin
            _uniswapRouter.swapTokensForExactTokens(archMinAmount, maxStableToPayForArch, path, address(this), block.timestamp + 2 minutes);
        }

        /// Exchange OUSD from any of the 3CRV. Will revert if didn't get min amount sent (2nd parameter)
        // Now spend all the remainign stable to buy OUSD
        uint256 remainingStable = IERC20Upgradeable(addressBaseStable).balanceOf(address(this));
        uint256 ousdAmount = _exchangeToOUSD(remainingStable, ousdMinAmount, addressBaseStable);

        // Check if we are using existing arch tokens owned by user or buying new ones
        if (useUserArch == true) {
            // We are using owners arch tokens, transfer from msg.sender to address(this)
            uint256 archToTransfer = _getArchAmountToTransferFromUser(ousdAmount, cycles);
            // uint256 archApproval = _archToken.allowance(msg.sender, address(this));
            // console.log(&quot;archToTransfer: %s , archMin %s, archApproved %s&quot;, archToTransfer, archMinAmount,archApproval);
            require(_archToken.balanceOf(msg.sender) &gt;= archToTransfer, &quot;err:insuf user arch&quot;);
            require(_archToken.allowance(msg.sender, address(this)) &gt;= archToTransfer, &quot;err:insuf approval arch&quot;);
            _transferFromSender(address(_archToken), archToTransfer);
        }

        /// create position
        uint256 tokenId = _levEngine.createLeveragedPositionFromZapper(ousdAmount, cycles, _archToken.balanceOf(address(this)), msg.sender);

        /// Return all remaining dust/tokens to user
        _archToken.safeTransfer(msg.sender, _archToken.balanceOf(address(this)));
        IERC20Upgradeable(addressBaseStable).safeApprove(msg.sender, 0);

        emit ZapIn(tokenId, stableCoinAmount, addressBaseStable, useUserArch);

        return tokenId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>useUserArch == true</code></p>
<hr />
<h3>Contract : ComptrollerG3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1e50dbce6c928888a80046ccace7c2a5fd9aff6e">0x1e50dbce6c928888a80046ccace7c2a5fd9aff6e</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1e50dbce6c928888a80046ccace7c2a5fd9aff6e">0x1e50dbce6c928888a80046ccace7c2a5fd9aff6e</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1e50dbce6c928888a80046ccace7c2a5fd9aff6e">0x1e50dbce6c928888a80046ccace7c2a5fd9aff6e</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1e50dbce6c928888a80046ccace7c2a5fd9aff6e">0x1e50dbce6c928888a80046ccace7c2a5fd9aff6e</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : AgileCycle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7f812651ec9a6edb53cbfa6b6709f1f61faae400">0x7f812651ec9a6edb53cbfa6b6709f1f61faae400</a></p>
<pre><code class="language-solidity">function approveCycle(bool _approved) public {
        require(cycleApproved != true &amp;&amp; roundFailedToStart != true);
        require(msg.sender == juryOperator);
        if (_approved == true) {
            cycleApproved = true;
        } else {
            roundFailedToStart = true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approved == true</code></p>
<hr />
<h3>Contract : AgileArbitration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7f812651ec9a6edb53cbfa6b6709f1f61faae400">0x7f812651ec9a6edb53cbfa6b6709f1f61faae400</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0638bd341d6bbb8e1fbfd529558c051d7e97d151">0x0638bd341d6bbb8e1fbfd529558c051d7e97d151</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0638bd341d6bbb8e1fbfd529558c051d7e97d151">0x0638bd341d6bbb8e1fbfd529558c051d7e97d151</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0638bd341d6bbb8e1fbfd529558c051d7e97d151">0x0638bd341d6bbb8e1fbfd529558c051d7e97d151</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0638bd341d6bbb8e1fbfd529558c051d7e97d151">0x0638bd341d6bbb8e1fbfd529558c051d7e97d151</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : JBController3_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x97a5b9d9f0f7cd676b69f584f29048d0ef4bb59b">0x97a5b9d9f0f7cd676b69f584f29048d0ef4bb59b</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate != JBConstants.MAX_RESERVED_RATE) {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    // Add reserved tokens if needed
    if (_reservedRate &gt; 0)
      reservedTokenBalanceOf[_projectId] += _tokenCount - beneficiaryTokenCount;

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : JBController3_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x97a5b9d9f0f7cd676b69f584f29048d0ef4bb59b">0x97a5b9d9f0f7cd676b69f584f29048d0ef4bb59b</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate != JBConstants.MAX_RESERVED_RATE) {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    // Add reserved tokens if needed
    if (_reservedRate &gt; 0)
      reservedTokenBalanceOf[_projectId] += _tokenCount - beneficiaryTokenCount;

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0784f5a1deb15f0dc6d6be4704f1f095ea825443">0x0784f5a1deb15f0dc6d6be4704f1f095ea825443</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x48bd4656e411e2c0e97e886b006908c0ee5a7eed">0x48bd4656e411e2c0e97e886b006908c0ee5a7eed</a></p>
<pre><code class="language-solidity">function updateSale(address _tokenAddress,uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) onlyAcceptedToken(_tokenAddress) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale      = true;
            sale.amount         = _amount;
            sale.price          = _price;
            sale.tokenAddress   = _tokenAddress;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0dc3ec189053522592df437d0b045bddbe7a866f">0x0dc3ec189053522592df437d0b045bddbe7a866f</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea">0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea</a></p>
<pre><code class="language-solidity">function updateSwapDurations(
        uint256 _duration,
        bool _is_supported
    ) external onlyGovernance() returns (bool){

        // get the initial value
        bool initialValue = swapDurations[_duration];

        // update the swapDurations mapping
        swapDurations[_duration] = _is_supported;

        // check if a swapDuration is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the swapDurationCount
            swapDurationCount = swapDurationCount.add(1);

        }

        // check if a swapDuration is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the swapDurationCount
            swapDurationCount = swapDurationCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == false &amp;&amp; _is_supported == true</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea">0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea</a></p>
<pre><code class="language-solidity">function updateSwapDurations(
        uint256 _duration,
        bool _is_supported
    ) external onlyGovernance() returns (bool){

        // get the initial value
        bool initialValue = swapDurations[_duration];

        // update the swapDurations mapping
        swapDurations[_duration] = _is_supported;

        // check if a swapDuration is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the swapDurationCount
            swapDurationCount = swapDurationCount.add(1);

        }

        // check if a swapDuration is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the swapDurationCount
            swapDurationCount = swapDurationCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == true &amp;&amp; _is_supported == false</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea">0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea</a></p>
<pre><code class="language-solidity">function updateProtocols(
        uint256 _protocol,
        bool _is_supported
    ) external onlyGovernance() returns (bool){

        // get the initial value
        bool initialValue = protocols[_protocol];

        // update the protocols mapping
        protocols[_protocol] = _is_supported;

        // check if a protocol is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the protocolCount
            protocolCount = protocolCount.add(1);

        }

        // check if a protocol is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the protocolCount
            protocolCount = protocolCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == false &amp;&amp; _is_supported == true</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea">0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea</a></p>
<pre><code class="language-solidity">function updateProtocols(
        uint256 _protocol,
        bool _is_supported
    ) external onlyGovernance() returns (bool){

        // get the initial value
        bool initialValue = protocols[_protocol];

        // update the protocols mapping
        protocols[_protocol] = _is_supported;

        // check if a protocol is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the protocolCount
            protocolCount = protocolCount.add(1);

        }

        // check if a protocol is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the protocolCount
            protocolCount = protocolCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == true &amp;&amp; _is_supported == false</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea">0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea</a></p>
<pre><code class="language-solidity">function updateProtocolMarkets(
        uint256 _protocol,
        address _market,
        bool _is_supported
    ) external onlyGovernance() returns (bool){

        // get the initial value
        bool initialValue = protocolMarkets[_protocol][_market];

        // update the protocolMarkets mapping
        protocolMarkets[_protocol][_market] = _is_supported;

        // check if a protocol market is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the protocolMarketCount
            protocolMarketCount = protocolMarketCount.add(1);

        }

        // check if a protocol market is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the protocolMarketCount
            protocolMarketCount = protocolMarketCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == false &amp;&amp; _is_supported == true</code></p>
<hr />
<h3>Contract : Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea">0xfc9c0a4783a8d5130f604d4c72433a459a0f38ea</a></p>
<pre><code class="language-solidity">function updateProtocolMarkets(
        uint256 _protocol,
        address _market,
        bool _is_supported
    ) external onlyGovernance() returns (bool){

        // get the initial value
        bool initialValue = protocolMarkets[_protocol][_market];

        // update the protocolMarkets mapping
        protocolMarkets[_protocol][_market] = _is_supported;

        // check if a protocol market is being added
        if (initialValue == false &amp;&amp; _is_supported == true) {

            // increment the protocolMarketCount
            protocolMarketCount = protocolMarketCount.add(1);

        }

        // check if a protocol market is being removed
        else if (initialValue == true &amp;&amp; _is_supported == false) {

            // decrement the protocolMarketCount
            protocolMarketCount = protocolMarketCount.sub(1);

        }

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initialValue == true &amp;&amp; _is_supported == false</code></p>
<hr />
<h3>Contract : NFTSingleNoGatingSevPrices</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4f9343fa110e8c5c1276b810fbbbb70a19678015">0x4f9343fa110e8c5c1276b810fbbbb70a19678015</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : BZXAAVEFLASHLIQUIDATE</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4163012cdc2dbb9465cddcba56f0e59c99c687a3">0x4163012cdc2dbb9465cddcba56f0e59c99c687a3</a></p>
<pre><code class="language-solidity">function performTrade(bool isItEther, uint256 amount1) public returns(uint256) {


        uint256 startingETHBalance = address(this).balance;
        ERC20 tokenToReceive = ERC20(currentCToken);
        uint256 startingCBalance = tokenToReceive.balanceOf(address(this));

        if (isItEther == true) {

        } else {
            ERC20 bzLToken = ERC20(currentLToken);

            if (bzLToken.allowance(address(this), bzx1Address) &lt;= currentMaxLiq) {
                bzLToken.approve(bzx1Address, (currentMaxLiq * 100));
            }
        }

        if (isItEther == false) {
            bzx1.liquidate(currentLoanId, address(this), currentMaxLiq);
        } else {
            bzx1.liquidate.value(amount1)(currentLoanId, address(this), currentMaxLiq);
        }



        uint256 amountBack = 0;
        if (address(this).balance &gt; startingETHBalance) {
            uint256 newETH = address(this).balance - startingETHBalance;
            wethToken.deposit.value(newETH)();


            amountBack = performUniswap(wethAddress, currentLToken, newETH);
        }
        else {



            uint256 difCBalance = tokenToReceive.balanceOf(address(this)) - startingCBalance;
           require(difCBalance &gt;0, &quot;Balance of Collateral token didnt go up after swap didnt go up&quot;);


           amountBack = performUniswap(currentCToken, currentLToken, difCBalance);
        }

        return amountBack;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isItEther == true</code></p>
<hr />
<h3>Contract : RewardCampaign</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9cf28ef84ec11763e488915d70715096c6bc0a5e">0x9cf28ef84ec11763e488915d70715096c6bc0a5e</a></p>
<pre><code class="language-solidity">function setApprovedKYFInstance(
        address _kyfContract,
        bool _status
    )
        public
        onlyAdmin
    {
        if (_status == true) {
            kyfInstancesArray.push(_kyfContract);
            kyfInstances[_kyfContract] = true;
            emit KyfStatusUpdated(_kyfContract, true);
            return;
        }

        // Remove the kyfContract from the kyfInstancesArray array.
        for (uint i = 0; i &lt; kyfInstancesArray.length; i++) {
            if (address(kyfInstancesArray[i]) == _kyfContract) {
                delete kyfInstancesArray[i];
                kyfInstancesArray[i] = kyfInstancesArray[kyfInstancesArray.length - 1];

                // Decrease the size of the array by one.
                kyfInstancesArray.length--;
                break;
            }
        }

        // And remove it from the synths mapping
        delete kyfInstances[_kyfContract];
        emit KyfStatusUpdated(_kyfContract, false);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : HelmsForLoot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe51d32ac7ef4653d3b526bb9d35b8a30af92ce2f">0xe51d32ac7ef4653d3b526bb9d35b8a30af92ce2f</a></p>
<pre><code class="language-solidity">function purchaseMatching(
        ILoot loot,
        uint256[] memory matchingIds,
        uint256[] memory lootIds,
        bool claimRiftXP
    ) public payable {
        require(
            state == SaleState.Phase1 ||
                state == SaleState.Phase2 ||
                state == SaleState.Phase3,
            &quot;HelmsForLoot: sale not active&quot;
        );

        require(lootContracts[loot], &quot;HelmsForLoot: not compatible&quot;);

        if (lootOnly)
            require(
                loot == ogLootContract,
                &quot;HelmsForLoot: loot-only minting period is active.&quot;
            );

        require(lootIds.length &gt; 0, &quot;HelmsForLoot: buy at least one&quot;);
        require(lootIds.length &lt;= 26, &quot;HelmsForLoot: too many at once&quot;);

        uint256[] memory tokenIds = new uint256[](lootIds.length);
        uint256 price = 0;

        for (uint256 i = 0; i &lt; lootIds.length; i++) {
            // Reserve Loot IDs 7778 to 8000 for ownerClaim
            require(
                (lootIds[i] &gt; 0 &amp;&amp; lootIds[i] &lt; 7778),
                &quot;HelmsForLoot: invalid Loot ID&quot;
            );

            require(
                loot.ownerOf(matchingIds[i]) == msg.sender,
                &quot;HelmsForLoot: not owner&quot;
            );

            require(
                keccak256(abi.encodePacked(loot.getHead(matchingIds[i]))) ==
                    keccak256(
                        abi.encodePacked(ogLootContract.getHead(lootIds[i]))
                    ),
                &quot;HelmsForLoot: wrong helm&quot;
            );

            // Both the original loot bag and matching bag
            // (loot/mloot/genesis adventurer) to be unclaimed
            require(
                !bagClaimed[loot][lootIds[i]],
                &quot;HelmsForLoot: loot bag already claimed&quot;
            );
            require(
                !bagClaimed[ogLootContract][matchingIds[i]],
                &quot;HelmsForLoot: matching already claimed&quot;
            );

            uint256 rarity = helmRarity(lootIds[i]);

            if (rarity == 1) {
                require(
                    state == SaleState.Phase1 ||
                        state == SaleState.Phase2 ||
                        state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceCommon;
            } else if (rarity == 2) {
                require(
                    state == SaleState.Phase2 || state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceEpic;
            } else if (rarity == 3) {
                require(
                    state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceLegendary;
            } else {
                require(
                    state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceMythic;
            }

            bagClaimed[ogLootContract][lootIds[i]] = true;
            tokenIds[i] = lmartContract.headId(lootIds[i]);
        }
        require(msg.value == price, &quot;Wrong price&quot;);

        // We're using a loop with _mint rather than _mintBatch
        // as currently some centralised tools like Opensea
        // have issues understanding the `TransferBatch` event
        for (uint256 i = 0; i &lt; tokenIds.length; i++) {
            uint256 riftId;
            // Add XP via The Rift
            if (claimRiftXP == true) {
                // Adjust ID for gLoot:
                if (loot != ogLootContract &amp;&amp; matchingIds[i] &lt; 8001) {
                    riftId = matchingIds[i] + 9997460;
                } else {
                    riftId = matchingIds[i];
                }
                riftDataContract.addXP(200, riftId);
            }
            _mint(msg.sender, tokenIds[i], 1, &quot;&quot;);
            emit Claimed(_msgSender(), lootIds[i], tokenIds[i]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claimRiftXP == true</code></p>
<hr />
<h3>Contract : ArbContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc6eba20877dc64e920975b9f5e6f1a0da48ee68e">0xc6eba20877dc64e920975b9f5e6f1a0da48ee68e</a></p>
<pre><code class="language-solidity">function arbIt2(uint[] eOrder, string[] memory tOrder1, uint256 amount, bool back) {
        uint256 final1 = eOrder.length -1;
        uint lastSell = amount;
        address [] tOrder;


        for(uint j=0; j&lt;tOrder1.length; j++){
            tOrder[j] =orfeed.getTokenAddress(tOrder1[j]);
        }
        for(uint i =0; i&lt;eOrder.length; i++){
            uint256 next = i+1;
            if(i &lt; final1){
               if(eOrder[i] ==1){
                   //kyber buy
                   lastSell = swapTokenOnKyber(tOrder[i], lastSell, tOrder[next]);
               }
               else if(eOrder[i] ==2){
                   lastSell = swapTokenOnUniswap(tOrder[i], lastSell, tOrder[next]);
               }
               else{
                 lastSell = bancorConvert2(tOrder[next], tOrder[i], lastSell);
               }
            }
            else{
                 //sell

                 if(back == true){
               if(eOrder[i] ==1){
                   //kyber buy
                   lastSell = swapTokenOnKyber(tOrder[i], lastSell, tOrder[0]);
               }
               else if(eOrder[i] ==2){
                  lastSell = swapTokenOnUniswap(tOrder[i], lastSell, tOrder[0]);
               }
               else{
                 lastSell = bancorConvert2(tOrder[0], tOrder[i], lastSell);
               }
            }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>back == true</code></p>
<hr />
<h3>Contract : AgileCycle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x967a89b2fc6b6e4803a8d4a130a846af9da9a7c1">0x967a89b2fc6b6e4803a8d4a130a846af9da9a7c1</a></p>
<pre><code class="language-solidity">function approveCycle(bool _approved) public {
        require(cycleApproved != true &amp;&amp; roundFailedToStart != true);
        require(msg.sender == juryOperator);
        if (_approved == true) {
            cycleApproved = true;
        } else {
            roundFailedToStart = true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approved == true</code></p>
<hr />
<h3>Contract : AgileArbitration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x967a89b2fc6b6e4803a8d4a130a846af9da9a7c1">0x967a89b2fc6b6e4803a8d4a130a846af9da9a7c1</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : Shyba</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x29c379af72742461d18c0633d25c4ec3f766508e">0x29c379af72742461d18c0633d25c4ec3f766508e</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x548bf2610c1f15ec6bb78914aa7f90c59a82f492">0x548bf2610c1f15ec6bb78914aa7f90c59a82f492</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : N2MERC1155</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcd0c4438b705c7536367a501fd246682b1b1c543">0xcd0c4438b705c7536367a501fd246682b1b1c543</a></p>
<pre><code class="language-solidity">function initialize(
        string memory tokenName,
        string memory tokenSymbol,
        uint256 iMintPrice,
        bytes32 baseURICIDHash,
        bytes32 placeholderImageCIDHash,
        RevenueAddress[] calldata revenueAddresses,
        address iErc20PaymentAddress,
        uint32 iTotalSupply,
        uint16 iRoyaltyFee,
        bool soulboundCollection,
        MintingType iMintingType
    ) public payable override initializer {

        _name = tokenName;
        symbol = tokenSymbol;

        if (iTotalSupply == 0) revert TotalSupplyMustBeGreaterThanZero();
        if (baseURICIDHash != 0 &amp;&amp; placeholderImageCIDHash != 0) revert CantSetBaseURIAndPlaceholderAtTheSameTime();
        if (iRoyaltyFee &gt; 10_00) revert RoyaltyFeeTooHigh();

        _collectionSize = iTotalSupply;
        if (baseURICIDHash == 0) {
            if (placeholderImageCIDHash == 0) {
                if (iMintingType != MintingType.CUSTOM_URI)
                    revert NoBaseURINorPlaceholderSet();
            } else {
                _placeholderImageCIDHash = placeholderImageCIDHash;
            }
        } else {
            _baseURICIDHash = baseURICIDHash;
        }

        _mintPrice = iMintPrice;
        _royaltyFee = iRoyaltyFee;
        if (iMintingType != MintingType.SEQUENTIAL) {
            _mintingType = iMintingType;
        }
        if (iErc20PaymentAddress != address(0)) {
            _isERC20Payment = true;
            _erc20PaymentAddress = iErc20PaymentAddress;
        }
        if (soulboundCollection == true) {
            _soulboundCollection = true;
        }

        if (revenueAddresses.length &gt; 0) {
            uint256 revenuePercentageTotal;
            for (uint256 i; i &lt; revenueAddresses.length; ) {
                revenuePercentageTotal += revenueAddresses[i].percentage;
                unchecked {
                    ++i;
                }
            }
            _revenueInfo = revenueAddresses;
            if (revenuePercentageTotal &gt; 100_00 - N2M_FEE) revert InvalidRevenuePercentage();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>soulboundCollection == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6f10c5401e54b9589f60ebaf64e23a4f97c5aa3d">0x6f10c5401e54b9589f60ebaf64e23a4f97c5aa3d</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf4961c0b395f19f0f27cc68ed2a97a75953a24d8">0xf4961c0b395f19f0f27cc68ed2a97a75953a24d8</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd877d120525a289a6d99dcf602de2c438f8fbcb0">0xd877d120525a289a6d99dcf602de2c438f8fbcb0</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x47c179e396cd388fc52a1d0c6949f24f6dd064a2">0x47c179e396cd388fc52a1d0c6949f24f6dd064a2</a></p>
<pre><code class="language-solidity">function updateSale(address _tokenAddress,uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) onlyAcceptedToken(_tokenAddress) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale      = true;
            sale.amount         = _amount;
            sale.price          = _price;
            sale.tokenAddress   = _tokenAddress;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : StakingPoolUSDCJustYield</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc558e9f2080914ac01597d3a73326d167b630667">0xc558e9f2080914ac01597d3a73326d167b630667</a></p>
<pre><code class="language-solidity">function whitelistBlacklist(address _addr, bool _status) public onlyAdmins{
        whitelist[_addr] = _status;
        if(_status == true){
            kycdAccounts.push(_addr);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : RebaserV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ed99d9c19c95c632659f7b683e4511bdc639503">0x8ed99d9c19c95c632659f7b683e4511bdc639503</a></p>
<pre><code class="language-solidity">function claimFee (uint256 amount, bool max, bool receiveFlip, uint256 operatorId) external {
        address manager;
        address feeRecipient;
        uint256 pendingFee = operators[operatorId].pendingFee;
        (manager,feeRecipient) = wrappedOutputProxy.getOperatorAddresses(operatorId);

        if (max == false &amp;&amp; amount &gt; pendingFee) revert ExcessiveFeeClaim();
        if (msg.sender != feeRecipient &amp;&amp; msg.sender != manager) revert NotFeeRecipientOrManager();

        uint256 amountToClaim = max ? pendingFee : amount;

        operators[operatorId].pendingFee -= SafeCast.toUint80(amountToClaim);
        totalOperatorPendingFee -= SafeCast.toUint80(amountToClaim);

        if (receiveFlip == true) {
            flip.transferFrom(address(wrappedOutputProxy), msg.sender, amountToClaim);
        } else {
            stflip.mint(msg.sender, amountToClaim);
        }

        emit FeeClaim(msg.sender, amountToClaim, receiveFlip, operatorId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>receiveFlip == true</code></p>
<hr />
<h3>Contract : RebaserV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ed99d9c19c95c632659f7b683e4511bdc639503">0x8ed99d9c19c95c632659f7b683e4511bdc639503</a></p>
<pre><code class="language-solidity">function claimFee (uint256 amount, bool max, bool receiveFlip, uint256 operatorId) external {
        address manager;
        address feeRecipient;
        uint256 pendingFee = operators[operatorId].pendingFee;
        (manager,feeRecipient) = wrappedOutputProxy.getOperatorAddresses(operatorId);

        if (max == false &amp;&amp; amount &gt; pendingFee) revert ExcessiveFeeClaim();
        if (msg.sender != feeRecipient &amp;&amp; msg.sender != manager) revert NotFeeRecipientOrManager();

        uint256 amountToClaim = max ? pendingFee : amount;

        operators[operatorId].pendingFee -= SafeCast.toUint80(amountToClaim);
        totalOperatorPendingFee -= SafeCast.toUint80(amountToClaim);

        if (receiveFlip == true) {
            flip.transferFrom(address(wrappedOutputProxy), msg.sender, amountToClaim);
        } else {
            stflip.mint(msg.sender, amountToClaim);
        }

        emit FeeClaim(msg.sender, amountToClaim, receiveFlip, operatorId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>receiveFlip == true</code></p>
<hr />
<h3>Contract : RebaserV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ed99d9c19c95c632659f7b683e4511bdc639503">0x8ed99d9c19c95c632659f7b683e4511bdc639503</a></p>
<pre><code class="language-solidity">function claimServiceFee(uint256 amount, bool max, bool receiveFlip) external onlyRole(FEE_RECIPIENT_ROLE) {
        if (max == false &amp;&amp; amount &gt; servicePendingFee) revert ExcessiveFeeClaim();

        uint256 amountToClaim = max ? servicePendingFee : amount;

        servicePendingFee -= SafeCast.toUint80(amountToClaim);

        if (receiveFlip == true) {
            flip.transferFrom(address(wrappedOutputProxy), msg.sender, amountToClaim);
        } else {
            stflip.mint(msg.sender, amountToClaim);
        }

        emit FeeClaim(msg.sender, amountToClaim, receiveFlip, 0); // consider putting service Fee under operator id zero. consider implications though since all validators will have operator id of zero by default. 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>receiveFlip == true</code></p>
<hr />
<h3>Contract : RebaserV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ed99d9c19c95c632659f7b683e4511bdc639503">0x8ed99d9c19c95c632659f7b683e4511bdc639503</a></p>
<pre><code class="language-solidity">function claimServiceFee(uint256 amount, bool max, bool receiveFlip) external onlyRole(FEE_RECIPIENT_ROLE) {
        if (max == false &amp;&amp; amount &gt; servicePendingFee) revert ExcessiveFeeClaim();

        uint256 amountToClaim = max ? servicePendingFee : amount;

        servicePendingFee -= SafeCast.toUint80(amountToClaim);

        if (receiveFlip == true) {
            flip.transferFrom(address(wrappedOutputProxy), msg.sender, amountToClaim);
        } else {
            stflip.mint(msg.sender, amountToClaim);
        }

        emit FeeClaim(msg.sender, amountToClaim, receiveFlip, 0); // consider putting service Fee under operator id zero. consider implications though since all validators will have operator id of zero by default. 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>receiveFlip == true</code></p>
<hr />
<h3>Contract : LUNABANK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3cffb402545b7fbddc66f751c76c4aede2e43002">0x3cffb402545b7fbddc66f751c76c4aede2e43002</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : HANDS</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x68fb67352535327438d319749e8f74c92157db14">0x68fb67352535327438d319749e8f74c92157db14</a></p>
<pre><code class="language-solidity">function draw(bool useOneOfThreeFreeDrawsAndSetPayableEthTo0) public payable nonReentrant {
        if(useOneOfThreeFreeDrawsAndSetPayableEthTo0 == true) {
            require(freeDraws[msg.sender] &lt; 3, &quot;used all free draws&quot;);
            freeDraws[msg.sender] += 1;  
        } else {
            require(msg.value == currentPrice * hikeFactor, &quot;incorrect eth amount&quot;);
        }
        require(totalSupply() &lt;= MAX_SUPPLY, &quot;exceed supply&quot;);
        uint256 tokenId = totalSupply() + 1;
        if(tokenId % 500 == 0) {
            hikeFactor += 1;
        }
        setHand(tokenId);
        _safeMint(_msgSender(), tokenId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>useOneOfThreeFreeDrawsAndSetPayableEthTo0 == true</code></p>
<hr />
<h3>Contract : SMCRHIMagnesita</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x71cd3572a40e82eaaa5d347bd351e3d3c1366ad5">0x71cd3572a40e82eaaa5d347bd351e3d3c1366ad5</a></p>
<pre><code class="language-solidity">function approveTechnicalMeasurement(
        string memory _label,
        bool _decision,
        bytes32 _technicalJustificative
    ) public measurementIsOpen(_label) canBeTechnicallyApproved(_label, _decision) {
        uint256 measurementId = getMeasurementId(_label);

        eventMeasurementType[measurementId] = MeasurementType.TECHNICAL;
        eventUser[measurementId] = msg.sender;

        if (_decision == true) {
            eventAction[measurementId] = Action.APPROVAL;
            measurementStatus[measurementId] = MeasurementStatus.TECHNICALLY_APPROVED;
        } else if (_decision == false) {
            eventAction[measurementId] = Action.DISSAPROVAL;
            measurementStatus[measurementId] = MeasurementStatus.TECHNICALLY_DISAPPROVED;
        }
        else {
            revert(&quot;Decision not boolean&quot;); // não sei se precisa
        }

        eventVariables[measurementId][uint256(Variables.TECHNICAL_JUSTIFICATIVE)] = _technicalJustificative;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_decision == true</code></p>
<hr />
<h3>Contract : SMCRHIMagnesita</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x71cd3572a40e82eaaa5d347bd351e3d3c1366ad5">0x71cd3572a40e82eaaa5d347bd351e3d3c1366ad5</a></p>
<pre><code class="language-solidity">function registerCommercialMeasurement(
        string memory _label,
        int256 _producedSteel,
        int256 _totalInvoicedMaterial,
        bytes32 _commercialNotes,
        bytes32 _commercialFiles,
        bool _updateAdminVariables,
        int256 _stopLimit,
        int256 _contractedValueRatio,
        int256 _coefficient
    )
        public
        canBeCommerciallyMeasured(_label)
    {
        uint256 measurementId = getMeasurementId(_label);
        eventUser[measurementId] = msg.sender;
        eventMeasurementType[measurementId] = MeasurementType.COMMERCIAL;

        if (msg.sender == arbiter) {
            eventAction[measurementId] = Action.ARBITER_MEASURE;

            measurementVariables[measurementId][uint256(Variables.IS_OPEN)] = FALSE;
            measurementStatus[measurementId] = MeasurementStatus.COMMERCIALLY_APPROVED;
            setFinancialMeasurement(measurementId);
        } else {
            eventAction[measurementId] = Action.MEASURE;

            if (msg.sender == contractorCommercial) {
                measurementStatus[measurementId] = MeasurementStatus.WAITING_HIRED_COMMERCIAL;
            } else {
                measurementStatus[measurementId] = MeasurementStatus.WAITING_CONTRACTOR_COMMERCIAL;
            }
        }

        financialVariables[measurementId][uint256(Variables.PRODUCED_STEEL)] = _producedSteel;
        financialVariables[measurementId][uint256(Variables.TOTAL_INVOICED_MATERIAL)] = _totalInvoicedMaterial;

        if (_updateAdminVariables == true) {
            financialVariables[measurementId][uint256(Variables.STOP_LIMIT)] = _stopLimit;
            financialVariables[measurementId][uint256(Variables.CONTRACTED_VALUE_RATIO)] = _contractedValueRatio;
            financialVariables[measurementId][uint256(Variables.COEFFICIENT)] = _coefficient;

            stopLimit = _stopLimit;
            contractedValueRatio = _contractedValueRatio;
            coefficient = _coefficient;
        }


        eventVariables[measurementId][uint256(Variables.COMMERCIAL_NOTES)] = _commercialNotes;
        eventVariables[measurementId][uint256(Variables.COMMERCIAL_FILES)] = _commercialFiles;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_updateAdminVariables == true</code></p>
<hr />
<h3>Contract : SMCRHIMagnesita</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x71cd3572a40e82eaaa5d347bd351e3d3c1366ad5">0x71cd3572a40e82eaaa5d347bd351e3d3c1366ad5</a></p>
<pre><code class="language-solidity">function approveCommercialMeasurement(
        string memory _label,
        bool _decision,
        bytes32 _commercialJustificative
    ) public measurementIsOpen(_label) canBeCommerciallyApproved(_label, _decision) {
        uint256 measurementId = getMeasurementId(_label);

        eventMeasurementType[measurementId] = MeasurementType.COMMERCIAL;
        eventUser[measurementId] = msg.sender;
        if (_decision == true) {
            eventAction[measurementId] = Action.APPROVAL;
            measurementStatus[measurementId] = MeasurementStatus.COMMERCIALLY_APPROVED;
            measurementVariables[measurementId][uint256(Variables.IS_OPEN)] = FALSE;
            setFinancialMeasurement(measurementId);
        } else {
            eventAction[measurementId] = Action.DISSAPROVAL;
            measurementStatus[measurementId] = MeasurementStatus.COMMERCIALLY_DISAPPROVED;
        }


        eventVariables[measurementId][uint256(Variables.COMMERCIAL_JUSTIFICATIVE)] = _commercialJustificative;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_decision == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyETHArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x517c8e1d3de9a366162fa85333ef6cd9baf1e709">0x517c8e1d3de9a366162fa85333ef6cd9baf1e709</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyETHArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x517c8e1d3de9a366162fa85333ef6cd9baf1e709">0x517c8e1d3de9a366162fa85333ef6cd9baf1e709</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0), getCheapestCurveToken());
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : AnonymousCult</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xba3f51682510ec30d584b633e058d6daef60ed41">0xba3f51682510ec30d584b633e058d6daef60ed41</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1">0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1</a></p>
<pre><code class="language-solidity">function relay(
        bytes32 _txid,
        address _user,
        uint256 _amount,
        uint256 _src_chain_id,
        uint256 _dest_chain_id,
        bool _tryTeleport,
        bool _confirmed
    ) onlyRelayer external {
        // check if txid is already relayed
        require(relayed_txids[_txid] == false, &quot;txid already relayed&quot;);

        // check if txid is confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // check if txid is already voted
        require(voted_txids[msg.sender][_txid] == false, &quot;txid already voted&quot;);

        // check if network/chain ids are correct
        // Note: the tx's dest is this contract's src and vice versa
        require(_src_chain_id == dest_chain_id, &quot;invalid src chain id&quot;);
        require(_dest_chain_id == src_chain_id, &quot;invalid dest chain id&quot;);

        // check if amount is correct
        require(_amount &gt; 0, &quot;invalid amount&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // add vote
        votes[_txid].push(Vote({
            relayer: msg.sender,
            user: _user,
            amount: _amount,
            txid: _txid,
            confirmed: _confirmed
        }));

        // mark txid as voted
        voted_txids[msg.sender][_txid] = true;

        emit Relayed(msg.sender, _user, _amount, _txid);

        if (_tryTeleport == true) {
            tryTeleport(_txid, _user, _amount, true, false);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryTeleport == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1">0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1</a></p>
<pre><code class="language-solidity">function relay(
        bytes32 _txid,
        address _user,
        uint256 _amount,
        uint256 _src_chain_id,
        uint256 _dest_chain_id,
        bool _tryTeleport,
        bool _confirmed
    ) onlyRelayer external {
        // check if txid is already relayed
        require(relayed_txids[_txid] == false, &quot;txid already relayed&quot;);

        // check if txid is confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // check if txid is already voted
        require(voted_txids[msg.sender][_txid] == false, &quot;txid already voted&quot;);

        // check if network/chain ids are correct
        // Note: the tx's dest is this contract's src and vice versa
        require(_src_chain_id == dest_chain_id, &quot;invalid src chain id&quot;);
        require(_dest_chain_id == src_chain_id, &quot;invalid dest chain id&quot;);

        // check if amount is correct
        require(_amount &gt; 0, &quot;invalid amount&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // add vote
        votes[_txid].push(Vote({
            relayer: msg.sender,
            user: _user,
            amount: _amount,
            txid: _txid,
            confirmed: _confirmed
        }));

        // mark txid as voted
        voted_txids[msg.sender][_txid] = true;

        emit Relayed(msg.sender, _user, _amount, _txid);

        if (_tryTeleport == true) {
            tryTeleport(_txid, _user, _amount, true, false);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryTeleport == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1">0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryFinalize == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1">0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_failOnInsufficientQuorum == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1">0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryFinalize == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1">0x5be173d21b55a8dbb8741e5b5a4b96a3eedeccb1</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_failOnInsufficientQuorum == true</code></p>
<hr />
<h3>Contract : MAMStake</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdbccb2d5da2521f066663a558a5c9c0b73369583">0xdbccb2d5da2521f066663a558a5c9c0b73369583</a></p>
<pre><code class="language-solidity">function mamStake(uint256 tokenId, uint256 _tier,  bool _topten) external {
        mam.safeTransferFrom(msg.sender, address(this), tokenId);
        mamTokenOwnerOf[tokenId] = msg.sender;
        mamTier[tokenId] = _tier;
        mamTokenStakedAt[tokenId] = block.timestamp;
        numberMamStaked[msg.sender]++;

        if(_topten == true){
                tMultiplier[tokenId] = true;
            } 


        for(uint16 i; i&lt; legendaryIds.length; i++) {
            if(tokenId == legendaryIds[i]) {
                lMultiplier[tokenId] = true;
            }
        }

        totalStaked++;
        mamStaked++;
        emit MamStaked(msg.sender, tokenId, _tier);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_topten == true</code></p>
<hr />
<h3>Contract : NFTInfo</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd15c62f530b335b391f9ce3eb67d69b88f551a20">0xd15c62f530b335b391f9ce3eb67d69b88f551a20</a></p>
<pre><code class="language-solidity">function manageHolderAddresses(bool status, address _holder) external {
        require(
            msg.sender == wrapperaddress || msg.sender == Owner,
            &quot;Not Oracle/Owner!&quot;
        );
        if (status == true) {
            //Add user to array!
            (bool _isholder, ) = isHolderInArray(_holder);
            if (!_isholder) holderaddresses.push(_holder);
        }
        if (status == false) {
            (bool _isholder, uint256 s) = isHolderInArray(_holder);
            if (_isholder) {
                holderaddresses[s] = holderaddresses[
                    holderaddresses.length - 1
                ];
                holderaddresses.pop();
            }
            holder[_holder] = status;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>status == true</code></p>
<hr />
<h3>Contract : ComptrollerG1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x69cb567ace32c016ca6a389fef8fcee55ab6bcdc">0x69cb567ace32c016ca6a389fef8fcee55ab6bcdc</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x69cb567ace32c016ca6a389fef8fcee55ab6bcdc">0x69cb567ace32c016ca6a389fef8fcee55ab6bcdc</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x69cb567ace32c016ca6a389fef8fcee55ab6bcdc">0x69cb567ace32c016ca6a389fef8fcee55ab6bcdc</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x69cb567ace32c016ca6a389fef8fcee55ab6bcdc">0x69cb567ace32c016ca6a389fef8fcee55ab6bcdc</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : CultMoon</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4807f00f4c07ed21dad08f9b6be334a5f627c555">0x4807f00f4c07ed21dad08f9b6be334a5f627c555</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x639e1a972dc38db8aa0fb4bd22df1c6dc84c9f7d">0x639e1a972dc38db8aa0fb4bd22df1c6dc84c9f7d</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + hightLightFee);
                } else {
                    require(msg.value == limitETHFee + hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x639e1a972dc38db8aa0fb4bd22df1c6dc84c9f7d">0x639e1a972dc38db8aa0fb4bd22df1c6dc84c9f7d</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : BONER</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7a26ec7416fa48c0ad8974f4e657f086875fc2ee">0x7a26ec7416fa48c0ad8974f4e657f086875fc2ee</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function getOrderInfo(bool _isBuyOrder, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.buyOrders[_price][_number].client;
            _amount = sCVars.buyOrders[_price][_number].amount;
            _orderId = sCVars.buyOrders[_price][_number].orderId;
        }
        else {
            _address = sCVars.sellOrders[_price][_number].client;
            _amount = sCVars.sellOrders[_price][_number].amount;
            _orderId = sCVars.sellOrders[_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2">0xb5cda69c569b0599fa3e491d3ad26fac1d9971a2</a></p>
<pre><code class="language-solidity">function getStockOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.stockBuyOrders[_node][_price][_number].client;
            _amount = sCVars.stockBuyOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockBuyOrders[_node][_price][_number].orderId;
        }
        else {
            _address = sCVars.stockSellOrders[_node][_price][_number].client;
            _amount = sCVars.stockSellOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockSellOrders[_node][_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : BetokenLogic2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc78d2edddd9844e9011871a8f8061f93d38f937e">0xc78d2edddd9844e9011871a8f8061f93d38f937e</a></p>
<pre><code class="language-solidity">function signalUpgrade(bool _inSupport) public notReadyForUpgrade during(CyclePhase.Intermission) returns (bool _success) {
    if (!__isMature()) {
      return false;
    }

    if (upgradeSignal[cycleNumber][msg.sender] == false) {
      if (_inSupport == true) {
        upgradeSignal[cycleNumber][msg.sender] = true;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].add(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    } else {
      if (_inSupport == false) {
        upgradeSignal[cycleNumber][msg.sender] = false;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].sub(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    }
    emit SignaledUpgrade(cycleNumber, msg.sender, _inSupport);
    return true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_inSupport == true</code></p>
<hr />
<h3>Contract : HelixNebula</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd9467327499e51609dc0493f0e5d6cbcc7d3fe01">0xd9467327499e51609dc0493f0e5d6cbcc7d3fe01</a></p>
<pre><code class="language-solidity">function SendTransaction(address payable _adr,address payable _referraladr,bool _hasreferral) public payable{
      uint HelixToTransfer=msg.value/HelixPrice;

      if(balances[wallet]&gt;(2*HelixToTransfer*(10**7))){
          if(_hasreferral == true){
            balances[_referraladr] += HelixToTransfer*(10**7);
            balances[wallet] -= HelixToTransfer*(10**7);
          }
          balances[msg.sender] += HelixToTransfer*(10**7);
          balances[wallet] -= HelixToTransfer*(10**7);
          _adr.transfer(msg.value*9/10);
          wallet.transfer(msg.value/10);
      }else{
          _adr.transfer(msg.value); //if the main helix nebula wallet is empty. all helpings send to the needy
      }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_hasreferral == true</code></p>
<hr />
<h3>Contract : Artis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x75a38ad35be11507ea908a22770613a9ab34e105">0x75a38ad35be11507ea908a22770613a9ab34e105</a></p>
<pre><code class="language-solidity">function setTokenSale(
    uint256 _tokenId,
    bool _sale,
    uint256 _sell_method,
    uint256 _expire_at,
    uint256 _price
  ) public {
    require(_exists(_tokenId), 'ERC721: Sale set of nonexistent token');
    require(_price &gt; 0, 'ERC721: Price of token must be greater than zero');
    require(ownerOf(_tokenId) == _msgSender(), 'ERC721: Only owner of token can do this action');

    if (
      _tokenMeta[_tokenId].sell_method == 2 &amp;&amp;
      _tokenMeta[_tokenId].locked == true &amp;&amp;
      _tokenMeta[_tokenId].sale == true
    ) {
      require(
        _tokenMeta[_tokenId].expire_at &lt;= block.timestamp &amp;&amp; _bids[_tokenId].bidder == address(0),
        'ERC721: Token currently blocked due to active auctions'
      );
    }

    _tokenMeta[_tokenId].sale = _sale;
    _tokenMeta[_tokenId].sell_method = _sell_method;
    _tokenMeta[_tokenId].expire_at = _expire_at;
    _tokenMeta[_tokenId].price = _price;
    _tokenMeta[_tokenId].locked = false;

    if (_sell_method == 2 &amp;&amp; _sale == true) {
      _tokenMeta[_tokenId].locked = true;
    }

    emit ChangedSalesTokenStatus(_tokenId, _msgSender(), _sale, _price, _sell_method, _expire_at);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_sell_method == 2 &amp;&amp; _sale == true</code></p>
<hr />
<h3>Contract : Artis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x75a38ad35be11507ea908a22770613a9ab34e105">0x75a38ad35be11507ea908a22770613a9ab34e105</a></p>
<pre><code class="language-solidity">function mint(
    address _owner,
    string memory _name,
    uint256 _price,
    uint256 _sell_method,
    uint256 _expire_at,
    uint256 _royalty,
    bool _sale,
    string memory _id_collection
  ) public returns (uint256) {
    require(_price &gt; 0);
    require(
      _royalty &gt;= 0 &amp;&amp; _royalty &lt;= maxAllowedRoyalties,
      'ERC721: Very high royalty, you have to set a lower royalty'
    );

    _tokenIds.increment();
    bool locked = false;

    uint256 newItemId = _tokenIds.current();
    _safeMint(_owner, newItemId);

    if (_sell_method == 2 &amp;&amp; _sale == true) {
      require(block.timestamp &lt; _expire_at, 'ERC721: time to expire auction must be in the future');
      locked = true;
    }

    TokenMeta memory meta = TokenMeta(
      newItemId,
      _name,
      _sale,
      _sell_method,
      _expire_at,
      _price,
      _royalty,
      _owner,
      locked,
      _id_collection
    );
    _setTokenMeta(newItemId, meta);

    return newItemId;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_sell_method == 2 &amp;&amp; _sale == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfdc3d3de2620e1ea9d45ba9f7a378388ed511c23">0xfdc3d3de2620e1ea9d45ba9f7a378388ed511c23</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfdc3d3de2620e1ea9d45ba9f7a378388ed511c23">0xfdc3d3de2620e1ea9d45ba9f7a378388ed511c23</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfdc3d3de2620e1ea9d45ba9f7a378388ed511c23">0xfdc3d3de2620e1ea9d45ba9f7a378388ed511c23</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfdc3d3de2620e1ea9d45ba9f7a378388ed511c23">0xfdc3d3de2620e1ea9d45ba9f7a378388ed511c23</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : BULLBANK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7de2cc570da4d1782a7829c200b72376e91f06d1">0x7de2cc570da4d1782a7829c200b72376e91f06d1</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe196002397a9b631bc0fa88e895221e0724e7028">0xe196002397a9b631bc0fa88e895221e0724e7028</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            checkAndSellStables();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe196002397a9b631bc0fa88e895221e0724e7028">0xe196002397a9b631bc0fa88e895221e0724e7028</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // When a user withdraws, we need to pull the tokens out of the contract
        if(nonContract == true){
            checkAndSellStables();
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }        

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : AgileCycleWithAssistance</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27369e8f43f44c26853a46da7e6cb52d203b59ce">0x27369e8f43f44c26853a46da7e6cb52d203b59ce</a></p>
<pre><code class="language-solidity">function approveCycle(bool _approved) public {
        require(cycleApproved != true &amp;&amp; roundFailedToStart != true);
        require(msg.sender == juryOperator);
        if (_approved == true) {
            cycleApproved = true;
        } else {
            roundFailedToStart = true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approved == true</code></p>
<hr />
<h3>Contract : AgileArbitrationWithAssistance</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27369e8f43f44c26853a46da7e6cb52d203b59ce">0x27369e8f43f44c26853a46da7e6cb52d203b59ce</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDWithdraw</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x95c4ac982896440213a8070074f773ef00056984">0x95c4ac982896440213a8070074f773ef00056984</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDWithdraw</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x95c4ac982896440213a8070074f773ef00056984">0x95c4ac982896440213a8070074f773ef00056984</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){}

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : MKongStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x08540bea06c3173af34d6a2298a0dfc314e565ae">0x08540bea06c3173af34d6a2298a0dfc314e565ae</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(91).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(mkongToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MKongStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x08540bea06c3173af34d6a2298a0dfc314e565ae">0x08540bea06c3173af34d6a2298a0dfc314e565ae</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(91).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(mkongToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : ArbitrationX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3abe5cc17aa51324c77224f19f3656f20acb8090">0x3abe5cc17aa51324c77224f19f3656f20acb8090</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x69c90605f5a3224ac54f23bb7923462e0630603a">0x69c90605f5a3224ac54f23bb7923462e0630603a</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xca92fedc300c3c3a42daef99c1b94f431a676167">0xca92fedc300c3c3a42daef99c1b94f431a676167</a></p>
<pre><code class="language-solidity">function setIsSatellitePool(address pool, bool state) public {
        require(msg.sender == coreDev, &quot;Liquidation::setIsSatellitePool:caller is not coreDev&quot;);
        if(isSatellitePool[pool] != state) {
            isSatellitePool[pool] = state;
            if (state == true) {
                satellitePools.push(pool);
            } else {
                for (uint i=0; i &lt; satellitePools.length; i++) {
                    if (satellitePools[i] == pool) {
                        satellitePools[i] = satellitePools[satellitePools.length-1];
                        satellitePools.pop();
                    }
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>state == true</code></p>
<hr />
<h3>Contract : LicensingToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x64ae47c0efb5bb151f3d00dece917fbbd6db2ebe">0x64ae47c0efb5bb151f3d00dece917fbbd6db2ebe</a></p>
<pre><code class="language-solidity">function safeMint(
        address _to,
        string calldata _licenseType,
        uint256 _expirationDate,
        bool _exclusive,
        uint256 _tokenId,
        address _tokenContractAddress,
        address _tokenOwnerAddress,
        bytes32 _databaseId
    ) external onlyRole(MINTER_ROLE) {
        MasterLicenseTypeDetail memory masterLicenseTypeDetail = masterLicenseTypeDetails[
            concatenateLicenseTypeHash(
                concatenateLicenseHash(_tokenContractAddress, _tokenId),
                &quot;MASTER&quot;
            )
        ];

        // If it's going to mint any license, it shouldnt exist a exclusive master license.
        require(masterLicenseTypeDetail.masterExclusiveMaxExpirationDate &lt;= block.timestamp,
            &quot;LT: Cannot mint. It has a valid exclusive master license.&quot;
        );

        if (keccak256(abi.encodePacked(_licenseType)) == keccak256(abi.encodePacked(&quot;MASTER&quot;))) {
            // it is going to mint a master so it cannot have an exclusive license that is not expired
            // check for other exclusive licenses TV, DISPLAY
            require(masterLicenseTypeDetail.regularExclusiveMaxExpirationDate &lt;= block.timestamp,
                &quot;LT: Cannot mint Master. It has a exclusive license and is not expired.&quot;
            );

            if (_exclusive == true) {
                // if exclusive, it cannot have a master license that is valid
                // ex. there is a non master exlcusive license that is not expired, and we try to mint an exclusive master license
                require(masterLicenseTypeDetail.masterMaxExpirationDate &lt;= block.timestamp,
                    &quot;LT: Cannot mint exclusive Master. It has a valid Master license.&quot;
                );

                // if exclusive, it cannot have a non master license that is valid
                // any licenses that is not exclusive
                require(masterLicenseTypeDetail.regularMaxExpirationDate &lt;= block.timestamp,
                    &quot;LT: Cannot mint exclusive Master. It has a valid regular license.&quot;
                );
                masterLicenseTypeDetail.masterExclusiveMaxExpirationDate = _expirationDate;
            } else {
                // it isn't a Master exclusive, so update max expiration date
                if (masterLicenseTypeDetail.masterMaxExpirationDate &lt;= _expirationDate) {
                    masterLicenseTypeDetail.masterMaxExpirationDate = _expirationDate;
                }
            }

            // update storage
            masterLicenseTypeDetails[
                concatenateLicenseTypeHash(
                    concatenateLicenseHash(_tokenContractAddress, _tokenId),
                    &quot;MASTER&quot;
                )
            ] = masterLicenseTypeDetail;
            ///
        } else {
            LicenseTypeDetail memory licenseTypeDetail = licenseTypeDetails[
                concatenateLicenseTypeHash(
                    concatenateLicenseHash(_tokenContractAddress, _tokenId),
                    _licenseType
                )
            ];
            if (_exclusive == true) {
                // if it is exclusive, it cannot have another license of the same type valid,
                require(licenseTypeDetail.maxExpirationDate &lt;= block.timestamp,
                    &quot;LT: Cannot mint exclusive license. It has a valid license.&quot;
                );

                // it cannot have a Master that is valid.
                require(masterLicenseTypeDetail.masterMaxExpirationDate &lt;= block.timestamp,
                    &quot;LT: Cannot mint exclusive license. It has a valid Master licenses.&quot;
                );

                if (!licenseTypeDetail.isExclusive) {
                    licenseTypeDetail.isExclusive = true;
                }

                if (masterLicenseTypeDetail.regularExclusiveMaxExpirationDate &lt;= _expirationDate
                ) {
                    masterLicenseTypeDetail.regularExclusiveMaxExpirationDate = _expirationDate;

                    // update storage
                    masterLicenseTypeDetails[
                        concatenateLicenseTypeHash(
                            concatenateLicenseHash(_tokenContractAddress, _tokenId),
                            &quot;MASTER&quot;
                        )
                    ] = masterLicenseTypeDetail;
                }
            } else {
                // check if there was an exclusive license and it should be expired to be able to mint a non exclusive license
                if (licenseTypeDetail.isExclusive) {
                    require(licenseTypeDetail.maxExpirationDate &lt;= block.timestamp,
                        &quot;LT: Cannot mint a license. It has a valid exclusive license.&quot;
                    );

                    // it was exclusive, but is expired, so set to false
                    licenseTypeDetail.isExclusive = false;
                }

                // store the max
                if (masterLicenseTypeDetail.regularMaxExpirationDate &lt;= _expirationDate
                ) {
                    masterLicenseTypeDetail.regularMaxExpirationDate = _expirationDate;

                    // update storage
                    masterLicenseTypeDetails[
                        concatenateLicenseTypeHash(
                            concatenateLicenseHash(_tokenContractAddress, _tokenId),
                            &quot;MASTER&quot;
                        )
                    ] = masterLicenseTypeDetail;
                }
            }

            // update expiration date if this new non exclusive license has a longer expiration date
            // _expirationDate is always greater than block.timestamp
            if (licenseTypeDetail.maxExpirationDate &lt; _expirationDate
            ) {
                licenseTypeDetail.maxExpirationDate = _expirationDate;
            }

            // update storage
            licenseTypeDetails[
                concatenateLicenseTypeHash(
                    concatenateLicenseHash(_tokenContractAddress, _tokenId),
                    _licenseType
                )
            ] = licenseTypeDetail;
        }

        // Buyer Token
        unchecked {
            ++tokenId;
        }

        uint256 buyerTokenId = tokenId;

        //seller token
        unchecked {
            ++tokenId;
        }

        _safeMint(_to, buyerTokenId);
        emit MintBuyerToken(buyerTokenId, _databaseId);

        _safeMint(_tokenOwnerAddress, tokenId);
        emit MintSellerToken(tokenId, _databaseId);

        License memory newLicense = License(
            _licenseType,
            buyerTokenId,
            _expirationDate,
            _exclusive
        );

        // Return the license hash if the license is already registered
        License[] storage licenses = registeredLicenses[
            concatenateLicenseHash(_tokenContractAddress, _tokenId)
        ];
        licenses.push(newLicense);

        registeredLicenses[concatenateLicenseHash(_tokenContractAddress, _tokenId)] = licenses;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_exclusive == true</code></p>
<hr />
<h3>Contract : LicensingToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x64ae47c0efb5bb151f3d00dece917fbbd6db2ebe">0x64ae47c0efb5bb151f3d00dece917fbbd6db2ebe</a></p>
<pre><code class="language-solidity">function safeMint(
        address _to,
        string calldata _licenseType,
        uint256 _expirationDate,
        bool _exclusive,
        uint256 _tokenId,
        address _tokenContractAddress,
        address _tokenOwnerAddress,
        bytes32 _databaseId
    ) external onlyRole(MINTER_ROLE) {
        MasterLicenseTypeDetail memory masterLicenseTypeDetail = masterLicenseTypeDetails[
            concatenateLicenseTypeHash(
                concatenateLicenseHash(_tokenContractAddress, _tokenId),
                &quot;MASTER&quot;
            )
        ];

        // If it's going to mint any license, it shouldnt exist a exclusive master license.
        require(masterLicenseTypeDetail.masterExclusiveMaxExpirationDate &lt;= block.timestamp,
            &quot;LT: Cannot mint. It has a valid exclusive master license.&quot;
        );

        if (keccak256(abi.encodePacked(_licenseType)) == keccak256(abi.encodePacked(&quot;MASTER&quot;))) {
            // it is going to mint a master so it cannot have an exclusive license that is not expired
            // check for other exclusive licenses TV, DISPLAY
            require(masterLicenseTypeDetail.regularExclusiveMaxExpirationDate &lt;= block.timestamp,
                &quot;LT: Cannot mint Master. It has a exclusive license and is not expired.&quot;
            );

            if (_exclusive == true) {
                // if exclusive, it cannot have a master license that is valid
                // ex. there is a non master exlcusive license that is not expired, and we try to mint an exclusive master license
                require(masterLicenseTypeDetail.masterMaxExpirationDate &lt;= block.timestamp,
                    &quot;LT: Cannot mint exclusive Master. It has a valid Master license.&quot;
                );

                // if exclusive, it cannot have a non master license that is valid
                // any licenses that is not exclusive
                require(masterLicenseTypeDetail.regularMaxExpirationDate &lt;= block.timestamp,
                    &quot;LT: Cannot mint exclusive Master. It has a valid regular license.&quot;
                );
                masterLicenseTypeDetail.masterExclusiveMaxExpirationDate = _expirationDate;
            } else {
                // it isn't a Master exclusive, so update max expiration date
                if (masterLicenseTypeDetail.masterMaxExpirationDate &lt;= _expirationDate) {
                    masterLicenseTypeDetail.masterMaxExpirationDate = _expirationDate;
                }
            }

            // update storage
            masterLicenseTypeDetails[
                concatenateLicenseTypeHash(
                    concatenateLicenseHash(_tokenContractAddress, _tokenId),
                    &quot;MASTER&quot;
                )
            ] = masterLicenseTypeDetail;
            ///
        } else {
            LicenseTypeDetail memory licenseTypeDetail = licenseTypeDetails[
                concatenateLicenseTypeHash(
                    concatenateLicenseHash(_tokenContractAddress, _tokenId),
                    _licenseType
                )
            ];
            if (_exclusive == true) {
                // if it is exclusive, it cannot have another license of the same type valid,
                require(licenseTypeDetail.maxExpirationDate &lt;= block.timestamp,
                    &quot;LT: Cannot mint exclusive license. It has a valid license.&quot;
                );

                // it cannot have a Master that is valid.
                require(masterLicenseTypeDetail.masterMaxExpirationDate &lt;= block.timestamp,
                    &quot;LT: Cannot mint exclusive license. It has a valid Master licenses.&quot;
                );

                if (!licenseTypeDetail.isExclusive) {
                    licenseTypeDetail.isExclusive = true;
                }

                if (masterLicenseTypeDetail.regularExclusiveMaxExpirationDate &lt;= _expirationDate
                ) {
                    masterLicenseTypeDetail.regularExclusiveMaxExpirationDate = _expirationDate;

                    // update storage
                    masterLicenseTypeDetails[
                        concatenateLicenseTypeHash(
                            concatenateLicenseHash(_tokenContractAddress, _tokenId),
                            &quot;MASTER&quot;
                        )
                    ] = masterLicenseTypeDetail;
                }
            } else {
                // check if there was an exclusive license and it should be expired to be able to mint a non exclusive license
                if (licenseTypeDetail.isExclusive) {
                    require(licenseTypeDetail.maxExpirationDate &lt;= block.timestamp,
                        &quot;LT: Cannot mint a license. It has a valid exclusive license.&quot;
                    );

                    // it was exclusive, but is expired, so set to false
                    licenseTypeDetail.isExclusive = false;
                }

                // store the max
                if (masterLicenseTypeDetail.regularMaxExpirationDate &lt;= _expirationDate
                ) {
                    masterLicenseTypeDetail.regularMaxExpirationDate = _expirationDate;

                    // update storage
                    masterLicenseTypeDetails[
                        concatenateLicenseTypeHash(
                            concatenateLicenseHash(_tokenContractAddress, _tokenId),
                            &quot;MASTER&quot;
                        )
                    ] = masterLicenseTypeDetail;
                }
            }

            // update expiration date if this new non exclusive license has a longer expiration date
            // _expirationDate is always greater than block.timestamp
            if (licenseTypeDetail.maxExpirationDate &lt; _expirationDate
            ) {
                licenseTypeDetail.maxExpirationDate = _expirationDate;
            }

            // update storage
            licenseTypeDetails[
                concatenateLicenseTypeHash(
                    concatenateLicenseHash(_tokenContractAddress, _tokenId),
                    _licenseType
                )
            ] = licenseTypeDetail;
        }

        // Buyer Token
        unchecked {
            ++tokenId;
        }

        uint256 buyerTokenId = tokenId;

        //seller token
        unchecked {
            ++tokenId;
        }

        _safeMint(_to, buyerTokenId);
        emit MintBuyerToken(buyerTokenId, _databaseId);

        _safeMint(_tokenOwnerAddress, tokenId);
        emit MintSellerToken(tokenId, _databaseId);

        License memory newLicense = License(
            _licenseType,
            buyerTokenId,
            _expirationDate,
            _exclusive
        );

        // Return the license hash if the license is already registered
        License[] storage licenses = registeredLicenses[
            concatenateLicenseHash(_tokenContractAddress, _tokenId)
        ];
        licenses.push(newLicense);

        registeredLicenses[concatenateLicenseHash(_tokenContractAddress, _tokenId)] = licenses;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_exclusive == true</code></p>
<hr />
<h3>Contract : Benchmark</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x67c597624b17b16fb77959217360b7cd18284253">0x67c597624b17b16fb77959217360b7cd18284253</a></p>
<pre><code class="language-solidity">function rebase(uint256 supplyDelta, bool increaseSupply) external returns (uint256) {
        require(msg.sender == rebaseOracle, &quot;Can only be executed by rebaseOracle.&quot;);

        if (supplyDelta == 0) {
            emit LogRebase(totalSupply);
            return totalSupply;
        }

        if (increaseSupply == true) {
            totalSupply = totalSupply.add(supplyDelta);
        } else {
            totalSupply = totalSupply.sub(supplyDelta);
        }

        if (totalSupply &gt; MAXSUPPLY) {
            totalSupply = MAXSUPPLY;
        }

        atomsPerMolecule = totalAtoms.div(totalSupply);

        emit LogRebase(totalSupply);
        return totalSupply;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>increaseSupply == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4e041bab07b2eb5f9ab1f8e677a5cbf1591bf9e4">0x4e041bab07b2eb5f9ab1f8e677a5cbf1591bf9e4</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4e041bab07b2eb5f9ab1f8e677a5cbf1591bf9e4">0x4e041bab07b2eb5f9ab1f8e677a5cbf1591bf9e4</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : ComptrollerG2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe14172224892e8fd7ae2883e46883abf1ea949d">0xbe14172224892e8fd7ae2883e46883abf1ea949d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe14172224892e8fd7ae2883e46883abf1ea949d">0xbe14172224892e8fd7ae2883e46883abf1ea949d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe14172224892e8fd7ae2883e46883abf1ea949d">0xbe14172224892e8fd7ae2883e46883abf1ea949d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe14172224892e8fd7ae2883e46883abf1ea949d">0xbe14172224892e8fd7ae2883e46883abf1ea949d</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf5f996ebbe131a7f8450af551c770b967af7af68">0xf5f996ebbe131a7f8450af551c770b967af7af68</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf5f996ebbe131a7f8450af551c770b967af7af68">0xf5f996ebbe131a7f8450af551c770b967af7af68</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf5f996ebbe131a7f8450af551c770b967af7af68">0xf5f996ebbe131a7f8450af551c770b967af7af68</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf5f996ebbe131a7f8450af551c770b967af7af68">0xf5f996ebbe131a7f8450af551c770b967af7af68</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : CryptoChallenge</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xff58b2da0414b4fc4cf18f4ec7230ba7b82677e2">0xff58b2da0414b4fc4cf18f4ec7230ba7b82677e2</a></p>
<pre><code class="language-solidity">function judge(uint256 _tokenId, bool _isP1Win) onlyWitness(_tokenId) public {
    require(price2OfToken[_tokenId] != 0);
    require(now &gt; free2OfToken[_tokenId]);
    uint reward = bet1OfToken[_tokenId] + bet2OfToken[_tokenId] + calculateDevCut(price1OfToken[_tokenId] + price2OfToken[_tokenId]);
    reward -= calculateDevCut(reward);
    if (_isP1Win == true) {
      reward = reward.div(bet1OfToken[_tokenId] + price1OfToken[_tokenId]);
      p1OfToken[_tokenId].transfer(reward.mul(bet1OfToken[_tokenId]));
      owner1OfToken[_tokenId].transfer(reward.mul(price1OfToken[_tokenId]));
    } else {
      reward = reward.div(bet2OfToken[_tokenId] + price2OfToken[_tokenId]);
      p2OfToken[_tokenId].transfer(reward.mul(bet2OfToken[_tokenId]));
      owner2OfToken[_tokenId].transfer(reward.mul(price2OfToken[_tokenId]));
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isP1Win == true</code></p>
<hr />
<h3>Contract : PriorityPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x80faea283474e9fd26ffd168829350ac766e7b8d">0x80faea283474e9fd26ffd168829350ac766e7b8d</a></p>
<pre><code class="language-solidity">function withdraw(
        uint256 _amountToWithdraw,
        uint256 _amount,
        uint256 _sharesAmount,
        bytes32[] calldata _merkleProof,
        bool _shouldUnqueue
    ) external {
        if (_amountToWithdraw == 0) revert InvalidAmount();

        uint256 toWithdraw = _amountToWithdraw;
        address account = msg.sender;

        if (_shouldUnqueue == true) {
            _requireNotPaused();

            if (_merkleProof.length != 0) {
                bytes32 node = keccak256(bytes.concat(keccak256(abi.encode(account, _amount, _sharesAmount))));
                if (!MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, node)) revert InvalidProof();
            } else if (accountIndexes[account] &lt; merkleTreeSize) {
                revert InvalidProof();
            }

            uint256 queuedTokens = getQueuedTokens(account, _amount);
            uint256 canUnqueue = queuedTokens &lt;= totalQueued ? queuedTokens : totalQueued;
            uint256 amountToUnqueue = toWithdraw &lt;= canUnqueue ? toWithdraw : canUnqueue;

            if (amountToUnqueue != 0) {
                accountQueuedTokens[account] -= amountToUnqueue;
                totalQueued -= amountToUnqueue;
                toWithdraw -= amountToUnqueue;
                emit UnqueueTokens(account, amountToUnqueue);
            }
        }

        if (toWithdraw != 0) {
            IERC20Upgradeable(address(stakingPool)).safeTransferFrom(account, address(this), toWithdraw);
            _withdraw(toWithdraw);
            emit Withdraw(account, toWithdraw);
        }

        token.safeTransfer(account, _amountToWithdraw);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_shouldUnqueue == true</code></p>
<hr />
<h3>Contract : JohnSkater</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdb4c920875a9cb7f7e78987626e7afaf1fdbb404">0xdb4c920875a9cb7f7e78987626e7afaf1fdbb404</a></p>
<pre><code class="language-solidity">constructor(bool mintERC2309Flg, bool _callerIsUserFlg) ERC721A(&quot;JohnSkater&quot;, &quot;JOHN&quot;) {
        callerIsUserFlg = _callerIsUserFlg;
        _setDefaultRoyalty(0x1242f4174Da11A23d18d405D1895f63fd6d312A8, 1000);
        if (mintERC2309Flg == true) {
            _mintERC2309(0x1242f4174Da11A23d18d405D1895f63fd6d312A8, 50);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mintERC2309Flg == true</code></p>
<hr />
<h3>Contract : JohnSkater</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdb4c920875a9cb7f7e78987626e7afaf1fdbb404">0xdb4c920875a9cb7f7e78987626e7afaf1fdbb404</a></p>
<pre><code class="language-solidity">constructor(bool mintERC2309Flg, bool _callerIsUserFlg) ERC721A(&quot;JohnSkater&quot;, &quot;JOHN&quot;) {
        callerIsUserFlg = _callerIsUserFlg;
        _setDefaultRoyalty(0x1242f4174Da11A23d18d405D1895f63fd6d312A8, 1000);
        if (mintERC2309Flg == true) {
            _mintERC2309(0x1242f4174Da11A23d18d405D1895f63fd6d312A8, 50);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mintERC2309Flg == true</code></p>
<hr />
<h3>Contract : Exchange</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc901b7c08dece715d0898d89b06722101c98518e">0xc901b7c08dece715d0898d89b06722101c98518e</a></p>
<pre><code class="language-solidity">function closeFuturesPosition (bytes32 futuresContract, bool side)
    {
        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);

        if (futuresContracts[futuresContract].closed == false &amp;&amp; futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled
        if (retrievePosition(positionHash)[1] == 0) throw; // position not found
        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed

        uint256 profit;
        uint256 loss;

        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;

        FuturesClosePositionValues memory v = FuturesClosePositionValues({
            reserve         : EtherMium(exchangeContract).getReserve(baseToken, msg.sender),
            balance         : EtherMium(exchangeContract).balanceOf(baseToken, msg.sender),
            floorPrice      : futuresContracts[futuresContract].floorPrice,
            capPrice        : futuresContracts[futuresContract].capPrice,
            closingPrice    : futuresContracts[futuresContract].closingPrice,
            futuresContract : futuresContract
        });

        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);
        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);
        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;
        // uint256 capPrice = futuresContracts[futuresContract].capPrice;
        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;



        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);
        uint256 fee = calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract);



        // close long position
        if (side == true)
        {            

            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);
            // return;
            // reserve = reserve - (entryPrice - floorPrice) * size;
            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));


            subReserve(
                baseToken, 
                msg.sender, 
                v.reserve, 
                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice
                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &gt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);



                // LogUint(15, profit);
                // LogUint(16, fee);
                // LogUint(17, safeSub(profit * 1e10, fee));
                // return;

                addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10));
                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  


                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }   
        // close short position 
        else
        {
            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);
            // return;

            // reserve = reserve - (capPrice - entryPrice) * size;
            subReserve(
                baseToken, 
                msg.sender,  
                v.reserve, 
                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice
                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &lt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                // profit = (entryPrice - closingPrice) * size
                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);

                addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                // profit = (closingPrice - entryPrice) * size
                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  

                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }  

        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount
        updatePositionSize(positionHash, 0, 0);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>side == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa4cba3f89d30184bf213172fea2c6241bd27911e">0xa4cba3f89d30184bf213172fea2c6241bd27911e</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa4cba3f89d30184bf213172fea2c6241bd27911e">0xa4cba3f89d30184bf213172fea2c6241bd27911e</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa4cba3f89d30184bf213172fea2c6241bd27911e">0xa4cba3f89d30184bf213172fea2c6241bd27911e</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : BetokenLogic</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa640b43f4f25362384a10fd73ff4ca350b7cbb70">0xa640b43f4f25362384a10fd73ff4ca350b7cbb70</a></p>
<pre><code class="language-solidity">function signalUpgrade(bool _inSupport) public returns (bool _success) {
    if (!__isMature()) {
      return false;
    }

    if (upgradeSignal[cycleNumber][msg.sender] == false) {
      if (_inSupport == true) {
        upgradeSignal[cycleNumber][msg.sender] = true;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].add(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    } else {
      if (_inSupport == false) {
        upgradeSignal[cycleNumber][msg.sender] = false;
        upgradeSignalStrength[cycleNumber] = upgradeSignalStrength[cycleNumber].sub(getVotingWeight(msg.sender));
      } else {
        return false;
      }
    }
    emit SignaledUpgrade(cycleNumber, msg.sender, _inSupport);
    return true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_inSupport == true</code></p>
<hr />
<h3>Contract : TokenAuction</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9beec9834c1bb97597663c6415795bb4621aa8c4">0x9beec9834c1bb97597663c6415795bb4621aa8c4</a></p>
<pre><code class="language-solidity">function disqualifyBid(address _from, bool _doRefund) public ownerOnly duringAuction {
    secretBids[_from].disqualified = true;
    BidDisqualifiedEvent(_from, secretBids[_from].hash);
    if (_doRefund == true) {
      uint _amount = secretBids[_from].deposit;
      secretBids[_from].hash = bytes32(0);
      secretBids[_from].deposit = 0;
      secretBidCount = safeSub(secretBidCount, 1);
      if (_amount &gt; 0)
        _from.transfer(_amount);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_doRefund == true</code></p>
<hr />
<h3>Contract : CErc20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xadf0f8e47c9086798ad63165399c6b0ff050bc61">0xadf0f8e47c9086798ad63165399c6b0ff050bc61</a></p>
<pre><code class="language-solidity">function mint(uint mintAmount, bool enterMarket) external returns (uint) {
        (uint err,) = mintInternal(mintAmount);
        //If the mint was successfull and the user wants to use assets as collateral
        if(err == 0 &amp;&amp; enterMarket == true){
            address[] memory marketToEnter = new address[](1);
            marketToEnter[0] = address(this);
            comptroller.enterMarkets(marketToEnter, msg.sender);
        }
        return err;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>err == 0 &amp;&amp; enterMarket == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ac0ef3fcb7cc4018286fe301d4102903bb63182">0x8ac0ef3fcb7cc4018286fe301d4102903bb63182</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ac0ef3fcb7cc4018286fe301d4102903bb63182">0x8ac0ef3fcb7cc4018286fe301d4102903bb63182</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ac0ef3fcb7cc4018286fe301d4102903bb63182">0x8ac0ef3fcb7cc4018286fe301d4102903bb63182</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner())</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27659ffb6d10cbbfcafbee03212807720b71d721">0x27659ffb6d10cbbfcafbee03212807720b71d721</a></p>
<pre><code class="language-solidity">function relay(
        bytes32 _txid,
        address _user,
        uint256 _amount,
        uint256 _src_chain_id,
        uint256 _dest_chain_id,
        bool _tryTeleport,
        bool _confirmed
    ) onlyRelayer external {
        // check if txid is already relayed
        require(relayed_txids[_txid] == false, &quot;txid already relayed&quot;);

        // check if txid is confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // check if txid is already voted
        require(voted_txids[msg.sender][_txid] == false, &quot;txid already voted&quot;);

        // check if network/chain ids are correct
        // Note: the tx's dest is this contract's src and vice versa
        require(_src_chain_id == dest_chain_id, &quot;invalid src chain id&quot;);
        require(_dest_chain_id == src_chain_id, &quot;invalid dest chain id&quot;);

        // check if amount is correct
        require(_amount &gt; 0, &quot;invalid amount&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // add vote
        votes[_txid].push(Vote({
            relayer: msg.sender,
            user: _user,
            amount: _amount,
            txid: _txid,
            confirmed: _confirmed
        }));

        // mark txid as voted
        voted_txids[msg.sender][_txid] = true;

        emit Relayed(msg.sender, _user, _amount, _txid);

        if (_tryTeleport == true) {
            tryTeleport(_txid, _user, _amount, true, false);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryTeleport == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27659ffb6d10cbbfcafbee03212807720b71d721">0x27659ffb6d10cbbfcafbee03212807720b71d721</a></p>
<pre><code class="language-solidity">function relay(
        bytes32 _txid,
        address _user,
        uint256 _amount,
        uint256 _src_chain_id,
        uint256 _dest_chain_id,
        bool _tryTeleport,
        bool _confirmed
    ) onlyRelayer external {
        // check if txid is already relayed
        require(relayed_txids[_txid] == false, &quot;txid already relayed&quot;);

        // check if txid is confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // check if txid is already voted
        require(voted_txids[msg.sender][_txid] == false, &quot;txid already voted&quot;);

        // check if network/chain ids are correct
        // Note: the tx's dest is this contract's src and vice versa
        require(_src_chain_id == dest_chain_id, &quot;invalid src chain id&quot;);
        require(_dest_chain_id == src_chain_id, &quot;invalid dest chain id&quot;);

        // check if amount is correct
        require(_amount &gt; 0, &quot;invalid amount&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // add vote
        votes[_txid].push(Vote({
            relayer: msg.sender,
            user: _user,
            amount: _amount,
            txid: _txid,
            confirmed: _confirmed
        }));

        // mark txid as voted
        voted_txids[msg.sender][_txid] = true;

        emit Relayed(msg.sender, _user, _amount, _txid);

        if (_tryTeleport == true) {
            tryTeleport(_txid, _user, _amount, true, false);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryTeleport == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27659ffb6d10cbbfcafbee03212807720b71d721">0x27659ffb6d10cbbfcafbee03212807720b71d721</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryFinalize == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27659ffb6d10cbbfcafbee03212807720b71d721">0x27659ffb6d10cbbfcafbee03212807720b71d721</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_failOnInsufficientQuorum == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27659ffb6d10cbbfcafbee03212807720b71d721">0x27659ffb6d10cbbfcafbee03212807720b71d721</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryFinalize == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x27659ffb6d10cbbfcafbee03212807720b71d721">0x27659ffb6d10cbbfcafbee03212807720b71d721</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_failOnInsufficientQuorum == true</code></p>
<hr />
<h3>Contract : DaoStructs</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1f5b7179a643570effb4da05a0ca0760b36ceed3">0x1f5b7179a643570effb4da05a0ca0760b36ceed3</a></p>
<pre><code class="language-solidity">function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)
        external
        view
        returns (address[] memory _voters, uint256 _length)
    {
        uint256 _n = _allUsers.length;
        uint256 i;
        _length = 0;
        _voters = new address[](_n);
        if (_vote == true) {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.yesVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        } else {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.noVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4cbfa8c91e8e5ed0ea9d86127806435a6d5c0672">0x4cbfa8c91e8e5ed0ea9d86127806435a6d5c0672</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd6ec25e530f1120e503a7adcfc980dcc9b8a5e98">0xd6ec25e530f1120e503a7adcfc980dcc9b8a5e98</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            uint256 diff = balance().sub(lastActionBalance);
            // Trade if long time since last trade or deposited a large amount of tokens
            if(now.sub(lastTradeTime) &gt; secondsBeforeTrade || diff &gt; lastActionBalance.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens();
            }
            lastActionBalance = balance();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd6ec25e530f1120e503a7adcfc980dcc9b8a5e98">0xd6ec25e530f1120e503a7adcfc980dcc9b8a5e98</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(now.sub(lastTradeTime) &gt; secondsBeforeTrade || _share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens();
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : DaoStructs</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35addce0274ba9104293c4cf234e43b5ae2d4ef3">0x35addce0274ba9104293c4cf234e43b5ae2d4ef3</a></p>
<pre><code class="language-solidity">function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)
        external
        view
        returns (address[] memory _voters, uint256 _length)
    {
        uint256 _n = _allUsers.length;
        uint256 i;
        _length = 0;
        _voters = new address[](_n);
        if (_vote == true) {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.yesVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        } else {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.noVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : ignoranceStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x035ad2d463501ae2b554b76eea076dba1de24449">0x035ad2d463501ae2b554b76eea076dba1de24449</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(91).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(ignoranceToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : ignoranceStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x035ad2d463501ae2b554b76eea076dba1de24449">0x035ad2d463501ae2b554b76eea076dba1de24449</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(91).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(ignoranceToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xaf5ef23e884fd696c8dfafd1836e0164f13873a0">0xaf5ef23e884fd696c8dfafd1836e0164f13873a0</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external override moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                IModule(_module).init(address(this));
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : Memefund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x35c674c288577df3e9b5dafef945795b741c7810">0x35c674c288577df3e9b5dafef945795b741c7810</a></p>
<pre><code class="language-solidity">function rebase(uint256 supplyDelta, bool increaseSupply) external returns (uint256) {
        require(msg.sender == rebaseOracle, &quot;Can only be executed by rebaseOracle.&quot;);

        if (supplyDelta == 0) {
            emit LogRebase(totalSupply);
            return totalSupply;
        }

        if (increaseSupply == true) {
            totalSupply = totalSupply.add(supplyDelta);
        } else {
            totalSupply = totalSupply.sub(supplyDelta);
        }

        if (totalSupply &gt; MAXSUPPLY) {
            totalSupply = MAXSUPPLY;
        }

        atomsPerMolecule = totalAtoms.div(totalSupply);

        emit LogRebase(totalSupply);
        return totalSupply;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>increaseSupply == true</code></p>
<hr />
<h3>Contract : MintChicadees</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x68a42d59e7b314c8655d8fe54756afa5b22bf150">0x68a42d59e7b314c8655d8fe54756afa5b22bf150</a></p>
<pre><code class="language-solidity">function pause(bool val) public  {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;Must be admin&quot;);
        if (val == true) {
            _pause();
            return;
        }
        _unpause();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>val == true</code></p>
<hr />
<h3>Contract : Bundles</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3db561d1c9a49aee8788493b791ecc95d5b84911">0x3db561d1c9a49aee8788493b791ecc95d5b84911</a></p>
<pre><code class="language-solidity">function updatebal(address _user,uint256 _bundleId,uint256 _reward,bool _isPositive) public returns(bool){
        require(msg.sender == owner,'Not Owner');
        require(_reward &lt;= 12000000,'Invalid Reward Percent');
        User storage us = user[_user];
        require(us.active == true,'Invalid User');
        UserBets storage u = bets[_user][_bundleId];
        require(u.claimed == false,'Already Claimed');
        uint256 a = SafeMath.mul(u.totalbet,_reward);
        uint256 b = SafeMath.div(a,10**8);
        if(_isPositive == true){
            uint256 c = SafeMath.add(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        else{
            uint256 c = SafeMath.sub(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isPositive == true</code></p>
<hr />
<h3>Contract : Castile_Tarot_Contract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8efa5d3d2ab95cb43bbba25de45bcea5b79bc151">0x8efa5d3d2ab95cb43bbba25de45bcea5b79bc151</a></p>
<pre><code class="language-solidity">function WhitelistCheck(address recipient, bytes32[] calldata _merkleProof, bool freeMint)
    public
    view 
    returns (bool) {
        bytes32 leaf = keccak256(abi.encodePacked(recipient));
        if(freeMint == true)
        {
            return MerkleProof.verify(_merkleProof, merkleRoot_free_wlist, leaf);
        }
        return MerkleProof.verify(_merkleProof, merkleRoot_fee_wlist, leaf);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>freeMint == true</code></p>
<hr />
<h3>Contract : Exchange</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x564a0ecf84fbf4004106238247a6e4bf34b55e4a">0x564a0ecf84fbf4004106238247a6e4bf34b55e4a</a></p>
<pre><code class="language-solidity">function closeFuturesPosition (bytes32 futuresContract, bool side)
    {
        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);

        if (futuresContracts[futuresContract].closed == false &amp;&amp; futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled
        if (retrievePosition(positionHash)[1] == 0) throw; // position not found
        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed

        uint256 profit;
        uint256 loss;

        FuturesClosePositionValues memory v = FuturesClosePositionValues({
            reserve         : EtherMium(exchangeContract).getReserve(baseToken, msg.sender),
            balance         : EtherMium(exchangeContract).balanceOf(baseToken, msg.sender),
            floorPrice      : futuresContracts[futuresContract].floorPrice,
            capPrice        : futuresContracts[futuresContract].capPrice,
            closingPrice    : futuresContracts[futuresContract].closingPrice
        });

        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);
        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);
        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;
        // uint256 capPrice = futuresContracts[futuresContract].capPrice;
        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;


        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;
        uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);



        // close long position
        if (side == true)
        {            

            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);
            // return;
            // reserve = reserve - (entryPrice - floorPrice) * size;
            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));
            subReserve(baseToken, msg.sender, v.reserve, safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice);
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &gt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);



                // LogUint(15, profit);
                // LogUint(16, fee);
                // LogUint(17, safeSub(profit * 1e10, fee));
                // return;

                addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee));
                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  


                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee));
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }   
        // close short position 
        else
        {
            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);
            // return;

            // reserve = reserve - (capPrice - entryPrice) * size;
            subReserve(baseToken, msg.sender,  v.reserve, safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice);
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &lt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                // profit = (entryPrice - closingPrice) * size
                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);

                addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                // profit = (closingPrice - entryPrice) * size
                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  

                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }  

        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee); // send fee to feeAccount
        updatePositionSize(positionHash, 0, 0);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>side == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x029af177a478bc81e1f344ea4634df581869c1f4">0x029af177a478bc81e1f344ea4634df581869c1f4</a></p>
<pre><code class="language-solidity">function updateSale(
        address _tokenAddress,
        uint256 _tokenId,
        bool _isForSale,
        uint256 _amount,
        uint256 _price
    ) public onlyAcceptedToken(_tokenAddress) returns (bool) {
        require(_exists(_tokenId)); //발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];

        if (_isForSale == true) {
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount); //판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale = true;
            sale.amount = _amount;
            sale.price = _price;
            sale.tokenAddress = _tokenAddress;
        } else {
            sale.isForSale = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : ERC721AUpgradeable</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x033795b498fb4725638454595c2b767cd831f101">0x033795b498fb4725638454595c2b767cd831f101</a></p>
<pre><code class="language-solidity">function setApprovalForAll(address operator, bool approved) public override {   
    address msgSender = _msgSender();
    require(operator != msgSender, &quot;ERC721A: approve to caller&quot;);
    bool curValue = _operatorApprovals[msgSender][operator];
    if (curValue != approved) {
        if (approved == true) {
            _beforeApprovalForAll(msgSender);
            _operatorApprovalsNum[msgSender] += 1;
        } else {
            _operatorApprovalsNum[msgSender] -= 1;
        }
    }
    _operatorApprovals[msgSender][operator] = approved;
    emit ApprovalForAll(msgSender, operator, approved);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>approved == true</code></p>
<hr />
<h3>Contract : MercuryLogic</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x033795b498fb4725638454595c2b767cd831f101">0x033795b498fb4725638454595c2b767cd831f101</a></p>
<pre><code class="language-solidity">function setApprovalForAll(address operator, bool approved) public override {   
    address msgSender = _msgSender();
    require(operator != msgSender, &quot;ERC721A: approve to caller&quot;);
    bool curValue = _operatorApprovals[msgSender][operator];
    if (curValue != approved) {
        if (approved == true) {
            _beforeApprovalForAll(msgSender);
            _operatorApprovalsNum[msgSender] += 1;
        } else {
            _operatorApprovalsNum[msgSender] -= 1;
        }
    }
    _operatorApprovals[msgSender][operator] = approved;
    emit ApprovalForAll(msgSender, operator, approved);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>approved == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9fbf94a6ab280851128298b7cb03216d67765a74">0x9fbf94a6ab280851128298b7cb03216d67765a74</a></p>
<pre><code class="language-solidity">function updateSale(address _tokenAddress,uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) onlyAcceptedToken(_tokenAddress) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale      = true;
            sale.amount         = _amount;
            sale.price          = _price;
            sale.tokenAddress   = _tokenAddress;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea332b66ee4b2c3a2d9c9a2f9618c9c94a1e9">0xcafea332b66ee4b2c3a2d9c9a2f9618c9c94a1e9</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8fbabf098c5be616da480560440a7c0ed0783371">0x8fbabf098c5be616da480560440a7c0ed0783371</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8fbabf098c5be616da480560440a7c0ed0783371">0x8fbabf098c5be616da480560440a7c0ed0783371</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8fbabf098c5be616da480560440a7c0ed0783371">0x8fbabf098c5be616da480560440a7c0ed0783371</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa9f1b3a4defc5d52e42660e64b2370fd7835afc0">0xa9f1b3a4defc5d52e42660e64b2370fd7835afc0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa9f1b3a4defc5d52e42660e64b2370fd7835afc0">0xa9f1b3a4defc5d52e42660e64b2370fd7835afc0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa9f1b3a4defc5d52e42660e64b2370fd7835afc0">0xa9f1b3a4defc5d52e42660e64b2370fd7835afc0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa9f1b3a4defc5d52e42660e64b2370fd7835afc0">0xa9f1b3a4defc5d52e42660e64b2370fd7835afc0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe36092d081b25be69777fa05c51f96fc6d91f23">0xbe36092d081b25be69777fa05c51f96fc6d91f23</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe36092d081b25be69777fa05c51f96fc6d91f23">0xbe36092d081b25be69777fa05c51f96fc6d91f23</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe36092d081b25be69777fa05c51f96fc6d91f23">0xbe36092d081b25be69777fa05c51f96fc6d91f23</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe36092d081b25be69777fa05c51f96fc6d91f23">0xbe36092d081b25be69777fa05c51f96fc6d91f23</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe36092d081b25be69777fa05c51f96fc6d91f23">0xbe36092d081b25be69777fa05c51f96fc6d91f23</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe36092d081b25be69777fa05c51f96fc6d91f23">0xbe36092d081b25be69777fa05c51f96fc6d91f23</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe36092d081b25be69777fa05c51f96fc6d91f23">0xbe36092d081b25be69777fa05c51f96fc6d91f23</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMain</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbe36092d081b25be69777fa05c51f96fc6d91f23">0xbe36092d081b25be69777fa05c51f96fc6d91f23</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }

            for (uint j = 0; j &lt; holders.length; j++) {
                compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : MarsGenesisMartiansWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x33a901ee63cc526ac666f39da701cf7cd4215589">0x33a901ee63cc526ac666f39da701cf7cd4215589</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : NFTMarketplaceToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0131dbeb75ebcf1a59f4594c79590166310a14f9">0x0131dbeb75ebcf1a59f4594c79590166310a14f9</a></p>
<pre><code class="language-solidity">function setApprovalForAll(
        address operator,
        bool approved
    ) public virtual override {
        if (isOperatorBlacklisted[operator] &amp;&amp; approved == true)
            revert BlacklistedOperator(operator);
        super.setApprovalForAll(operator, approved);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isOperatorBlacklisted[operator] &amp;&amp; approved == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea2ad994d07bb95008ed5810068546c128895">0xcafea2ad994d07bb95008ed5810068546c128895</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function getOrderInfo(bool _isBuyOrder, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.buyOrders[_price][_number].client;
            _amount = sCVars.buyOrders[_price][_number].amount;
            _orderId = sCVars.buyOrders[_price][_number].orderId;
        }
        else {
            _address = sCVars.sellOrders[_price][_number].client;
            _amount = sCVars.sellOrders[_price][_number].amount;
            _orderId = sCVars.sellOrders[_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc">0xe0097b45d9da23d5d1e1e5fcf5c81674f3196cfc</a></p>
<pre><code class="language-solidity">function getStockOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.stockBuyOrders[_node][_price][_number].client;
            _amount = sCVars.stockBuyOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockBuyOrders[_node][_price][_number].orderId;
        }
        else {
            _address = sCVars.stockSellOrders[_node][_price][_number].client;
            _amount = sCVars.stockSellOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockSellOrders[_node][_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : AgileCycleWithAssistance</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdd28e3c53894fe91c38d3f59796a3dbac3b480dc">0xdd28e3c53894fe91c38d3f59796a3dbac3b480dc</a></p>
<pre><code class="language-solidity">function approveCycle(bool _approved) public {
        require(cycleApproved != true &amp;&amp; roundFailedToStart != true);
        require(msg.sender == juryOperator);
        if (_approved == true) {
            cycleApproved = true;
        } else {
            roundFailedToStart = true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approved == true</code></p>
<hr />
<h3>Contract : AgileArbitrationWithAssistance</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdd28e3c53894fe91c38d3f59796a3dbac3b480dc">0xdd28e3c53894fe91c38d3f59796a3dbac3b480dc</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x63c18e21eed171435b42b7e042f4dcf3602dbec5">0x63c18e21eed171435b42b7e042f4dcf3602dbec5</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x63c18e21eed171435b42b7e042f4dcf3602dbec5">0x63c18e21eed171435b42b7e042f4dcf3602dbec5</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x63c18e21eed171435b42b7e042f4dcf3602dbec5">0x63c18e21eed171435b42b7e042f4dcf3602dbec5</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : NFTSingle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xecdd3aaea990e55be34727e153c1ade3228d6a6a">0xecdd3aaea990e55be34727e153c1ade3228d6a6a</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd0abec1bd8c0d173bcacb6971df07939433cff07">0xd0abec1bd8c0d173bcacb6971df07939433cff07</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function
        require(safetyMode == false, &quot;Safety Mode enabled, wait for new strategy deployment&quot;);

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDArbV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd0abec1bd8c0d173bcacb6971df07939433cff07">0xd0abec1bd8c0d173bcacb6971df07939433cff07</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        require(safetyMode == false, &quot;Safety Mode enabled, wait for new strategy deployment&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                (uint256 sellID, ) = withdrawTokenReservesID(); // These may often be the same tokens
                checkAndSwapTokens(address(0), sellID, lastBuyID);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : ClaimVXDeluxe</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2cea61e0ec92009e6623532413a2961b0e2ca5ff">0x2cea61e0ec92009e6623532413a2961b0e2ca5ff</a></p>
<pre><code class="language-solidity">function claimBearsDeluxe(
        uint16[] calldata _tokenIds,
        bool _forfeith,
        bool payHoney
    ) external payable nonReentrant {
        if (claimingOpen == false) revert ClaimingClosed();

        uint256 i;
        uint16[] memory ids = new uint16[](_tokenIds.length);
        uint256 totalPriceToPay;
        uint256 _price = payHoney ? honeyPrice : price;
        for (i; i &lt; _tokenIds.length; ) {
            unchecked {
                uint16 currentToken = _tokenIds[i];
                if (bearsDeluxe.ownerOf(currentToken) != msg.sender) revert NotOwner();
                if (_forfeith) {
                    if (customVX &gt;= vxDeluxe.MAX_SUPPLY()) {
                        revert MaxSupplyReached();
                    }
                    ids[i] = uint16(++customVX);
                    totalPriceToPay += _price;
                    if (forfeitedIds[currentToken]) revert AlreadyMinted();
                    forfeitIds.push(currentToken);
                    forfeitedIds[currentToken] = true;
                } else {
                    if (vxDeluxe.exists(currentToken)) revert AlreadyMinted();
                    ids[i] = currentToken;
                    totalPriceToPay += _price;
                }
                i++;
            }
        }

        if (payHoney == true) {
            if (honey.balanceOf(msg.sender) &lt; totalPriceToPay) revert WrongAmount();
            honey.burn(msg.sender, totalPriceToPay);
        } else {
            if (msg.value != totalPriceToPay) revert WrongAmount();
        }

        vxDeluxe.mintBatch(msg.sender, ids);
        emit ClaimedBears(msg.sender, ids, _tokenIds);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>payHoney == true</code></p>
<hr />
<h3>Contract : ClaimVXDeluxe</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2cea61e0ec92009e6623532413a2961b0e2ca5ff">0x2cea61e0ec92009e6623532413a2961b0e2ca5ff</a></p>
<pre><code class="language-solidity">function claimBearsDeluxe(
        uint16[] calldata _tokenIds,
        bool _forfeith,
        bool payHoney
    ) external payable nonReentrant {
        if (claimingOpen == false) revert ClaimingClosed();

        uint256 i;
        uint16[] memory ids = new uint16[](_tokenIds.length);
        uint256 totalPriceToPay;
        uint256 _price = payHoney ? honeyPrice : price;
        for (i; i &lt; _tokenIds.length; ) {
            unchecked {
                uint16 currentToken = _tokenIds[i];
                if (bearsDeluxe.ownerOf(currentToken) != msg.sender) revert NotOwner();
                if (_forfeith) {
                    if (customVX &gt;= vxDeluxe.MAX_SUPPLY()) {
                        revert MaxSupplyReached();
                    }
                    ids[i] = uint16(++customVX);
                    totalPriceToPay += _price;
                    if (forfeitedIds[currentToken]) revert AlreadyMinted();
                    forfeitIds.push(currentToken);
                    forfeitedIds[currentToken] = true;
                } else {
                    if (vxDeluxe.exists(currentToken)) revert AlreadyMinted();
                    ids[i] = currentToken;
                    totalPriceToPay += _price;
                }
                i++;
            }
        }

        if (payHoney == true) {
            if (honey.balanceOf(msg.sender) &lt; totalPriceToPay) revert WrongAmount();
            honey.burn(msg.sender, totalPriceToPay);
        } else {
            if (msg.value != totalPriceToPay) revert WrongAmount();
        }

        vxDeluxe.mintBatch(msg.sender, ids);
        emit ClaimedBears(msg.sender, ids, _tokenIds);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>payHoney == true</code></p>
<hr />
<h3>Contract : ClaimVXDeluxe</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2cea61e0ec92009e6623532413a2961b0e2ca5ff">0x2cea61e0ec92009e6623532413a2961b0e2ca5ff</a></p>
<pre><code class="language-solidity">function publicMint(bool payHoney, uint256 _amount) external payable nonReentrant {
        if (publicMintOpen == false) revert PublicMintClosed();
        if (customVX + _amount &gt; vxDeluxe.MAX_SUPPLY()) revert MaxSupplyReached();
        require(_amount &lt;= 10 &amp;&amp; _amount &gt; 0, &quot;Max 10 mint per tx, min 1&quot;);

        uint256 totalPriceToPay;
        uint16[] memory ids = new uint16[](_amount);
        uint256 i;
        uint256 _price = payHoney ? honeyPrice : price;

        for (i; i &lt; _amount; ) {
            unchecked {
                ids[i] = uint16(++customVX);
                totalPriceToPay += _price;
                i++;
            }
        }

        if (payHoney == true) {
            if (honey.balanceOf(msg.sender) &lt; totalPriceToPay) revert WrongAmount();
            honey.burn(msg.sender, totalPriceToPay);
        } else {
            if (msg.value != totalPriceToPay) revert WrongAmount();
        }

        vxDeluxe.mintBatch(msg.sender, ids);
        emit PublicMint(msg.sender, ids);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>payHoney == true</code></p>
<hr />
<h3>Contract : ClaimVXDeluxe</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2cea61e0ec92009e6623532413a2961b0e2ca5ff">0x2cea61e0ec92009e6623532413a2961b0e2ca5ff</a></p>
<pre><code class="language-solidity">function mintSpares(bool payHoney, uint256 _amount) external payable nonReentrant {
        if (publicMintOpen == false) revert PublicMintClosed();
        if (forfeitIndex + _amount &gt; forfeitIds.length) revert MaxSupplyReached();
        require(_amount &lt;= 10 &amp;&amp; _amount &gt; 0, &quot;Max 10 mint per tx, min 1&quot;);

        uint256 i = forfeitIndex;
        uint16[] memory ids = new uint16[](_amount);
        uint256 totalPriceToPay;
        uint256 _price = payHoney ? honeyPrice : price;
        uint256 index;
        for (i; i &lt; forfeitIndex + _amount; ) {
            unchecked {
                require(forfeitedIds[forfeitIds[i]] == true, &quot;bear not foreited&quot;);
                ids[index] = forfeitIds[i];
                totalPriceToPay += _price;
                i++;
                index++;
            }
        }

        forfeitIndex = forfeitIndex + _amount;

        if (payHoney == true) {
            if (honey.balanceOf(msg.sender) &lt; totalPriceToPay) revert WrongAmount();
            honey.burn(msg.sender, totalPriceToPay);
        } else {
            if (msg.value != totalPriceToPay) revert WrongAmount();
        }

        vxDeluxe.mintBatch(msg.sender, ids);
        emit PublicMint(msg.sender, ids);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>payHoney == true</code></p>
<hr />
<h3>Contract : DevWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x417737d49a175d62625154262d8569d3890425ae">0x417737d49a175d62625154262d8569d3890425ae</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(msg.sender == _devMultiSigWalletAddress, &quot;ONLY_DEV_MULTISIG&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : SHABANGERS</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x960bf873da3e1f06a65905456122d6f9d9868648">0x960bf873da3e1f06a65905456122d6f9d9868648</a></p>
<pre><code class="language-solidity">function fuseTokens(uint toFuse, uint toBurn, bytes memory payload, bool burn) external {
        IContractFusion(FusionContractAddress).fuseTokens(msg.sender, toFuse, toBurn, payload);

        if(burn == true)
            _burn(toBurn);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>burn == true</code></p>
<hr />
<h3>Contract : Collateral</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb4d77dd9957c1ebece47d4a6e1e9755b8dcbf9ee">0xb4d77dd9957c1ebece47d4a6e1e9755b8dcbf9ee</a></p>
<pre><code class="language-solidity">function provideCollateralRelief(uint256 _amount, uint256 _rate, uint _option, bool _addRelief) external {
        require(msg.sender == owner);
        require(_rate &gt; 0 &amp;&amp; _rate &lt;= 10000);

        if(_addRelief == true) {
            require(_getAvailableFunds(ERC20(aToken[_option]), _option) &gt;= _amount);
            collateralRelief[_option][_rate] += _amount;
            totalRelief[_option] += _amount;
            StoreHubInterface(storeHub[_option]).callEvent(address(0), _amount, _rate, true, 1);
        }
        else {
            require(collateralRelief[_option][_rate] &gt;= _amount);
            collateralRelief[_option][_rate] -= _amount;
            totalRelief[_option] -= _amount;
            StoreHubInterface(storeHub[_option]).callEvent(address(0), _amount, _rate, false, 1);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_addRelief == true</code></p>
<hr />
<h3>Contract : Collateral</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb4d77dd9957c1ebece47d4a6e1e9755b8dcbf9ee">0xb4d77dd9957c1ebece47d4a6e1e9755b8dcbf9ee</a></p>
<pre><code class="language-solidity">function receiveCollateral(uint256 _amount, uint256 _rate, uint _option, bool _isTrade) external {
        require(StoreHubInterface(storeHub[0]).isValidStore(address(msg.sender))  == true);

        if(_isTrade == true){
            require(collateralRelief[_option][_rate] == _amount);
            collateralRelief[_option][_rate] = 0;
            totalRelief[_option] -= _amount;
        }

        collateral[_option] += _amount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isTrade == true</code></p>
<hr />
<h3>Contract : General</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb4d77dd9957c1ebece47d4a6e1e9755b8dcbf9ee">0xb4d77dd9957c1ebece47d4a6e1e9755b8dcbf9ee</a></p>
<pre><code class="language-solidity">function provideCollateralRelief(uint256 _amount, uint256 _rate, uint _option, bool _addRelief) external {
        require(msg.sender == owner);
        require(_rate &gt; 0 &amp;&amp; _rate &lt;= 10000);

        if(_addRelief == true) {
            require(_getAvailableFunds(ERC20(aToken[_option]), _option) &gt;= _amount);
            collateralRelief[_option][_rate] += _amount;
            totalRelief[_option] += _amount;
            StoreHubInterface(storeHub[_option]).callEvent(address(0), _amount, _rate, true, 1);
        }
        else {
            require(collateralRelief[_option][_rate] &gt;= _amount);
            collateralRelief[_option][_rate] -= _amount;
            totalRelief[_option] -= _amount;
            StoreHubInterface(storeHub[_option]).callEvent(address(0), _amount, _rate, false, 1);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_addRelief == true</code></p>
<hr />
<h3>Contract : General</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb4d77dd9957c1ebece47d4a6e1e9755b8dcbf9ee">0xb4d77dd9957c1ebece47d4a6e1e9755b8dcbf9ee</a></p>
<pre><code class="language-solidity">function receiveCollateral(uint256 _amount, uint256 _rate, uint _option, bool _isTrade) external {
        require(StoreHubInterface(storeHub[0]).isValidStore(address(msg.sender))  == true);

        if(_isTrade == true){
            require(collateralRelief[_option][_rate] == _amount);
            collateralRelief[_option][_rate] = 0;
            totalRelief[_option] -= _amount;
        }

        collateral[_option] += _amount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isTrade == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1_2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x10dfbcfc732467c4cb0e18c21f20f8db54efcab7">0x10dfbcfc732467c4cb0e18c21f20f8db54efcab7</a></p>
<pre><code class="language-solidity">function addorRemoveTokens(address[] memory _addresses, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            TokenAddresses[_addresses[i]] = _isAdded;
            if (_isAdded == true) {
                emit TokenAdded(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1_2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x10dfbcfc732467c4cb0e18c21f20f8db54efcab7">0x10dfbcfc732467c4cb0e18c21f20f8db54efcab7</a></p>
<pre><code class="language-solidity">function addTokenPayments(address[] memory _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        for (uint256 i = 0; i &lt; _address.length; i++) {
            TokenPaymentAddresses[_address[i]] = _isAdded;
            if (_isAdded == true) {
                emit AddedTokenPayment(_address[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : AVEC</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa2e5833d7d6ca149475005eb1f2ddccb61c04e95">0xa2e5833d7d6ca149475005eb1f2ddccb61c04e95</a></p>
<pre><code class="language-solidity">function createEscrowForProperty(
          bytes32 _PropertyID, 
          address payable _recipientOfFunds, 
          bytes32 _recipientName, 
          uint8 _escrowAgreementNumber,
          bool _override,
          bool _escrowCompleted,
          uint256 _milestonePriceOfEscrowInETH, 
          uint256 _tokensAvailableTotal,
          uint256 _propertyIncrease
          )
          public {
              requireUserPrivilegeLevel(3, msg.sender);
              uint8 _localEscrowAgreementNumber;
              if(Properties[_PropertyID].firstEscrowSet != true){
                  _localEscrowAgreementNumber = 0;
                  Properties[_PropertyID].currentEscrowAgreementNumber = 0;
                  Properties[_PropertyID].firstEscrowSet = true;
              } else {
                  _localEscrowAgreementNumber = uint8(Properties[_PropertyID].currentEscrowAgreementNumber + 1); 
              }
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].PropertyID = _PropertyID;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientOfFunds = _recipientOfFunds;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientName = _recipientName;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH = _milestonePriceOfEscrowInETH;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableTotal = _tokensAvailableTotal;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableCurrent = _tokensAvailableTotal;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].ethPerToken = divi(_milestonePriceOfEscrowInETH, _tokensAvailableTotal);
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowCompleted = _escrowCompleted;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].propertyIncrease = _propertyIncrease;
              ETHERESCROWED += GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH;
              if(_override == true){
                 GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _escrowAgreementNumber; 
              } else {
                  GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _localEscrowAgreementNumber;
              }
              Properties[_PropertyID].escrowAgreementNumber.push(GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber);
              bytes32 prop = _PropertyID;
              emit EscrowCreated(msg.sender, _recipientOfFunds,  _recipientName, _milestonePriceOfEscrowInETH, _tokensAvailableTotal, prop, _localEscrowAgreementNumber);
      }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_override == true</code></p>
<hr />
<h3>Contract : AVEC</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa2e5833d7d6ca149475005eb1f2ddccb61c04e95">0xa2e5833d7d6ca149475005eb1f2ddccb61c04e95</a></p>
<pre><code class="language-solidity">function createEscrowForProperty(
          bytes32 _PropertyID, 
          address payable _recipientOfFunds, 
          bytes32 _recipientName, 
          uint8 _escrowAgreementNumber,
          bool _override,
          bool _escrowCompleted,
          uint256 _milestonePriceOfEscrowInETH, 
          uint256 _tokensAvailableTotal,
          uint256 _propertyIncrease
          )
          public {
              requireUserPrivilegeLevel(3, msg.sender);
              uint8 _localEscrowAgreementNumber;
              if(Properties[_PropertyID].firstEscrowSet != true){
                  _localEscrowAgreementNumber = 0;
                  Properties[_PropertyID].currentEscrowAgreementNumber = 0;
                  Properties[_PropertyID].firstEscrowSet = true;
              } else {
                  _localEscrowAgreementNumber = uint8(Properties[_PropertyID].currentEscrowAgreementNumber + 1); 
              }
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].PropertyID = _PropertyID;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientOfFunds = _recipientOfFunds;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientName = _recipientName;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH = _milestonePriceOfEscrowInETH;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableTotal = _tokensAvailableTotal;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableCurrent = _tokensAvailableTotal;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].ethPerToken = divi(_milestonePriceOfEscrowInETH, _tokensAvailableTotal);
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowCompleted = _escrowCompleted;
              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].propertyIncrease = _propertyIncrease;
              ETHERESCROWED += GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH;
              if(_override == true){
                 GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _escrowAgreementNumber; 
              } else {
                  GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _localEscrowAgreementNumber;
              }
              Properties[_PropertyID].escrowAgreementNumber.push(GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber);
              bytes32 prop = _PropertyID;
              emit EscrowCreated(msg.sender, _recipientOfFunds,  _recipientName, _milestonePriceOfEscrowInETH, _tokensAvailableTotal, prop, _localEscrowAgreementNumber);
      }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_override == true</code></p>
<hr />
<h3>Contract : FDCGov</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7be10844c2d078175ab347ff9b05470c4f0bc43f">0x7be10844c2d078175ab347ff9b05470c4f0bc43f</a></p>
<pre><code class="language-solidity">function vote(address proposalAddress, bool forVote) external returns(bool) {
    require(proposals[proposalAddress].state == 1, 'Proposal needs to be open');
    require(WFDCToken.balanceOf(msg.sender) &gt; 0, 'Need tokens to vote');
    require(proposals[proposalAddress].votes[msg.sender].startBlock != proposals[proposalAddress].startBlock, 'Can only vote once per proposal');
    if (forVote == true) {
      proposals[proposalAddress].totalVotesFor += WFDCToken.balanceOf(msg.sender);
    } else {
      proposals[proposalAddress].totalVotesAgainst += WFDCToken.balanceOf(msg.sender);
    }
    proposals[proposalAddress].votes[msg.sender].amount += WFDCToken.balanceOf(msg.sender);
    proposals[proposalAddress].votes[msg.sender].forVote = forVote;
    proposals[proposalAddress].votes[msg.sender].startBlock = proposals[proposalAddress].startBlock;
    return true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>forVote == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8c06cdf2147c029180c5c817f082c67c1462283c">0x8c06cdf2147c029180c5c817f082c67c1462283c</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    delegatedOnly
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call{value:(executions[_id].value)}(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : The_Starry_Night_Animated</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x191898dd4ccaeb37ab5d45a7d6b4d959fc56b96d">0x191898dd4ccaeb37ab5d45a7d6b4d959fc56b96d</a></p>
<pre><code class="language-solidity">function mintForAll(uint256 amount, bool _isUK) external payable {
        require(mintStarted == true, &quot;Minting is not yet open.&quot;);
        require(publicMintCount + amount &lt;= publicMintSupply, &quot;Sold Out.&quot;);
        require(amount &lt;= MAX_MINT_PER_ACCOUNT, &quot;Amount Exceeds Maximum Mints Allowed Per Account.&quot;);
        require(userNftCount[msg.sender] + amount &lt;= MAX_MINT_PER_ACCOUNT, &quot;You can not mint more than Max Mint Limit.&quot;);
        require(_totalMinted() + amount &lt;= MAX_SUPPLY , &quot;Exceeds Maximum Supply&quot; );
        uint totalCost = amount * mintPrice;
        if (_isUK == true) {
            totalCost = totalCost * 120 / 100; // add 20% VAT tax for UK
        }        
        require( msg.value &gt;= totalCost, &quot;Ether sent is not correct.&quot; );
        _mintRandom(msg.sender, amount);
        publicMintCount += amount;
        userNftCount[msg.sender] += amount;
        if (msg.value &gt; totalCost) {
            payable(msg.sender).transfer(msg.value - totalCost);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isUK == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbc4efe38e1c6172d587efcde0f5b98a24f145911">0xbc4efe38e1c6172d587efcde0f5b98a24f145911</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : Exchange</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd2a7dc131cc43ca4f2de5ab71ee919eddf20109b">0xd2a7dc131cc43ca4f2de5ab71ee919eddf20109b</a></p>
<pre><code class="language-solidity">function closeFuturesPosition (bytes32 futuresContract, bool side)
    {
        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);

        if (futuresContracts[futuresContract].closed == false &amp;&amp; futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled
        if (retrievePosition(positionHash)[1] == 0) throw; // position not found
        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed

        uint256 profit;
        uint256 loss;

        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;

        FuturesClosePositionValues memory v = FuturesClosePositionValues({
            reserve         : EtherMium(exchangeContract).getReserve(baseToken, msg.sender),
            balance         : EtherMium(exchangeContract).balanceOf(baseToken, msg.sender),
            floorPrice      : futuresContracts[futuresContract].floorPrice,
            capPrice        : futuresContracts[futuresContract].capPrice,
            closingPrice    : futuresContracts[futuresContract].closingPrice,
            futuresContract : futuresContract
        });

        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);
        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);
        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;
        // uint256 capPrice = futuresContracts[futuresContract].capPrice;
        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;



        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);
        uint256 fee = calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract);



        // close long position
        if (side == true)
        {            

            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);
            // return;
            // reserve = reserve - (entryPrice - floorPrice) * size;
            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));


            subReserve(
                baseToken, 
                msg.sender, 
                v.reserve, 
                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice
                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &gt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);



                // LogUint(15, profit);
                // LogUint(16, fee);
                // LogUint(17, safeSub(profit * 1e10, fee));
                // return;

                addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10));
                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  


                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }   
        // close short position 
        else
        {
            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);
            // return;

            // reserve = reserve - (capPrice - entryPrice) * size;
            subReserve(
                baseToken, 
                msg.sender,  
                v.reserve, 
                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice
                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &lt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                // profit = (entryPrice - closingPrice) * size
                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);

                addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                // profit = (closingPrice - entryPrice) * size
                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  

                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }  

        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount
        updatePositionSize(positionHash, 0, 0);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>side == true</code></p>
<hr />
<h3>Contract : DaoStructs</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd6cc644492f4f1be1e8bf255f1c179fba07d5464">0xd6cc644492f4f1be1e8bf255f1c179fba07d5464</a></p>
<pre><code class="language-solidity">function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)
        external
        view
        returns (address[] memory _voters, uint256 _length)
    {
        uint256 _n = _allUsers.length;
        uint256 i;
        _length = 0;
        _voters = new address[](_n);
        if (_vote == true) {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.yesVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        } else {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.noVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb864607dc7f7c4ffdc9620697f9000883667e4a7">0xb864607dc7f7c4ffdc9620697f9000883667e4a7</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb864607dc7f7c4ffdc9620697f9000883667e4a7">0xb864607dc7f7c4ffdc9620697f9000883667e4a7</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb864607dc7f7c4ffdc9620697f9000883667e4a7">0xb864607dc7f7c4ffdc9620697f9000883667e4a7</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Moartroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb864607dc7f7c4ffdc9620697f9000883667e4a7">0xb864607dc7f7c4ffdc9620697f9000883667e4a7</a></p>
<pre><code class="language-solidity">function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {
        require(rewardClaimEnabled, &quot;reward claim is disabled&quot;);
        for (uint i = 0; i &lt; mTokens.length; i++) {
            MToken mToken = mTokens[i];
            require(markets[address(mToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});
                updateMoarBorrowIndex(address(mToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateMoarSupplyIndex(address(mToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierMoar(address(mToken), holders[j]);
                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafeada57182b2de3a81b7d8d97a7a223ff9c978">0xcafeada57182b2de3a81b7d8d97a7a223ff9c978</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : AdapterManager</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8610f734cb2001a3ab7ed7a8a0da898776d99da9">0x8610f734cb2001a3ab7ed7a8a0da898776d99da9</a></p>
<pre><code class="language-solidity">function setPause(bool val) external {
        if (val == true) {
            require(
                suspendPermissions[msg.sender] || msg.sender == owner(),
                &quot;verification failed.&quot;
            );
        } else {
            require(msg.sender == TIMELOCK_ADDRESS, &quot;verification failed.&quot;);
        }
        _paused = val;
        if (_paused) {
            emit Paused();
        } else {
            emit Unpaused();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>val == true</code></p>
<hr />
<h3>Contract : Bundles</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1dbf0d60463e943e3aafa9d0608fb3d30f9dd39a">0x1dbf0d60463e943e3aafa9d0608fb3d30f9dd39a</a></p>
<pre><code class="language-solidity">function updatebal(address _user,uint256 _bundleId,uint256 _reward,bool _isPositive) public returns(bool){
        require(msg.sender == owner,'Not Owner');
        require(_reward &lt;= 12000000,'Invalid Reward Percent');
        User storage us = user[_user];
        require(us.active == true,'Invalid User');
        UserBets storage u = bets[_user][_bundleId];
        require(u.claimed == false,'Already Claimed');
        uint256 a = SafeMath.mul(u.totalbet,_reward);
        uint256 b = SafeMath.div(a,10**8);
        if(_isPositive == true){
            uint256 c = SafeMath.add(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        else{
            uint256 c = SafeMath.sub(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isPositive == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xad45d7e5ac29f888d0a7f007bbb73210ebc153b2">0xad45d7e5ac29f888d0a7f007bbb73210ebc153b2</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external override moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                IModule(_module).init(address(this));
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: cannot remove last module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7cbe5682be6b648cc1100c76d4f6c96997f753d6">0x7cbe5682be6b648cc1100c76d4f6c96997f753d6</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfcfab7cdc0613fea78982ebd52559b7362db7976">0xfcfab7cdc0613fea78982ebd52559b7362db7976</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : RafldexPVP_V1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfa1cf7227848472d7df9113cf62f19840ce8f2d3">0xfa1cf7227848472d7df9113cf62f19840ce8f2d3</a></p>
<pre><code class="language-solidity">function addorRemoveTokens(address[] memory _addresses, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            TokenAddresses[_addresses[i]] = _isAdded;
            if (_isAdded == true) {
                emit TokenAdded(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2a3e411b9bcf6729059d0a62f0488b589a1a4f98">0x2a3e411b9bcf6729059d0a62f0488b589a1a4f98</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2a3e411b9bcf6729059d0a62f0488b589a1a4f98">0x2a3e411b9bcf6729059d0a62f0488b589a1a4f98</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : shiAIStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa84010f33d209a370fcddf93bf07f2c2f444efca">0xa84010f33d209a370fcddf93bf07f2c2f444efca</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(93).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(shiAIToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : shiAIStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa84010f33d209a370fcddf93bf07f2c2f444efca">0xa84010f33d209a370fcddf93bf07f2c2f444efca</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(93).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(shiAIToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd45a727684d25342ea2900cc6e0a157ead912141">0xd45a727684d25342ea2900cc6e0a157ead912141</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            checkAndSellStables();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd45a727684d25342ea2900cc6e0a157ead912141">0xd45a727684d25342ea2900cc6e0a157ead912141</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // When a user withdraws, we need to pull the tokens out of the contract
        if(nonContract == true){
            checkAndSellStables();
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }        

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcfbbfd727d8dcdd979e6c7b84e1d8980bbe0277a">0xcfbbfd727d8dcdd979e6c7b84e1d8980bbe0277a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcfbbfd727d8dcdd979e6c7b84e1d8980bbe0277a">0xcfbbfd727d8dcdd979e6c7b84e1d8980bbe0277a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcfbbfd727d8dcdd979e6c7b84e1d8980bbe0277a">0xcfbbfd727d8dcdd979e6c7b84e1d8980bbe0277a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcfbbfd727d8dcdd979e6c7b84e1d8980bbe0277a">0xcfbbfd727d8dcdd979e6c7b84e1d8980bbe0277a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyAMPLArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x87e8feb7a28f55f9ae9abe0a426eb3af55fa1910">0x87e8feb7a28f55f9ae9abe0a426eb3af55fa1910</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : OasisAuctionHouse</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1a6e04d507f19374a1480d11f07f025a902dd981">0x1a6e04d507f19374a1480d11f07f025a902dd981</a></p>
<pre><code class="language-solidity">function createBid(uint256 _currentTokenId, bool _standing) external payable nonReentrant  onlyUnpaused {

        // Query the auction state
        IAuctionHouse.Auction memory _auction = auction; 

        // Check that the auction is live
        require(_currentTokenId == _auction.tokenId, 'Bid on wrong tokenId.');
        require(block.timestamp &lt; _auction.endTime, &quot;Auction has ended&quot;);
        require(block.timestamp &gt; _auction.startTime, &quot;Auction has not started&quot;);
        require(msg.value &gt;= minimumBid, &quot;Bid is too low.&quot;);
        require(
            msg.value &gt;= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100), 
            &quot;Bid is too low.&quot;
        );

        // A reference to benchmark the new bid against
        address payable lastBidder = _auction.bidder;

        // Refund the previous highest bidder,
        // if not standing bid
        if (lastBidder != address(0) &amp;&amp; Bids[lastBidder].standing == false &amp;&amp; Bids[msg.sender].refunded == false) {
            _safeTransferETH(lastBidder, _auction.amount);
            Bids[lastBidder].refunded = true;
        }

        // if overbidding self, remove old bid
        // clear standing bids from same sender
        if (Bids[msg.sender].refunded == false) {
            if (Bids[msg.sender].standing == true) {
                // loop through standing bidders and remove the address
                for (uint i = 0; i &lt; standingBidders.length; i++) {
                    if (standingBidders[i] == msg.sender) {
                        standingBidders[i] = standingBidders[standingBidders.length - 1];
                        standingBidders.pop();
                        break;
                    }
                }
            }
            _safeTransferETH(msg.sender, Bids[msg.sender].amount);
            Bids[msg.sender].refunded = true;
        }

        Bid memory new_bid;
        new_bid.bidder = payable(msg.sender);
        new_bid.amount = msg.value;
        new_bid.timestamp = block.timestamp;
        new_bid.winner = false;
        new_bid.refunded = false;
        new_bid.standing = _standing;
        Bids[msg.sender] = new_bid;

        if (_standing == true) {
            standingBidders.push(msg.sender);
        }

        // Update the auction state with the new bid bidder and the new amount
        auction.bidder = payable(msg.sender);
        auction.amount = msg.value;


        // Extend the auction if the bid was received within the time buffer
        bool extended = _auction.endTime - block.timestamp &lt; timeBuffer;
        if (extended) {
            auction.endTime = _auction.endTime = _auction.endTime + timeBuffer;
            auction.extendedTime = _auction.extendedTime + timeBuffer;
        }

        emit AuctionBid(currentTokenId, msg.sender, Bids[msg.sender].amount, _standing, extended, false); 

        if (extended) {
            emit AuctionExtended(currentTokenId, _auction.endTime);
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_standing == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyREETHArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x180eac22d6f7bac509978ac9be3ca6e2c1754da9">0x180eac22d6f7bac509978ac9be3ca6e2c1754da9</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyREETHArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x180eac22d6f7bac509978ac9be3ca6e2c1754da9">0x180eac22d6f7bac509978ac9be3ca6e2c1754da9</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){ }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance(); // Returns the normalized balance
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrderWithOracle(_depositor, _myBalance, false); // This will withdraw based on order
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrderWithOracle(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8117090983d5e74c2b4e632e94e3d5aca95481a4">0x8117090983d5e74c2b4e632e94e3d5aca95481a4</a></p>
<pre><code class="language-solidity">function updateSale(uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale  = true;
            sale.amount     = _amount;
            sale.price      = _price;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : AddressesGeneratorEarn</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf536399c04683d7ab0bcb1308c245b4bbb539344">0xf536399c04683d7ab0bcb1308c245b4bbb539344</a></p>
<pre><code class="language-solidity">function setAssetDeprecated(address assetAddress, bool newDeprecationStatus)
        public
        onlyManagers
    {
        bool currentDeprecationStatus = assetDeprecated[assetAddress];
        if (currentDeprecationStatus == newDeprecationStatus) {
            revert(&quot;Generator: Unable to change asset deprecation status&quot;);
        }
        if (newDeprecationStatus == true) {
            numberOfDeprecatedAssets++;
        } else {
            numberOfDeprecatedAssets--;
        }
        assetDeprecated[assetAddress] = newDeprecationStatus;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>newDeprecationStatus == true</code></p>
<hr />
<h3>Contract : SPJVoting</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa58e3cac82d5c041ef5dc69790450f32ded133e0">0xa58e3cac82d5c041ef5dc69790450f32ded133e0</a></p>
<pre><code class="language-solidity">function voteProposal(string memory proposal, bool choice) public override {
        require(!isBlocked(msg.sender), &quot;Sender is blocked&quot;);
        require(proposals[proposal].exists, &quot;proposal does not exist&quot;);
        require(proposals[proposal].proposalStatus != Status.Closed, &quot;proposal has been closed&quot;);
        require(proposals[proposal].startTime &lt;= uint40(block.timestamp), &quot;Not allowed to Vote yet&quot;);
        require(proposals[proposal].endTime &gt; uint40(block.timestamp), &quot;Voting has ended&quot;);

        uint256 amount;

        proposals[proposal].voteCount += 1;
        if(choice == true){
            votingAmount[msg.sender][proposal].approvedTimes += 1;
            proposals[proposal].votes.approvals += 1;
            amount = votingAmount[msg.sender][proposal].approvedTimes * votingAmount[msg.sender][proposal].approvedTimes;
        }
        else{
            votingAmount[msg.sender][proposal].dissaprovedTimes += 1;
            proposals[proposal].votes.disapprovals += 1;
            amount = votingAmount[msg.sender][proposal].dissaprovedTimes * votingAmount[msg.sender][proposal].dissaprovedTimes;
        }
        voters[proposal].proposal = proposal;
        voters[proposal].voterAddress = msg.sender;
        voters[proposal].vote = choice;
        voters[proposal].timestamp = uint40(block.timestamp);

        allVoters.push(voters[proposal]);
        IERC20(SPJ).transferFrom(msg.sender, address(this), (amount * 10 ** uint256(decimals)));
        emit votedProposal(proposal, choice);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>choice == true</code></p>
<hr />
<h3>Contract : BaseVault</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x20f6b1afba9038c1bdc49e2e9b9e7f47e2bfffe5">0x20f6b1afba9038c1bdc49e2e9b9e7f47e2bfffe5</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value, bytes32 _initData) external override moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                IModule(_module).init(address(this), _initData);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: cannot remove last module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : AgreementContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7d9e7ca33fea93477dcdf856656581f436639905">0x7d9e7ca33fea93477dcdf856656581f436639905</a></p>
<pre><code class="language-solidity">function approveMilestone(
        uint256 _agreementID,
        string memory _employerID,
        uint256 _milesID,
        bool status,
        address receiver
    ) public {

        require(keccak256(bytes(agreementDetails[_agreementID].employerID)) == keccak256(bytes(_employerID)), &quot;Only Employer&quot;);
        require(contractCancelled[_agreementID] != true, &quot;Agreement cancelled&quot;);
        require(milestoneDetails[_agreementID][_milesID].Approve != true, &quot;Milestone already approved&quot;);
        require(milestoneDetails[_agreementID][_milesID].delivered == true, &quot;Milestone not delivered&quot;);
        require(fundTransfered[_agreementID][_milesID] != true, &quot;Milestone already released&quot;);

        for (uint256 i = 0; i &lt; agreementDetails[_agreementID].milstones.length; i++) {
            if (_milesID == agreementDetails[_agreementID].milstones[i]) {
                milestoneDetails[_agreementID][_milesID].Approve = status;

                if(status == true) {
                    uint amount = milestoneDetails[_agreementID][i].Mile_Price.mul(1e18).div(getLatestPrice());
                    uint fee = amount.mul(milestonefee).div(10000);
                    payable(owner).transfer(fee);
                    payable(receiver).transfer(amount.sub(fee));
                    AdminCommissionFee = AdminCommissionFee.add(fee);
                    escrowAmount[_agreementID][_milesID] = escrowAmount[_agreementID][_milesID].sub(amount);
                    fundTransfered[_agreementID][_milesID] = true;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>status == true</code></p>
<hr />
<h3>Contract : ArbitrationX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5f8a93087c32dd3100a790953dd0436d3e70039c">0x5f8a93087c32dd3100a790953dd0436d3e70039c</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        /* require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true); */
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : Manager</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4d6283b4198c0039f2addc6a8784bbdef6e259eb">0x4d6283b4198c0039f2addc6a8784bbdef6e259eb</a></p>
<pre><code class="language-solidity">constructor(address _vrfCoordinator, address _linkToken, bytes32 _keyHash, bool _mainetFee)
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10**18;// in mainnet, the fee must be 2 LINK
        else fee =  0.1 * 10**18; // 0.1 LINK In Rinkeby and Goerli         
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x092513c950d06ecca1be16ccdfe8b4826c2035dc">0x092513c950d06ecca1be16ccdfe8b4826c2035dc</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + hightLightFee);
                } else {
                    require(msg.value == limitETHFee + hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x092513c950d06ecca1be16ccdfe8b4826c2035dc">0x092513c950d06ecca1be16ccdfe8b4826c2035dc</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : SocialMediaThread</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x082d7a62142941aa13b2cc957accfe30b5a45d69">0x082d7a62142941aa13b2cc957accfe30b5a45d69</a></p>
<pre><code class="language-solidity">function likeComment(uint _threadID, uint _commentId, bool _val) public isValidComment(_threadID, _commentId){
        if (Threads[_threadID].comments[_commentId].hasLiked[msg.sender] == true &amp;&amp; _val == false) {
            Threads[_threadID].comments[_commentId].likes --;
            Threads[_threadID].comments[_commentId].hasLiked[msg.sender] = false;
        } else if (Threads[_threadID].comments[_commentId].hasLiked[msg.sender] == false &amp;&amp; _val == true) {
            Threads[_threadID].comments[_commentId].likes ++;
            Threads[_threadID].comments[_commentId].hasLiked[msg.sender] = true;
        } else {
            revert(&quot;Invalid operation&quot;);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>Threads[_threadID].comments[_commentId].hasLiked[msg.sender] == true &amp;&amp; _val == false</code></p>
<hr />
<h3>Contract : SocialMediaThread</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x082d7a62142941aa13b2cc957accfe30b5a45d69">0x082d7a62142941aa13b2cc957accfe30b5a45d69</a></p>
<pre><code class="language-solidity">function likeComment(uint _threadID, uint _commentId, bool _val) public isValidComment(_threadID, _commentId){
        if (Threads[_threadID].comments[_commentId].hasLiked[msg.sender] == true &amp;&amp; _val == false) {
            Threads[_threadID].comments[_commentId].likes --;
            Threads[_threadID].comments[_commentId].hasLiked[msg.sender] = false;
        } else if (Threads[_threadID].comments[_commentId].hasLiked[msg.sender] == false &amp;&amp; _val == true) {
            Threads[_threadID].comments[_commentId].likes ++;
            Threads[_threadID].comments[_commentId].hasLiked[msg.sender] = true;
        } else {
            revert(&quot;Invalid operation&quot;);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>Threads[_threadID].comments[_commentId].hasLiked[msg.sender] == false &amp;&amp; _val == true</code></p>
<hr />
<h3>Contract : SocialMediaThread</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x082d7a62142941aa13b2cc957accfe30b5a45d69">0x082d7a62142941aa13b2cc957accfe30b5a45d69</a></p>
<pre><code class="language-solidity">function likeThread(uint _threadID, bool _val) public isValidThread(_threadID) {
        if (Threads[_threadID].hasLiked[msg.sender] == true &amp;&amp; _val == false) {
            Threads[_threadID].likes --;
            Threads[_threadID].hasLiked[msg.sender] = false;
        } else if (Threads[_threadID].hasLiked[msg.sender] == false &amp;&amp; _val == true) {
            Threads[_threadID].likes ++;
            Threads[_threadID].hasLiked[msg.sender] = true;
        } else {
            revert(&quot;Invalid operation&quot;);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>Threads[_threadID].hasLiked[msg.sender] == true &amp;&amp; _val == false</code></p>
<hr />
<h3>Contract : SocialMediaThread</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x082d7a62142941aa13b2cc957accfe30b5a45d69">0x082d7a62142941aa13b2cc957accfe30b5a45d69</a></p>
<pre><code class="language-solidity">function likeThread(uint _threadID, bool _val) public isValidThread(_threadID) {
        if (Threads[_threadID].hasLiked[msg.sender] == true &amp;&amp; _val == false) {
            Threads[_threadID].likes --;
            Threads[_threadID].hasLiked[msg.sender] = false;
        } else if (Threads[_threadID].hasLiked[msg.sender] == false &amp;&amp; _val == true) {
            Threads[_threadID].likes ++;
            Threads[_threadID].hasLiked[msg.sender] = true;
        } else {
            revert(&quot;Invalid operation&quot;);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>Threads[_threadID].hasLiked[msg.sender] == false &amp;&amp; _val == true</code></p>
<hr />
<h3>Contract : evaiStableCoinFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc1ad1eb79ccadd578a190e6e602d63e44c3681db">0xc1ad1eb79ccadd578a190e6e602d63e44c3681db</a></p>
<pre><code class="language-solidity">function withdraw(
        uint32 _stakeID,
        bool _full,
        uint64 _withdrawAmount
    ) external nonReentrant {
        require(
            stakeByID[_stakeID].ownerAddress == msg.sender,
            &quot;Unauthorized Stake owner&quot;
        );
        require(stakeByID[_stakeID].active == true, &quot;Stake was settled&quot;);
        uint256 elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
            uint256(stakeByID[_stakeID].startOfTerm),
            uint256(block.timestamp)
        );
        uint256 totalReturns;
        uint256 stakeReturns;
        uint256 rewardEndTime;
        if (elapsedTime &lt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm) {
            totalReturns = compound(
                (stakeByID[_stakeID].evaiAmount),
                (stakeTypes[stakeByID[_stakeID].Type].percentageReturn),
                elapsedTime
            );
            stakeReturns = totalReturns - stakeByID[_stakeID].evaiAmount;
        } else if (
            elapsedTime == stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            totalReturns = (stakeByID[_stakeID].evaiAmount *
                (stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier));
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        } else if (
            elapsedTime &gt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            uint256 daysForYearInProgress = elapsedTime.mod(
                uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
            );
            uint256 completedYears = (elapsedTime.sub(daysForYearInProgress))
                .div(uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm));

            rewardEndTime = BokkyPooBahsDateTimeLibrary.addDays(
                uint256(stakeByID[_stakeID].startOfTerm),
                uint256(
                    (completedYears + 1) *
                        uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                )
            );

            if (rewardEndTime &lt; uint256(block.timestamp)) {
                // Calculated elapsed time again
                elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
                    uint256(stakeByID[_stakeID].startOfTerm),
                    rewardEndTime
                );

                daysForYearInProgress = elapsedTime.mod(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
                completedYears = (elapsedTime.sub(daysForYearInProgress)).div(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
            }

            uint256 bMul = uint256(
                stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier
            );

            uint256 postBonusBalance = calculatePostBonusBalance(
                uint256(stakeByID[_stakeID].evaiAmount),
                completedYears,
                bMul
            );

            uint256 pReturns = stakeTypes[stakeByID[_stakeID].Type]
                .percentageReturn;

            totalReturns = compound(
                postBonusBalance,
                pReturns,
                daysForYearInProgress
            );
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        }

        if (_full == true) {
            stakeByID[_stakeID].partialWithdrawn = false;
            stakeByID[_stakeID].settlementAmount = uint64(totalReturns);
            stakeByID[_stakeID].stakeReturns = uint64(stakeReturns);
        } else {
            require(
                _withdrawAmount &lt;= uint64(totalReturns),
                &quot;Amount to claim is higher than returns&quot;
            );
            stakeByID[_stakeID].settlementAmount = _withdrawAmount;
        }

        if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            //Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            totalProfitsDistrubuted += stakeByID[_stakeID].stakeReturns;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
        } else if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            emitWithdrawStake(_stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            // Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
            // restake with the remaining amount
            uint8 Type = stakeByID[_stakeID].Type;
            uint256 reStakeAmount = totalReturns -
                (stakeByID[_stakeID].settlementAmount);
            reStake(uint64(reStakeAmount), Type, _stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            emitWithdrawStake(_stakeID);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_full == true</code></p>
<hr />
<h3>Contract : evaiStableCoinFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc1ad1eb79ccadd578a190e6e602d63e44c3681db">0xc1ad1eb79ccadd578a190e6e602d63e44c3681db</a></p>
<pre><code class="language-solidity">function withdraw(
        uint32 _stakeID,
        bool _full,
        uint64 _withdrawAmount
    ) external nonReentrant {
        require(
            stakeByID[_stakeID].ownerAddress == msg.sender,
            &quot;Unauthorized Stake owner&quot;
        );
        require(stakeByID[_stakeID].active == true, &quot;Stake was settled&quot;);
        uint256 elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
            uint256(stakeByID[_stakeID].startOfTerm),
            uint256(block.timestamp)
        );
        uint256 totalReturns;
        uint256 stakeReturns;
        uint256 rewardEndTime;
        if (elapsedTime &lt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm) {
            totalReturns = compound(
                (stakeByID[_stakeID].evaiAmount),
                (stakeTypes[stakeByID[_stakeID].Type].percentageReturn),
                elapsedTime
            );
            stakeReturns = totalReturns - stakeByID[_stakeID].evaiAmount;
        } else if (
            elapsedTime == stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            totalReturns = (stakeByID[_stakeID].evaiAmount *
                (stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier));
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        } else if (
            elapsedTime &gt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            uint256 daysForYearInProgress = elapsedTime.mod(
                uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
            );
            uint256 completedYears = (elapsedTime.sub(daysForYearInProgress))
                .div(uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm));

            rewardEndTime = BokkyPooBahsDateTimeLibrary.addDays(
                uint256(stakeByID[_stakeID].startOfTerm),
                uint256(
                    (completedYears + 1) *
                        uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                )
            );

            if (rewardEndTime &lt; uint256(block.timestamp)) {
                // Calculated elapsed time again
                elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
                    uint256(stakeByID[_stakeID].startOfTerm),
                    rewardEndTime
                );

                daysForYearInProgress = elapsedTime.mod(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
                completedYears = (elapsedTime.sub(daysForYearInProgress)).div(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
            }

            uint256 bMul = uint256(
                stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier
            );

            uint256 postBonusBalance = calculatePostBonusBalance(
                uint256(stakeByID[_stakeID].evaiAmount),
                completedYears,
                bMul
            );

            uint256 pReturns = stakeTypes[stakeByID[_stakeID].Type]
                .percentageReturn;

            totalReturns = compound(
                postBonusBalance,
                pReturns,
                daysForYearInProgress
            );
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        }

        if (_full == true) {
            stakeByID[_stakeID].partialWithdrawn = false;
            stakeByID[_stakeID].settlementAmount = uint64(totalReturns);
            stakeByID[_stakeID].stakeReturns = uint64(stakeReturns);
        } else {
            require(
                _withdrawAmount &lt;= uint64(totalReturns),
                &quot;Amount to claim is higher than returns&quot;
            );
            stakeByID[_stakeID].settlementAmount = _withdrawAmount;
        }

        if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            //Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            totalProfitsDistrubuted += stakeByID[_stakeID].stakeReturns;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
        } else if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            emitWithdrawStake(_stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            // Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
            // restake with the remaining amount
            uint8 Type = stakeByID[_stakeID].Type;
            uint256 reStakeAmount = totalReturns -
                (stakeByID[_stakeID].settlementAmount);
            reStake(uint64(reStakeAmount), Type, _stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            emitWithdrawStake(_stakeID);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))</code></p>
<hr />
<h3>Contract : evaiStableCoinFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc1ad1eb79ccadd578a190e6e602d63e44c3681db">0xc1ad1eb79ccadd578a190e6e602d63e44c3681db</a></p>
<pre><code class="language-solidity">function withdraw(
        uint32 _stakeID,
        bool _full,
        uint64 _withdrawAmount
    ) external nonReentrant {
        require(
            stakeByID[_stakeID].ownerAddress == msg.sender,
            &quot;Unauthorized Stake owner&quot;
        );
        require(stakeByID[_stakeID].active == true, &quot;Stake was settled&quot;);
        uint256 elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
            uint256(stakeByID[_stakeID].startOfTerm),
            uint256(block.timestamp)
        );
        uint256 totalReturns;
        uint256 stakeReturns;
        uint256 rewardEndTime;
        if (elapsedTime &lt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm) {
            totalReturns = compound(
                (stakeByID[_stakeID].evaiAmount),
                (stakeTypes[stakeByID[_stakeID].Type].percentageReturn),
                elapsedTime
            );
            stakeReturns = totalReturns - stakeByID[_stakeID].evaiAmount;
        } else if (
            elapsedTime == stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            totalReturns = (stakeByID[_stakeID].evaiAmount *
                (stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier));
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        } else if (
            elapsedTime &gt; stakeTypes[stakeByID[_stakeID].Type].bonusTerm
        ) {
            uint256 daysForYearInProgress = elapsedTime.mod(
                uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
            );
            uint256 completedYears = (elapsedTime.sub(daysForYearInProgress))
                .div(uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm));

            rewardEndTime = BokkyPooBahsDateTimeLibrary.addDays(
                uint256(stakeByID[_stakeID].startOfTerm),
                uint256(
                    (completedYears + 1) *
                        uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                )
            );

            if (rewardEndTime &lt; uint256(block.timestamp)) {
                // Calculated elapsed time again
                elapsedTime = BokkyPooBahsDateTimeLibrary.diffDays(
                    uint256(stakeByID[_stakeID].startOfTerm),
                    rewardEndTime
                );

                daysForYearInProgress = elapsedTime.mod(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
                completedYears = (elapsedTime.sub(daysForYearInProgress)).div(
                    uint256(stakeTypes[stakeByID[_stakeID].Type].bonusTerm)
                );
            }

            uint256 bMul = uint256(
                stakeTypes[stakeByID[_stakeID].Type].bonusMultiplier
            );

            uint256 postBonusBalance = calculatePostBonusBalance(
                uint256(stakeByID[_stakeID].evaiAmount),
                completedYears,
                bMul
            );

            uint256 pReturns = stakeTypes[stakeByID[_stakeID].Type]
                .percentageReturn;

            totalReturns = compound(
                postBonusBalance,
                pReturns,
                daysForYearInProgress
            );
            stakeReturns = totalReturns - (stakeByID[_stakeID].evaiAmount);
        }

        if (_full == true) {
            stakeByID[_stakeID].partialWithdrawn = false;
            stakeByID[_stakeID].settlementAmount = uint64(totalReturns);
            stakeByID[_stakeID].stakeReturns = uint64(stakeReturns);
        } else {
            require(
                _withdrawAmount &lt;= uint64(totalReturns),
                &quot;Amount to claim is higher than returns&quot;
            );
            stakeByID[_stakeID].settlementAmount = _withdrawAmount;
        }

        if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            //Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            totalProfitsDistrubuted += stakeByID[_stakeID].stakeReturns;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
        } else if (
            _full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            emitWithdrawStake(_stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &lt;=
            evaiToken.balanceOf(address(this))
        ) {
            // Update the global variables
            currentStakedEvaiAmount -= stakeByID[_stakeID].evaiAmount;
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            stakeByID[_stakeID].settled = true;
            evaiTransfer(_stakeID);
            emitWithdrawStake(_stakeID);
            // restake with the remaining amount
            uint8 Type = stakeByID[_stakeID].Type;
            uint256 reStakeAmount = totalReturns -
                (stakeByID[_stakeID].settlementAmount);
            reStake(uint64(reStakeAmount), Type, _stakeID);
        } else if (
            _full == false &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))
        ) {
            // set the stake attributes
            stakeByID[_stakeID].active = false;
            stakeByID[_stakeID].partialWithdrawn = true;
            emitWithdrawStake(_stakeID);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_full == true &amp;&amp;
            stakeByID[_stakeID].settlementAmount &gt;=
            evaiToken.balanceOf(address(this))</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x08c3a887865684f30351a0ba6d683aa9b539829a">0x08c3a887865684f30351a0ba6d683aa9b539829a</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9b4825997d2634c4c68c6283ea30cfcabe8bda0a">0x9b4825997d2634c4c68c6283ea30cfcabe8bda0a</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : MonegraphERC721Factory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x415eacc51dc77e97c6bebb3296d5ffb84cce5d8f">0x415eacc51dc77e97c6bebb3296d5ffb84cce5d8f</a></p>
<pre><code class="language-solidity">function createContract(
        string memory name,
        string memory symbol,
        bool managed
    ) public onlyRole(CREATOR_ROLE) returns (address) {
        address addr = _msgSender();
        address contractAddress;

        bytes memory data =
            abi.encodeWithSignature(
                &quot;initialize(string,string,address)&quot;,
                name,
                symbol,
                addr
            );

        if (managed == true) {
            BeaconProxy proxy = new BeaconProxy(address(this), data);
            contractAddress = address(proxy);
        } else {
            ERC1967Proxy proxy = new ERC1967Proxy(implementation(), data);
            contractAddress = address(proxy);
        }

        deployed[addr].push(contractAddress);

        emit BeaconCreated(addr, contractAddress, managed);

        return contractAddress;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>managed == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde4fc27ed2cf46d4c66ba16ccc757beca007b75b">0xde4fc27ed2cf46d4c66ba16ccc757beca007b75b</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // First the interest earned since the last call will be calculated
        // Some will sent to a strategy vault to be later processed when it becomes large enough
        calculateAndStoreInterest(); // This function will also call an update to lastATokenBalance

        // Then convert deposited stablecoins into their aToken equivalents and updates lastATokenBalance
        convertAllToAaveTokens();

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde4fc27ed2cf46d4c66ba16ccc757beca007b75b">0xde4fc27ed2cf46d4c66ba16ccc757beca007b75b</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // First the interest earned since the last call will be calculated and sent to vault
        calculateAndStoreInterest();

        // This is in case there are some leftover raw tokens
        convertAllToAaveTokens();

        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0)); // This will also not call calculateAndHold due to 0 address
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea44daf0bc6238cd50f1f19cbc7ee6a790360">0xcafea44daf0bc6238cd50f1f19cbc7ee6a790360</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1599470505ec590a2aa85ef8d7dfed7833a60831">0x1599470505ec590a2aa85ef8d7dfed7833a60831</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : InsolventComptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa8d6f19888d18add771b4649f8115a59b4425649">0xa8d6f19888d18add771b4649f8115a59b4425649</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa8d6f19888d18add771b4649f8115a59b4425649">0xa8d6f19888d18add771b4649f8115a59b4425649</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa8d6f19888d18add771b4649f8115a59b4425649">0xa8d6f19888d18add771b4649f8115a59b4425649</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : InsolventComptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa8d6f19888d18add771b4649f8115a59b4425649">0xa8d6f19888d18add771b4649f8115a59b4425649</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : DaoStructs</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa9e87d13ed09126b5a07555f737de9f6a478bf19">0xa9e87d13ed09126b5a07555f737de9f6a478bf19</a></p>
<pre><code class="language-solidity">function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)
        external
        view
        returns (address[] memory _voters, uint256 _length)
    {
        uint256 _n = _allUsers.length;
        uint256 i;
        _length = 0;
        _voters = new address[](_n);
        if (_vote == true) {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.yesVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        } else {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.noVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32e41714dcce1c4be08cc1e896bbca56f93e89c9">0x32e41714dcce1c4be08cc1e896bbca56f93e89c9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32e41714dcce1c4be08cc1e896bbca56f93e89c9">0x32e41714dcce1c4be08cc1e896bbca56f93e89c9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32e41714dcce1c4be08cc1e896bbca56f93e89c9">0x32e41714dcce1c4be08cc1e896bbca56f93e89c9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32e41714dcce1c4be08cc1e896bbca56f93e89c9">0x32e41714dcce1c4be08cc1e896bbca56f93e89c9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32e41714dcce1c4be08cc1e896bbca56f93e89c9">0x32e41714dcce1c4be08cc1e896bbca56f93e89c9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32e41714dcce1c4be08cc1e896bbca56f93e89c9">0x32e41714dcce1c4be08cc1e896bbca56f93e89c9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32e41714dcce1c4be08cc1e896bbca56f93e89c9">0x32e41714dcce1c4be08cc1e896bbca56f93e89c9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x32e41714dcce1c4be08cc1e896bbca56f93e89c9">0x32e41714dcce1c4be08cc1e896bbca56f93e89c9</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Nayuta</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3d73e881d3c57bd11d87c09ab0fef12e5469c790">0x3d73e881d3c57bd11d87c09ab0fef12e5469c790</a></p>
<pre><code class="language-solidity">constructor(bool _callerIsUserFlg, bool mintERC2309Flg) ERC721A(&quot;Nayuta&quot;, &quot;NAYUTA&quot;) {
        _registerForOperatorFiltering();
        _setDefaultRoyalty(FUND_ADDRESS, 750);
        callerIsUserFlg = _callerIsUserFlg;
        _grantRole(DEFAULT_ADMIN_ROLE, owner());
        _grantRole(MINTER_ROLE, owner());
        presaleCost[BuyerRole.Prime] = 0.01 ether;
        presaleCost[BuyerRole.Composite] = 0.03 ether;
        presaleCost[BuyerRole.AllowList] = 0.04 ether;

        if (mintERC2309Flg == true) {
            _mintERC2309(FUND_ADDRESS, 930);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mintERC2309Flg == true</code></p>
<hr />
<h3>Contract : Nayuta</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3d73e881d3c57bd11d87c09ab0fef12e5469c790">0x3d73e881d3c57bd11d87c09ab0fef12e5469c790</a></p>
<pre><code class="language-solidity">constructor(bool _callerIsUserFlg, bool mintERC2309Flg) ERC721A(&quot;Nayuta&quot;, &quot;NAYUTA&quot;) {
        _registerForOperatorFiltering();
        _setDefaultRoyalty(FUND_ADDRESS, 750);
        callerIsUserFlg = _callerIsUserFlg;
        _grantRole(DEFAULT_ADMIN_ROLE, owner());
        _grantRole(MINTER_ROLE, owner());
        presaleCost[BuyerRole.Prime] = 0.01 ether;
        presaleCost[BuyerRole.Composite] = 0.03 ether;
        presaleCost[BuyerRole.AllowList] = 0.04 ether;

        if (mintERC2309Flg == true) {
            _mintERC2309(FUND_ADDRESS, 930);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>mintERC2309Flg == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5433593c12b9953697420fbbbaac5f43199ebcf">0xc5433593c12b9953697420fbbbaac5f43199ebcf</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc5433593c12b9953697420fbbbaac5f43199ebcf">0xc5433593c12b9953697420fbbbaac5f43199ebcf</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArbV4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x86fedcc299d2e04264b168c37f18b7596320de2b">0x86fedcc299d2e04264b168c37f18b7596320de2b</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyBTCArbV4</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x86fedcc299d2e04264b168c37f18b7596320de2b">0x86fedcc299d2e04264b168c37f18b7596320de2b</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if( _share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : ICO</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4ca0cc70198cc83e04713a4d37d165f5e91e9aef">0x4ca0cc70198cc83e04713a4d37d165f5e91e9aef</a></p>
<pre><code class="language-solidity">function extension(bool pollResult) public {

        //Only creator
        require(msg.sender == creator,&quot;You are not the creator&quot;);
        //Only on poll stage
        require(state == State.finishing, &quot;Wrong Stage&quot;);

        //poll results
        if (pollResult == true) { //Approved
            //extended stage
            state = State.extended;
            //extension is 30Days
            ICOdeadline = now.add(30 days);
        } else { //Denied
            //ico becomes Successful
            state = State.successful;
            //ICO is complete, stamp it
            completedAt = now;

            emit LogFundingSuccessful(totalRaised); //we log the finish
            finished(); //and execute closure

        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>pollResult == true</code></p>
<hr />
<h3>Contract : ANWToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0">0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0</a></p>
<pre><code class="language-solidity">function voting(bool vote, uint256 amount) public returns (bool) {

        if (_proposalList.length == 0) { // minting Proposal array is empty
            revert(&quot;voting: proposal not active&quot;);
        } else {
            require(_proposalList[_proposalId]._isActive, &quot;voting: proposal not active&quot; );
        }

        if(_votes[_msgSender()][_proposalId]._amount == 0) { // if voter hasn't voted, or reduced vote to zero previously
            require(amount &gt; 0, &quot;voting: vote amount is zero&quot; );
        }
        require(_proposalList[_proposalId]._votingEnds &gt; block.timestamp, &quot;voting: voting period has closed&quot;);
        require(balanceOf(_msgSender()) &gt;= amount, &quot;voting: vote amount cannot exceed token balance&quot;);

        // adjust the proposal voting balances
        if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == true) { // voter switched thier vote from disagree to agree
            // subtract from disagree and add to agree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.add(amount);
        } else if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == false){ // voter switched their vote form agree to disagree
            // subtract from agree and add to disagree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.add(amount);
        } else if ( vote == true) { // voter reinforced their agree vote
            // add to agree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        } else { // voter reinforced their disagree vote
            // add to disagree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        }
        // update 
        _votes[_msgSender()][_proposalId]._vote = vote;

        uint256 oldAmount = _votes[_msgSender()][_proposalId]._amount;

        // assign the new vote amount to this Vote
        _votes[_msgSender()][_proposalId]._amount = amount;


        if(oldAmount &gt; amount) { // refund excess token if vote amount reduced
            _transfer(address(this), _msgSender(), oldAmount.sub(amount));    
        } else { // lock new tokens if vote amount increased
            _transfer(_msgSender(), address(this), amount.sub(oldAmount));  
        }

        emit Voted(_msgSender(), _proposalId, vote,  amount);

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == true</code></p>
<hr />
<h3>Contract : ANWToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0">0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0</a></p>
<pre><code class="language-solidity">function voting(bool vote, uint256 amount) public returns (bool) {

        if (_proposalList.length == 0) { // minting Proposal array is empty
            revert(&quot;voting: proposal not active&quot;);
        } else {
            require(_proposalList[_proposalId]._isActive, &quot;voting: proposal not active&quot; );
        }

        if(_votes[_msgSender()][_proposalId]._amount == 0) { // if voter hasn't voted, or reduced vote to zero previously
            require(amount &gt; 0, &quot;voting: vote amount is zero&quot; );
        }
        require(_proposalList[_proposalId]._votingEnds &gt; block.timestamp, &quot;voting: voting period has closed&quot;);
        require(balanceOf(_msgSender()) &gt;= amount, &quot;voting: vote amount cannot exceed token balance&quot;);

        // adjust the proposal voting balances
        if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == true) { // voter switched thier vote from disagree to agree
            // subtract from disagree and add to agree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.add(amount);
        } else if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == false){ // voter switched their vote form agree to disagree
            // subtract from agree and add to disagree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.add(amount);
        } else if ( vote == true) { // voter reinforced their agree vote
            // add to agree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        } else { // voter reinforced their disagree vote
            // add to disagree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        }
        // update 
        _votes[_msgSender()][_proposalId]._vote = vote;

        uint256 oldAmount = _votes[_msgSender()][_proposalId]._amount;

        // assign the new vote amount to this Vote
        _votes[_msgSender()][_proposalId]._amount = amount;


        if(oldAmount &gt; amount) { // refund excess token if vote amount reduced
            _transfer(address(this), _msgSender(), oldAmount.sub(amount));    
        } else { // lock new tokens if vote amount increased
            _transfer(_msgSender(), address(this), amount.sub(oldAmount));  
        }

        emit Voted(_msgSender(), _proposalId, vote,  amount);

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>vote == true</code></p>
<hr />
<h3>Contract : ERC20Pausable</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0">0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0</a></p>
<pre><code class="language-solidity">function voting(bool vote, uint256 amount) public returns (bool) {

        if (_proposalList.length == 0) { // minting Proposal array is empty
            revert(&quot;voting: proposal not active&quot;);
        } else {
            require(_proposalList[_proposalId]._isActive, &quot;voting: proposal not active&quot; );
        }

        if(_votes[_msgSender()][_proposalId]._amount == 0) { // if voter hasn't voted, or reduced vote to zero previously
            require(amount &gt; 0, &quot;voting: vote amount is zero&quot; );
        }
        require(_proposalList[_proposalId]._votingEnds &gt; block.timestamp, &quot;voting: voting period has closed&quot;);
        require(balanceOf(_msgSender()) &gt;= amount, &quot;voting: vote amount cannot exceed token balance&quot;);

        // adjust the proposal voting balances
        if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == true) { // voter switched thier vote from disagree to agree
            // subtract from disagree and add to agree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.add(amount);
        } else if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == false){ // voter switched their vote form agree to disagree
            // subtract from agree and add to disagree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.add(amount);
        } else if ( vote == true) { // voter reinforced their agree vote
            // add to agree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        } else { // voter reinforced their disagree vote
            // add to disagree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        }
        // update 
        _votes[_msgSender()][_proposalId]._vote = vote;

        uint256 oldAmount = _votes[_msgSender()][_proposalId]._amount;

        // assign the new vote amount to this Vote
        _votes[_msgSender()][_proposalId]._amount = amount;


        if(oldAmount &gt; amount) { // refund excess token if vote amount reduced
            _transfer(address(this), _msgSender(), oldAmount.sub(amount));    
        } else { // lock new tokens if vote amount increased
            _transfer(_msgSender(), address(this), amount.sub(oldAmount));  
        }

        emit Voted(_msgSender(), _proposalId, vote,  amount);

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == true</code></p>
<hr />
<h3>Contract : ERC20Pausable</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0">0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0</a></p>
<pre><code class="language-solidity">function voting(bool vote, uint256 amount) public returns (bool) {

        if (_proposalList.length == 0) { // minting Proposal array is empty
            revert(&quot;voting: proposal not active&quot;);
        } else {
            require(_proposalList[_proposalId]._isActive, &quot;voting: proposal not active&quot; );
        }

        if(_votes[_msgSender()][_proposalId]._amount == 0) { // if voter hasn't voted, or reduced vote to zero previously
            require(amount &gt; 0, &quot;voting: vote amount is zero&quot; );
        }
        require(_proposalList[_proposalId]._votingEnds &gt; block.timestamp, &quot;voting: voting period has closed&quot;);
        require(balanceOf(_msgSender()) &gt;= amount, &quot;voting: vote amount cannot exceed token balance&quot;);

        // adjust the proposal voting balances
        if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == true) { // voter switched thier vote from disagree to agree
            // subtract from disagree and add to agree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.add(amount);
        } else if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == false){ // voter switched their vote form agree to disagree
            // subtract from agree and add to disagree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.add(amount);
        } else if ( vote == true) { // voter reinforced their agree vote
            // add to agree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        } else { // voter reinforced their disagree vote
            // add to disagree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        }
        // update 
        _votes[_msgSender()][_proposalId]._vote = vote;

        uint256 oldAmount = _votes[_msgSender()][_proposalId]._amount;

        // assign the new vote amount to this Vote
        _votes[_msgSender()][_proposalId]._amount = amount;


        if(oldAmount &gt; amount) { // refund excess token if vote amount reduced
            _transfer(address(this), _msgSender(), oldAmount.sub(amount));    
        } else { // lock new tokens if vote amount increased
            _transfer(_msgSender(), address(this), amount.sub(oldAmount));  
        }

        emit Voted(_msgSender(), _proposalId, vote,  amount);

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>vote == true</code></p>
<hr />
<h3>Contract : ERC20VotingMintable</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0">0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0</a></p>
<pre><code class="language-solidity">function voting(bool vote, uint256 amount) public returns (bool) {

        if (_proposalList.length == 0) { // minting Proposal array is empty
            revert(&quot;voting: proposal not active&quot;);
        } else {
            require(_proposalList[_proposalId]._isActive, &quot;voting: proposal not active&quot; );
        }

        if(_votes[_msgSender()][_proposalId]._amount == 0) { // if voter hasn't voted, or reduced vote to zero previously
            require(amount &gt; 0, &quot;voting: vote amount is zero&quot; );
        }
        require(_proposalList[_proposalId]._votingEnds &gt; block.timestamp, &quot;voting: voting period has closed&quot;);
        require(balanceOf(_msgSender()) &gt;= amount, &quot;voting: vote amount cannot exceed token balance&quot;);

        // adjust the proposal voting balances
        if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == true) { // voter switched thier vote from disagree to agree
            // subtract from disagree and add to agree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.add(amount);
        } else if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == false){ // voter switched their vote form agree to disagree
            // subtract from agree and add to disagree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.add(amount);
        } else if ( vote == true) { // voter reinforced their agree vote
            // add to agree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        } else { // voter reinforced their disagree vote
            // add to disagree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        }
        // update 
        _votes[_msgSender()][_proposalId]._vote = vote;

        uint256 oldAmount = _votes[_msgSender()][_proposalId]._amount;

        // assign the new vote amount to this Vote
        _votes[_msgSender()][_proposalId]._amount = amount;


        if(oldAmount &gt; amount) { // refund excess token if vote amount reduced
            _transfer(address(this), _msgSender(), oldAmount.sub(amount));    
        } else { // lock new tokens if vote amount increased
            _transfer(_msgSender(), address(this), amount.sub(oldAmount));  
        }

        emit Voted(_msgSender(), _proposalId, vote,  amount);

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == true</code></p>
<hr />
<h3>Contract : ERC20VotingMintable</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0">0x7dbdd9dafdc4c1c03d67925a4f85daa398af32b0</a></p>
<pre><code class="language-solidity">function voting(bool vote, uint256 amount) public returns (bool) {

        if (_proposalList.length == 0) { // minting Proposal array is empty
            revert(&quot;voting: proposal not active&quot;);
        } else {
            require(_proposalList[_proposalId]._isActive, &quot;voting: proposal not active&quot; );
        }

        if(_votes[_msgSender()][_proposalId]._amount == 0) { // if voter hasn't voted, or reduced vote to zero previously
            require(amount &gt; 0, &quot;voting: vote amount is zero&quot; );
        }
        require(_proposalList[_proposalId]._votingEnds &gt; block.timestamp, &quot;voting: voting period has closed&quot;);
        require(balanceOf(_msgSender()) &gt;= amount, &quot;voting: vote amount cannot exceed token balance&quot;);

        // adjust the proposal voting balances
        if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == true) { // voter switched thier vote from disagree to agree
            // subtract from disagree and add to agree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.add(amount);
        } else if (_votes[_msgSender()][_proposalId]._vote != vote &amp;&amp; vote == false){ // voter switched their vote form agree to disagree
            // subtract from agree and add to disagree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount);
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.add(amount);
        } else if ( vote == true) { // voter reinforced their agree vote
            // add to agree
            _proposalList[_proposalId]._agree = _proposalList[_proposalId]._agree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        } else { // voter reinforced their disagree vote
            // add to disagree
            _proposalList[_proposalId]._disagree = _proposalList[_proposalId]._disagree.sub(_votes[_msgSender()][_proposalId]._amount).add(amount);
        }
        // update 
        _votes[_msgSender()][_proposalId]._vote = vote;

        uint256 oldAmount = _votes[_msgSender()][_proposalId]._amount;

        // assign the new vote amount to this Vote
        _votes[_msgSender()][_proposalId]._amount = amount;


        if(oldAmount &gt; amount) { // refund excess token if vote amount reduced
            _transfer(address(this), _msgSender(), oldAmount.sub(amount));    
        } else { // lock new tokens if vote amount increased
            _transfer(_msgSender(), address(this), amount.sub(oldAmount));  
        }

        emit Voted(_msgSender(), _proposalId, vote,  amount);

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>vote == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa918d18a72c606be88023bcc4ee93681a1d006f3">0xa918d18a72c606be88023bcc4ee93681a1d006f3</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;DarkExchange: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : DarkExchangePair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa918d18a72c606be88023bcc4ee93681a1d006f3">0xa918d18a72c606be88023bcc4ee93681a1d006f3</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;DarkExchange: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : Oasis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2b8fcd21412e6e1b4b6f12b7ea4c9902b738162b">0x2b8fcd21412e6e1b4b6f12b7ea4c9902b738162b</a></p>
<pre><code class="language-solidity">function ended(bool ifget) public returns(bool) {
        require(actived == true);
        address user = msg.sender;
        require(my[user].systemtag &lt; tags);
        require(!frozenAccount[user]);
        if(ifget == true) {
            my[user].prizecount = 0;
            my[user].tzs = 0;
            my[user].prizecount = 0;
            mycan[user].eths = 0;
            mycan[user].used = 0;
            if(mycan[user].len &gt; 0) {
                delete mycan[user].times;
                delete mycan[user].amounts;
                delete mycan[user].moneys;
            }
            mycan[user].len = 0;

            myrun[user].eths = 0;
            myrun[user].used = 0;
            if(myrun[user].len &gt; 0) {
                delete myrun[user].times;
                delete myrun[user].amounts;
                delete myrun[user].moneys;
            }
            myrun[user].len = 0;
            if(my[user].usereths/2 &gt; my[user].userethsused) {
                uint money = my[user].usereths/2 - my[user].userethsused;
                require(address(this).balance &gt; money);
                user.transfer(money);
            }
            my[user].usereths = 0;
            my[user].userethsused = 0;

        }else{
            uint amount = my[user].usereths - my[user].userethsused;
            tg[tags].ethnum += my[user].tzs;
            tg[tags].sysethnum += amount;
            tg[tags].userethnum += amount;
        }
        my[user].systemtag = tags;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifget == true</code></p>
<hr />
<h3>Contract : SakeSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x75e48c954594d64ef9613aeef97ad85370f13807">0x75e48c954594d64ef9613aeef97ad85370f13807</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;SakeSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;SakeSwap: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : SakeSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x75e48c954594d64ef9613aeef97ad85370f13807">0x75e48c954594d64ef9613aeef97ad85370f13807</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;SakeSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : TestNet1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf259fb4684841ee046b5e7f0749daa7d2b319f6f">0xf259fb4684841ee046b5e7f0749daa7d2b319f6f</a></p>
<pre><code class="language-solidity">function tradeTokensBatch(address token,
        uint256 amount,
        uint24 poolFee,
        bool convertToWeth
    ) public payable checkAddress() returns (uint256 totalSwapped) {
        address firstToken;
        address secondToken;

        if(convertToWeth == true) {
            firstToken = token;
            secondToken = WETH;
        } else {
            firstToken = WETH;
            secondToken = token;
        }

        for (uint256 i = 0; i &lt; wallets.length; i++) {
            uint256 tokenAmount = swapExactInputSingle(firstToken, secondToken, wallets[i], amount, poolFee);
            totalSwapped += tokenAmount;
        }

        return (totalSwapped);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>convertToWeth == true</code></p>
<hr />
<h3>Contract : MultiNftMarket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x50c4e33ca332469004427c48c7b8466ec4541800">0x50c4e33ca332469004427c48c7b8466ec4541800</a></p>
<pre><code class="language-solidity">function updateSale(address _tokenAddress,uint256 _tokenId,bool _isForSale,uint256 _amount,uint256 _price) onlyAcceptedToken(_tokenAddress) public returns (bool) {
        require(_exists(_tokenId));//발행된 토큰인지

        SaleInfo storage sale = saleMap[_tokenId][_msgSender()];


        if(_isForSale == true){
            require(balanceOf(_msgSender(), _tokenId) &gt;= _amount);//판매할 수량이 소유중인 개수 초과할수 없음

            sale.isForSale      = true;
            sale.amount         = _amount;
            sale.price          = _price;
            sale.tokenAddress   = _tokenAddress;
        }else{
            sale.isForSale  = false;
        }

        saleMap[_tokenId][_msgSender()] = sale;
        emit UpdateSale(_msgSender(), _isForSale, _tokenId, _amount, _price);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isForSale == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe8b3722059f8f3672f14f1a9561388cb4ccf04a2">0xe8b3722059f8f3672f14f1a9561388cb4ccf04a2</a></p>
<pre><code class="language-solidity">function authoriseModule(
        address _module,
        bool _value
    )
        external
        moduleOnly
    {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6c021e8df1e1f0ddd6050277b8495dc92124208a">0x6c021e8df1e1f0ddd6050277b8495dc92124208a</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6c021e8df1e1f0ddd6050277b8495dc92124208a">0x6c021e8df1e1f0ddd6050277b8495dc92124208a</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6c021e8df1e1f0ddd6050277b8495dc92124208a">0x6c021e8df1e1f0ddd6050277b8495dc92124208a</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner())</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6c217a78272e810affcc8f3494efb638b17f476d">0x6c217a78272e810affcc8f3494efb638b17f476d</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external override moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                IModule(_module).init(address(this));
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: cannot remove last module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : TeamDream</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x09e8b6af57a0c7f1e1d3ce397dc417082611291a">0x09e8b6af57a0c7f1e1d3ce397dc417082611291a</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x415f306a0628d35183f42d0607cd03fcb71d1e1f">0x415f306a0628d35183f42d0607cd03fcb71d1e1f</a></p>
<pre><code class="language-solidity">function purchaseKingdom(string _key, string _title, bool _locked) public 
    payable 
    nonReentrant()
    checkKingdomExistence(_key)
    checkIsNotLocked(_key)
    {
        require(now &lt; rounds[currentRound].endTime);
        Round storage round = rounds[currentRound];
        uint kingdomId = round.kingdomsKeys[_key];
        Kingdom storage kingdom = kingdoms[kingdomId];
        require((kingdom.kingdomTier + 1) &lt; 6);
        uint requiredPrice = kingdom.minimumPrice;
        if (_locked == true) {
            requiredPrice = requiredPrice.add(ACTION_TAX);
        }

        require (msg.value &gt;= requiredPrice);
        uint jackpotCommission = (msg.value).sub(kingdom.returnPrice);

        if (kingdom.returnPrice &gt; 0) {
            round.nbKingdoms[kingdom.owner]--;
            if (kingdom.kingdomType == 1) {
                round.nbKingdomsType1[kingdom.owner]--;
            } else if (kingdom.kingdomType == 2) {
                round.nbKingdomsType2[kingdom.owner]--;
            } else if (kingdom.kingdomType == 3) {
                round.nbKingdomsType3[kingdom.owner]--;
            } else if (kingdom.kingdomType == 4) {
                round.nbKingdomsType4[kingdom.owner]--;
            } else if (kingdom.kingdomType == 5) {
                round.nbKingdomsType5[kingdom.owner]--;
            }
            compensateLatestMonarch(kingdom.lastTransaction, kingdom.returnPrice);
        }


        // woodInterface.resetTimer(_key);

        kingdom.kingdomTier++;
        kingdom.title = _title;

        if (kingdom.kingdomTier == 5) {
            kingdom.returnPrice = 0;
            kingdom.minimumPrice = 5 ether;
        } else if (kingdom.kingdomTier == 2) {
            kingdom.returnPrice = 0.1125 ether;
            kingdom.minimumPrice = 0.27 ether;
        } else if (kingdom.kingdomTier == 3) {
            kingdom.returnPrice = 0.3375 ether;
            kingdom.minimumPrice = 0.81 ether;
        } else if (kingdom.kingdomTier == 4) {
            kingdom.returnPrice = 1.0125 ether;
            kingdom.minimumPrice = 2.43 ether;
        }

        kingdom.owner = msg.sender;
        kingdom.locked = _locked;

        uint transactionId = kingdomTransactions.push(Transaction(&quot;&quot;, msg.sender, msg.value, 0, jackpotCommission, now)) - 1;
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdom.transactionCount++;
        kingdom.lastTransaction = transactionId;
        lastTransaction[msg.sender] = now;

        setNewJackpot(kingdom.kingdomType, jackpotCommission, msg.sender);
        LandPurchasedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x415f306a0628d35183f42d0607cd03fcb71d1e1f">0x415f306a0628d35183f42d0607cd03fcb71d1e1f</a></p>
<pre><code class="language-solidity">function setLock(string _key, bool _locked) public payable checkKingdomExistence(_key) onlyKingdomOwner(_key, msg.sender) {
        if (_locked == true) { require(msg.value &gt;= ACTION_TAX); }
        kingdoms[rounds[currentRound].kingdomsKeys[_key]].locked = _locked;
        if (msg.value &gt; 0) { asyncSend(bookerAddress, msg.value); }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x415f306a0628d35183f42d0607cd03fcb71d1e1f">0x415f306a0628d35183f42d0607cd03fcb71d1e1f</a></p>
<pre><code class="language-solidity">function createKingdom(string _key, string _title, uint _type, bool _locked) checkKingdomCap(msg.sender, _type) onlyForRemainingKingdoms() public payable {
        require(now &lt; rounds[currentRound].endTime);
        require(_type &gt; 0);
        require(_type &lt; 6);
        uint basePrice = STARTING_CLAIM_PRICE_WEI;
        uint requiredPrice = basePrice;
        if (_locked == true) { requiredPrice = requiredPrice.add(ACTION_TAX); }
        require(msg.value &gt;= requiredPrice);
        Round storage round = rounds[currentRound];
        require(round.kingdomsCreated[_key] == false);

        uint refundPrice = 0.0375 ether; // (STARTING_CLAIM_PRICE_WEI.mul(125)).div(100);
        uint nextMinimumPrice = 0.09 ether; // STARTING_CLAIM_PRICE_WEI.add(STARTING_CLAIM_PRICE_WEI.mul(2));

        uint kingdomId = kingdoms.push(Kingdom(&quot;&quot;, &quot;&quot;, 1, 0, 0, 0, 1, refundPrice, address(0), false)) - 1;

        kingdoms[kingdomId].kingdomType = _type;
        kingdoms[kingdomId].title = _title;
        kingdoms[kingdomId].owner = msg.sender;
        kingdoms[kingdomId].key = _key;
        kingdoms[kingdomId].minimumPrice = nextMinimumPrice;
        kingdoms[kingdomId].locked = _locked;

        round.kingdomsKeys[_key] = kingdomId;
        round.kingdomsCreated[_key] = true;

        if(_locked == true) {
            asyncSend(bookerAddress, ACTION_TAX);
        }

        uint transactionId = kingdomTransactions.push(Transaction(&quot;&quot;, msg.sender, msg.value, 0, basePrice, now)) - 1;
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdoms[kingdomId].lastTransaction = transactionId;
        lastTransaction[msg.sender] = now;

        setNewJackpot(_type, basePrice, msg.sender);
        LandCreatedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x415f306a0628d35183f42d0607cd03fcb71d1e1f">0x415f306a0628d35183f42d0607cd03fcb71d1e1f</a></p>
<pre><code class="language-solidity">function createKingdom(string _key, string _title, uint _type, bool _locked) checkKingdomCap(msg.sender, _type) onlyForRemainingKingdoms() public payable {
        require(now &lt; rounds[currentRound].endTime);
        require(_type &gt; 0);
        require(_type &lt; 6);
        uint basePrice = STARTING_CLAIM_PRICE_WEI;
        uint requiredPrice = basePrice;
        if (_locked == true) { requiredPrice = requiredPrice.add(ACTION_TAX); }
        require(msg.value &gt;= requiredPrice);
        Round storage round = rounds[currentRound];
        require(round.kingdomsCreated[_key] == false);

        uint refundPrice = 0.0375 ether; // (STARTING_CLAIM_PRICE_WEI.mul(125)).div(100);
        uint nextMinimumPrice = 0.09 ether; // STARTING_CLAIM_PRICE_WEI.add(STARTING_CLAIM_PRICE_WEI.mul(2));

        uint kingdomId = kingdoms.push(Kingdom(&quot;&quot;, &quot;&quot;, 1, 0, 0, 0, 1, refundPrice, address(0), false)) - 1;

        kingdoms[kingdomId].kingdomType = _type;
        kingdoms[kingdomId].title = _title;
        kingdoms[kingdomId].owner = msg.sender;
        kingdoms[kingdomId].key = _key;
        kingdoms[kingdomId].minimumPrice = nextMinimumPrice;
        kingdoms[kingdomId].locked = _locked;

        round.kingdomsKeys[_key] = kingdomId;
        round.kingdomsCreated[_key] = true;

        if(_locked == true) {
            asyncSend(bookerAddress, ACTION_TAX);
        }

        uint transactionId = kingdomTransactions.push(Transaction(&quot;&quot;, msg.sender, msg.value, 0, basePrice, now)) - 1;
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdoms[kingdomId].lastTransaction = transactionId;
        lastTransaction[msg.sender] = now;

        setNewJackpot(_type, basePrice, msg.sender);
        LandCreatedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa2073fab02cd808dd35b144360b0d2b1fa2325b5">0xa2073fab02cd808dd35b144360b0d2b1fa2325b5</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
        public
        onlyAction
        returns (bool success)
    {
        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;
            success = executions[_id].to.call(executions[_id].data, 0);
            if (success) {
                executions[_id].executed = true;
                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );
            }
            return success;
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : BZXAAVEFLASHLIQUIDATE</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xca833649d3806dfd944540d32f8b4b2def8e9816">0xca833649d3806dfd944540d32f8b4b2def8e9816</a></p>
<pre><code class="language-solidity">function performTrade(bool isItEther, uint256 amount1) public returns(uint256) {


        uint256 startingETHBalance = address(this).balance;
        ERC20 tokenToReceive = ERC20(currentCToken);
        uint256 startingCBalance = tokenToReceive.balanceOf(address(this));

        if (isItEther == true) {

        } else {
            ERC20 bzLToken = ERC20(currentLToken);

            if (bzLToken.allowance(address(this), bzx1Address) &lt;= currentMaxLiq) {
                bzLToken.approve(bzx1Address, (currentMaxLiq * 100));
            }
        }

        if (isItEther == false) {
            bzx1.liquidate(currentLoanId, address(this), currentMaxLiq);
        } else {
            bzx1.liquidate.value(amount1)(currentLoanId, address(this), currentMaxLiq);
        }



        uint256 amountBack = 0;
        if (address(this).balance &gt; startingETHBalance) {
            uint256 newETH = address(this).balance - startingETHBalance;
            wethToken.deposit.value(newETH)();


            amountBack = performUniswap(wethAddress, currentLToken, newETH);
        }
        else {



            uint256 difCBalance = tokenToReceive.balanceOf(address(this)) - startingCBalance;
           require(difCBalance &gt;0, &quot;Balance of Collateral token didnt go up after swap didnt go up&quot;);


           amountBack = performUniswap(currentCToken, currentLToken, difCBalance);
        }

        return amountBack;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isItEther == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe80f4d88288bd71df7bd36dd1b53e5df4b7d413c">0xe80f4d88288bd71df7bd36dd1b53e5df4b7d413c</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea6a8e3e7b7c1fffbcab062c55c492fc9d933">0xcafea6a8e3e7b7c1fffbcab062c55c492fc9d933</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : EnergyChainValidator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe763b5257aea69c94c01faf7f72cf154a6ffd960">0xe763b5257aea69c94c01faf7f72cf154a6ffd960</a></p>
<pre><code class="language-solidity">function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool) {
        if (vesting &lt; MIN_VESTING || vesting &gt; MAX_VESTING) {
            return false;
        }
        if (maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators) {
            return false;
        }
        return existAcc(whitelistedValidators, acc);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x74c47ed1b9ee5122a8a7870a297f2c05a56734b7">0x74c47ed1b9ee5122a8a7870a297f2c05a56734b7</a></p>
<pre><code class="language-solidity">function trade(bool _isUSDB) public returns(bool) {
        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));
        uint256 returnUSD = network.rateByPath(generatePath(_isUSDB, true), tradeValue);
        uint256 returnDAI = network.rateByPath(generatePath(_isUSDB, false), tradeValue);
        IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD;

        if(returnDAI &gt; tradeValue) {
            require((returnDAI - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient USD balance.');
            network.convertFor(generatePath(_isUSDB, true), tradeValue, tradeValue, address(this));
        } else {
            require(returnUSD &gt; tradeValue, 'Trade not yet available.');
            require((returnUSD - tradeValue) &gt;= threshold, 'Trade not yet available.');
            require(tokenDAI.balanceOf(address(this)) &gt;= tradeValue, 'Insufficient DAI balance.');
            network.convertFor(generatePath(_isUSDB, false), tradeValue, tradeValue, address(this));
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : AssetLib2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe248d52ed1a0c68eabe6d607d535b5e30ef842c7">0xe248d52ed1a0c68eabe6d607d535b5e30ef842c7</a></p>
<pre><code class="language-solidity">function xyDistributionAfterRedeem(
        mapping(address =&gt; uint256) storage totalTokenAmount,
        bool isAllowedAutoXYRebalace,
        mapping(address =&gt; uint256) storage xVaultAmount,
        mapping(address =&gt; uint256) storage yVaultAmount,
        address[] memory tokensInAsset,
        uint256[] memory sellAmounts
    ) public {
        for (uint256 i = 0; i &lt; tokensInAsset.length; ++i) {
            uint256 totalAmount = totalTokenAmount[tokensInAsset[i]];
            uint256 xStopAmount = (totalAmount * 500) / 1e4;
            uint256 xAmountMax = (totalAmount * 2000) / 1e4;

            uint256 xAmount = xVaultAmount[tokensInAsset[i]];
            if (isAllowedAutoXYRebalace == true) {
                uint256 yAmount = yVaultAmount[tokensInAsset[i]];
                require(
                    xAmount + yAmount &gt;= sellAmounts[i] &amp;&amp;
                        xAmount + yAmount - sellAmounts[i] &gt;= xStopAmount,
                    &quot;Not enough XY&quot;
                );
                if (xAmount &gt;= sellAmounts[i] &amp;&amp; xAmount - sellAmounts[i] &gt;= xStopAmount) {
                    xAmount -= sellAmounts[i];
                } else {
                    xAmount += yAmount;
                    xAmount -= sellAmounts[i];
                    if (xAmount &gt; xAmountMax) {
                        uint256 delta = xAmount - xAmountMax;
                        yAmount = delta;
                        xAmount = xAmountMax;

                        yVaultAmount[tokensInAsset[i]] = yAmount;
                    }
                }
            } else {
                require(
                    xAmount &gt;= sellAmounts[i] &amp;&amp; xAmount - sellAmounts[i] &gt;= xStopAmount,
                    &quot;Not enough X&quot;
                );
                xAmount -= sellAmounts[i];
            }
            xVaultAmount[tokensInAsset[i]] = xAmount;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isAllowedAutoXYRebalace == true</code></p>
<hr />
<h3>Contract : Oasis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4abe61182f8e49bf55ca1c4b2d21d4a1812dbbef">0x4abe61182f8e49bf55ca1c4b2d21d4a1812dbbef</a></p>
<pre><code class="language-solidity">function ended(bool ifget) public returns(bool) {
        require(actived == true);
        address user = msg.sender;
        require(my[user].systemtag &lt; tags);
        require(!frozenAccount[user]);
        if(ifget == true) {
            my[user].prizecount = 0;
            my[user].tzs = 0;
            my[user].prizecount = 0;
            mycan[user].eths = 0;
            mycan[user].used = 0;
            if(mycan[user].len &gt; 0) {
                delete mycan[user].times;
                delete mycan[user].amounts;
                delete mycan[user].moneys;
            }
            mycan[user].len = 0;

            myrun[user].eths = 0;
            myrun[user].used = 0;
            if(myrun[user].len &gt; 0) {
                delete myrun[user].times;
                delete myrun[user].amounts;
                delete myrun[user].moneys;
            }
            myrun[user].len = 0;
            if(my[user].usereths/2 &gt; my[user].userethsused) {
                uint money = my[user].usereths/2 - my[user].userethsused;
                require(address(this).balance &gt; money);
                user.transfer(money);
            }
            my[user].usereths = 0;
            my[user].userethsused = 0;

        }else{
            uint amount = my[user].usereths - my[user].userethsused;
            tg[tags].ethnum += my[user].tzs;
            tg[tags].sysethnum += amount;
            tg[tags].userethnum += amount;
        }
        my[user].systemtag = tags;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifget == true</code></p>
<hr />
<h3>Contract : Cryptopumps</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4d67dcc8ab25f604b2dee43f0a12d04f923dd1e3">0x4d67dcc8ab25f604b2dee43f0a12d04f923dd1e3</a></p>
<pre><code class="language-solidity">function fromBoolToString(bool _data) public pure returns (string memory) {
        if (_data == true) {
            return &quot;true&quot;;
        } else {
            return &quot;false&quot;;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_data == true</code></p>
<hr />
<h3>Contract : BlazingWomen</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x54f7c276d8d1530f590b02e1c83873b10d069b70">0x54f7c276d8d1530f590b02e1c83873b10d069b70</a></p>
<pre><code class="language-solidity">function togglePaused(bool pauseIt) external onlyDelegates {
        if (pauseIt == true) {
            _pause();
        } else {
            _unpause();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>pauseIt == true</code></p>
<hr />
<h3>Contract : ERC721B2FAEnumLitePausable</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x54f7c276d8d1530f590b02e1c83873b10d069b70">0x54f7c276d8d1530f590b02e1c83873b10d069b70</a></p>
<pre><code class="language-solidity">function togglePaused(bool pauseIt) external onlyDelegates {
        if (pauseIt == true) {
            _pause();
        } else {
            _unpause();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>pauseIt == true</code></p>
<hr />
<h3>Contract : ERC721BLockRegistry</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x54f7c276d8d1530f590b02e1c83873b10d069b70">0x54f7c276d8d1530f590b02e1c83873b10d069b70</a></p>
<pre><code class="language-solidity">function togglePaused(bool pauseIt) external onlyDelegates {
        if (pauseIt == true) {
            _pause();
        } else {
            _unpause();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>pauseIt == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6babebb9657257f83492d457e7f41b2524368de6">0x6babebb9657257f83492d457e7f41b2524368de6</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : RAOToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x45edb535942a8c84d9f4b5d37e1b25f91ea4804c">0x45edb535942a8c84d9f4b5d37e1b25f91ea4804c</a></p>
<pre><code class="language-solidity">function setWhitelistStatus(address user,bool status) public returns (bool) {
        if (status == true) {
            //only owner can set whitelist
            require(msg.sender == owner);
            whitelist[user] = true;        
        } else {
            // owner and the user themselves can remove them selves from whitelist
            require(msg.sender == owner || msg.sender == user);
            whitelist[user] = false;
        }
        return whitelist[user];
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>status == true</code></p>
<hr />
<h3>Contract : Exchange</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd341da9e6ed5c65b7cad193099b6e86f5a2b9929">0xd341da9e6ed5c65b7cad193099b6e86f5a2b9929</a></p>
<pre><code class="language-solidity">function closeFuturesPosition (bytes32 futuresContract, bool side)
    {
        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);

        if (futuresContracts[futuresContract].closed == false &amp;&amp; futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled
        if (retrievePosition(positionHash)[1] == 0) throw; // position not found
        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed

        uint256 profit;
        uint256 loss;

        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;

        FuturesClosePositionValues memory v = FuturesClosePositionValues({
            reserve         : EtherMium(exchangeContract).getReserve(baseToken, msg.sender),
            balance         : EtherMium(exchangeContract).balanceOf(baseToken, msg.sender),
            floorPrice      : futuresContracts[futuresContract].floorPrice,
            capPrice        : futuresContracts[futuresContract].capPrice,
            closingPrice    : futuresContracts[futuresContract].closingPrice,
            futuresContract : futuresContract
        });

        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);
        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);
        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;
        // uint256 capPrice = futuresContracts[futuresContract].capPrice;
        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;



        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);
        uint256 fee = calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract);



        // close long position
        if (side == true)
        {            

            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);
            // return;
            // reserve = reserve - (entryPrice - floorPrice) * size;
            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));


            subReserve(
                baseToken, 
                msg.sender, 
                v.reserve, 
                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice
                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &gt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);



                // LogUint(15, profit);
                // LogUint(16, fee);
                // LogUint(17, safeSub(profit * 1e10, fee));
                // return;
                if (profit &gt; fee)
                {
                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }
                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  


                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }   
        // close short position 
        else
        {
            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);
            // return;

            // reserve = reserve - (capPrice - entryPrice) * size;
            subReserve(
                baseToken, 
                msg.sender,  
                v.reserve, 
                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice
                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &lt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                // profit = (entryPrice - closingPrice) * size
                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);

                if (profit &gt; fee)
                {
                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                // profit = (closingPrice - entryPrice) * size
                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  

                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }  

        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount
        updatePositionSize(positionHash, 0, 0);

        emit FuturesPositionClosed(positionHash);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>side == true</code></p>
<hr />
<h3>Contract : Exchange</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd341da9e6ed5c65b7cad193099b6e86f5a2b9929">0xd341da9e6ed5c65b7cad193099b6e86f5a2b9929</a></p>
<pre><code class="language-solidity">function closeFuturesPositionForUser (bytes32 futuresContract, bool side, address user, uint256 gasFee) onlyAdmin
    {
        bytes32 positionHash = keccak256(this, user, futuresContract, side);

        if (futuresContracts[futuresContract].closed == false &amp;&amp; futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled
        if (retrievePosition(positionHash)[1] == 0) throw; // position not found
        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed

        // failsafe, gas fee cannot be greater than 5% of position value
        if (safeMul(gasFee * 1e10, 20) &gt; calculateTradeValue(retrievePosition(positionHash)[0], retrievePosition(positionHash)[1], futuresContract))
        {
            emit LogError(uint8(Errors.GAS_TOO_HIGH), futuresContract, positionHash);
            return;
        }


        uint256 profit;
        uint256 loss;

        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;

        FuturesClosePositionValues memory v = FuturesClosePositionValues({
            reserve         : EtherMium(exchangeContract).getReserve(baseToken, user),
            balance         : EtherMium(exchangeContract).balanceOf(baseToken, user),
            floorPrice      : futuresContracts[futuresContract].floorPrice,
            capPrice        : futuresContracts[futuresContract].capPrice,
            closingPrice    : futuresContracts[futuresContract].closingPrice,
            futuresContract : futuresContract
        });

        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);
        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);
        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;
        // uint256 capPrice = futuresContracts[futuresContract].capPrice;
        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;



        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);
        uint256 fee = safeAdd(calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract), gasFee);

        // close long position
        if (side == true)
        {            

            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);
            // return;
            // reserve = reserve - (entryPrice - floorPrice) * size;
            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));


            subReserve(
                baseToken, 
                user, 
                v.reserve, 
                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice
                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &gt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);



                // LogUint(15, profit);
                // LogUint(16, fee);
                // LogUint(17, safeSub(profit * 1e10, fee));
                // return;
                if (profit &gt; fee)
                {
                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }
                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  


                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }   
        // close short position 
        else
        {
            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);
            // return;

            // reserve = reserve - (capPrice - entryPrice) * size;
            subReserve(
                baseToken, 
                user,  
                v.reserve, 
                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice
                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &lt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                // profit = (entryPrice - closingPrice) * size
                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);

                if (profit &gt; fee)
                {
                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }


                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                // profit = (closingPrice - entryPrice) * size
                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  

                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }  

        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount
        updatePositionSize(positionHash, 0, 0);

        emit FuturesPositionClosed(positionHash);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>side == true</code></p>
<hr />
<h3>Contract : PresaleV2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf787534a3876ffa7d8a2d3e9a6bd1104e5cc6249">0xf787534a3876ffa7d8a2d3e9a6bd1104e5cc6249</a></p>
<pre><code class="language-solidity">function buy(
        address _token,
        uint256 _amount,
        address _onBehalfOf,
        address _refWallet,
        bool _stakeIt
    ) public payable nonReentrant returns (uint256) {
        require(presaleOpen, &quot;presale is closed&quot;);
        require(_token != address(0), &quot;Invalid _token address&quot;);
        require(_onBehalfOf != address(0), &quot;Invalid onBehalfOf address&quot;);
        require(_amount &gt; 0, &quot;Amount should be more than 0&quot;);
        require(_refWallet != address(0), &quot;Invalid refWallet address&quot;);
        require(_refWallet != _onBehalfOf, &quot;buyer can not refer themself&quot;);

        if (originalReferrer[_onBehalfOf] == address(0)) {
            originalReferrer[_onBehalfOf] = _refWallet;
        } else {
            _refWallet = originalReferrer[_onBehalfOf];
        }

        AggregatorV3Interface priceFeed;
        bool found = false;
        uint256 decimals;
        for (uint i = 0; i &lt; paymentTokens.length; i++) {
            if (paymentTokens[i].token == _token) {
                priceFeed = paymentTokens[i].priceFeed;
                decimals = paymentTokens[i].decimals;
                found = true;
                break;
            }
        }
        require(found, &quot;Payment token not supported&quot;);

        uint256 amountInUSD = convertPaymentTokenToUsd(
            _amount,
            priceFeed,
            decimals
        );

        uint256 refEarnedinUSD = (paymentTokenReferralPercentage *
            amountInUSD) / 100;

        uint256 paymentTokenReferralAmount = (paymentTokenReferralPercentage *
            _amount) / 100;

        uint256 forTreasury = _amount - paymentTokenReferralAmount;

        if (_token == eth) {
            (bool sent, ) = treasury.call{value: forTreasury}(&quot;&quot;);
            require(sent, &quot;Failed to send Ether&quot;);
        } else {
            SafeERC20.safeTransferFrom(
                IERC20(_token),
                msg.sender,
                treasury,
                forTreasury
            );
            SafeERC20.safeTransferFrom(
                IERC20(_token),
                msg.sender,
                address(this),
                paymentTokenReferralAmount
            );
        }

        uint256 tokens = (amountInUSD * (10 ** 18)) / tokenPriceUSD;
        balances[_onBehalfOf] += tokens;
        totalBoughtTokens += tokens;

        uint256 refAmount = (tokens * refPercentage) / 100;
        referrals[_refWallet] += refAmount;
        totalReferralTokens += refAmount;

        earnedInUSD[_refWallet] += refEarnedinUSD;

        if (_stakeIt == true) {
            _stake(_onBehalfOf, tokens);
        }

        emit PurchaseMade(
            _token,
            _amount,
            _onBehalfOf,
            tokens,
            _refWallet,
            _stakeIt
        );

        paymentTokenReferralRewards[_refWallet][
            _token
        ] += paymentTokenReferralAmount;

        totalRewardsByPaymentToken[_token] += paymentTokenReferralAmount;

        emit PaymentTokenReferralRewardAdded(
            _refWallet,
            _token,
            paymentTokenReferralAmount,
            refEarnedinUSD,
            _onBehalfOf
        );

        return tokens;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_stakeIt == true</code></p>
<hr />
<h3>Contract : MyEtherCityGame</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbc145bc6bfc6af7370bba5baf6a70dcf4789a3c6">0xbc145bc6bfc6af7370bba5baf6a70dcf4789a3c6</a></p>
<pre><code class="language-solidity">function rentLand(uint _landId, bool _createCity, uint _cityId) public {
        // The owner can rent the land even if it's not marked forRent
        if(lands[_landId].ownerAddress != msg.sender) {
            require(lands[_landId].landForRent == true);
        }

        // Cities can't rent a land if it's already occupied
        require(lands[_landId].isOccupied == false);

        if(_createCity == true) {
            // We create the city if the user is renting this land for a new city
            createCity(_landId);
        } else {
            // Cities can't rent a land if they are already landing one
            require(cities[_cityId].landId == 0);

            // We update the land and city if the user is renting the land for an existing city
            cities[_cityId].landId = _landId;
            lands[_landId].cityRentingId = _cityId;
            lands[_landId].landForSale == false;
            lands[_landId].landForRent == true;
            lands[_landId].isOccupied = true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_createCity == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x94e388d6410a40c36cde41a7ad8e60a820b5971a">0x94e388d6410a40c36cde41a7ad8e60a820b5971a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x94e388d6410a40c36cde41a7ad8e60a820b5971a">0x94e388d6410a40c36cde41a7ad8e60a820b5971a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x94e388d6410a40c36cde41a7ad8e60a820b5971a">0x94e388d6410a40c36cde41a7ad8e60a820b5971a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x94e388d6410a40c36cde41a7ad8e60a820b5971a">0x94e388d6410a40c36cde41a7ad8e60a820b5971a</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1b73bcfec213e7748454e1ec6c4fd9d6e8cf9754">0x1b73bcfec213e7748454e1ec6c4fd9d6e8cf9754</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            if(now.sub(lastTradeTime) &gt; secondsInDay){
                updateTokenPrices(); // Update the prices based on an off-chain Oracle
                checkAndSwapTokens(true);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1b73bcfec213e7748454e1ec6c4fd9d6e8cf9754">0x1b73bcfec213e7748454e1ec6c4fd9d6e8cf9754</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        updateTokenPrices(); // Update the prices based on an off-chain Oracle
        if(nonContract == true){
            checkAndSwapTokens(true);
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }        

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : ComptrollerG1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcec075ff61916085e6a18d79141efcb45607596c">0xcec075ff61916085e6a18d79141efcb45607596c</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcec075ff61916085e6a18d79141efcb45607596c">0xcec075ff61916085e6a18d79141efcb45607596c</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcec075ff61916085e6a18d79141efcb45607596c">0xcec075ff61916085e6a18d79141efcb45607596c</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcec075ff61916085e6a18d79141efcb45607596c">0xcec075ff61916085e6a18d79141efcb45607596c</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc6f08d6cb8da01ee2829328e0ae013c5bc20dcbc">0xc6f08d6cb8da01ee2829328e0ae013c5bc20dcbc</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function
        require(safetyMode == false, &quot;Safety Mode enabled, wait for new strategy deployment&quot;);

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyXUSDArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc6f08d6cb8da01ee2829328e0ae013c5bc20dcbc">0xc6f08d6cb8da01ee2829328e0ae013c5bc20dcbc</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        require(safetyMode == false, &quot;Safety Mode enabled, wait for new strategy deployment&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                uint256 buyID = getCheapestCurveToken();
                (uint256 sellID, ) = withdrawTokenReservesID(); // These may often be the same tokens
                checkAndSwapTokens(address(0), sellID, buyID);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x17babd32505ff012fbd95e30db0047d33fadf7cb">0x17babd32505ff012fbd95e30db0047d33fadf7cb</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_finish == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x17babd32505ff012fbd95e30db0047d33fadf7cb">0x17babd32505ff012fbd95e30db0047d33fadf7cb</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enableTransfer == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x17babd32505ff012fbd95e30db0047d33fadf7cb">0x17babd32505ff012fbd95e30db0047d33fadf7cb</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_finish == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x17babd32505ff012fbd95e30db0047d33fadf7cb">0x17babd32505ff012fbd95e30db0047d33fadf7cb</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enableTransfer == true</code></p>
<hr />
<h3>Contract : BZXAAVEFLASHLIQUIDATE</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x73da1793a35c467af5798d42442c5da4a5cc782c">0x73da1793a35c467af5798d42442c5da4a5cc782c</a></p>
<pre><code class="language-solidity">function performTrade(bool isItEther, uint256 amount1) public returns(uint256) {


        uint256 startingETHBalance = address(this).balance;
        ERC20 tokenToReceive = ERC20(currentCToken);
        uint256 startingCBalance = tokenToReceive.balanceOf(address(this));

        if (isItEther == true) {

        } else {
            ERC20 bzLToken = ERC20(currentLToken);

            if (bzLToken.allowance(address(this), bzx1Address) &lt;= currentMaxLiq) {
                bzLToken.approve(bzx1Address, (currentMaxLiq * 100));
            }
        }

        if (isItEther == false) {
            bzx1.liquidate(currentLoanId, address(this), currentMaxLiq);
        } else {
            bzx1.liquidate {value: amount1}(currentLoanId, address(this), currentMaxLiq);
        }



        uint256 amountBack = 0;
        if (address(this).balance &gt; startingETHBalance) {
            uint256 newETH = address(this).balance - startingETHBalance;
            wethToken.deposit {value: newETH}();


            amountBack = performUniswap(wethAddress, currentLToken, newETH);
        }
        else {



            uint256 difCBalance = tokenToReceive.balanceOf(address(this)) - startingCBalance;
           require(difCBalance &gt;0, &quot;Balance of Collateral token didnt go up after swap didnt go up&quot;);


           amountBack = performUniswap(currentCToken, currentLToken, difCBalance);
        }

        return amountBack;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isItEther == true</code></p>
<hr />
<h3>Contract : DaoStructs</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xca8cdeb92fb992585b5d9c617189898f0cfea735">0xca8cdeb92fb992585b5d9c617189898f0cfea735</a></p>
<pre><code class="language-solidity">function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)
        external
        view
        returns (address[] memory _voters, uint256 _length)
    {
        uint256 _n = _allUsers.length;
        uint256 i;
        _length = 0;
        _voters = new address[](_n);
        if (_vote == true) {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.yesVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        } else {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.noVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : Announcement</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbf74cc2839b4b639062e37b6ea53f3ed7964132c">0xbf74cc2839b4b639062e37b6ea53f3ed7964132c</a></p>
<pre><code class="language-solidity">function addAudit (uint256 msgWaitingN, bool msgGood) isAuditor external {
        // ensure the msgWaiting is not done, and that this auditor has not submitted an audit previously
        require(msgsWaitingDone[msgWaitingN] == false);
        MessageAwaitingAudit msgWaiting = msgsWaiting[msgWaitingN];
        require(msgWaiting.auditedBy[msg.sender] == false);
        require(msgWaiting.alarmedBy[msg.sender] == false);
        require(alarmRaised[msgWaitingN] == false);

        // check if the auditor is giving a thumbs up or a thumbs down and adjust things appropriately
        if (msgGood == true) {
            msgWaiting.nAudits += 1;
            msgWaiting.auditedBy[msg.sender] = true;
        } else {
            msgWaiting.nAlarms += 1;
            msgWaiting.alarmedBy[msg.sender] = true;
        }

        // have we reached the right number of auditors and not triggered an alarm?
        if (msgWaiting.nAudits &gt;= nAuditorsRequired &amp;&amp; msgWaiting.nAlarms &lt; nAuditorsAlarm) {
            // then remove msg from queue and add to messages
            addMsgFinal(msgWaiting.msg, msgWaitingN);
        } else if (msgWaiting.nAlarms &gt;= nAuditorsAlarm) {
            msgsWaitingDone[msgWaitingN] = true;
            alarmRaised[msgWaitingN] = true;
            alarms.push(msgWaitingN);
            nAlarms += 1;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>msgGood == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa469b9196e2efa18c7cba5cadf4c524a9d18cad6">0xa469b9196e2efa18c7cba5cadf4c524a9d18cad6</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa469b9196e2efa18c7cba5cadf4c524a9d18cad6">0xa469b9196e2efa18c7cba5cadf4c524a9d18cad6</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea80f156a860d9fa7c05ac540f1faddaecf78">0xcafea80f156a860d9fa7c05ac540f1faddaecf78</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : MarsGenesisWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb3449f7bc4a7041a7b5cf4f1d9c405d3b96608b4">0xb3449f7bc4a7041a7b5cf4f1d9c405d3b96608b4</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : LendingPoolConfigurator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb398a7cc9c4c8b58991de3edaa820acad98b7d82">0xb398a7cc9c4c8b58991de3edaa820acad98b7d82</a></p>
<pre><code class="language-solidity">function enableReserveForInvoicePool(address _reserve, bool _enable) external onlyLendingPoolManager {
        require(_reserve != address(0x0), &quot;reserve address is invalid&quot;);
        if(_enable == true) {
            require(isInvoiceReserve[_reserve] == false, &quot;reserve is already been enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = true;
        } else {
            require(isInvoiceReserve[_reserve] == true, &quot;reserve is not enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enable == true</code></p>
<hr />
<h3>Contract : IPCWrapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x61e1ea57558b81c3b62578901502fe74d5a924c1">0x61e1ea57558b81c3b62578901502fe74d5a924c1</a></p>
<pre><code class="language-solidity">function wrapX(uint256 totalTokens, bool wrapTokens)
    external {

    uint256[] memory ownersTokenIds;

    if (wrapTokens == true)
      ownersTokenIds = uwGetTokenIdsOfOwner(msg.sender);
    else
      ownersTokenIds = wGetTokenIdsOfOwner(msg.sender);

    uint256 tokenId;

    if (totalTokens == 0 || totalTokens &gt;= ownersTokenIds.length)
      totalTokens = ownersTokenIds.length;

    for (uint256 index = 0; index &lt; totalTokens; index++) {

      tokenId = ownersTokenIds[index];
      if (tokenId &lt;= 0)
        continue;

      if (wrapTokens == true)
        wrap(tokenId);
      else
        unwrap(tokenId);
    }

    emit WrapX(msg.sender, wrapTokens, totalTokens);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>wrapTokens == true</code></p>
<hr />
<h3>Contract : IPCWrapper</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x61e1ea57558b81c3b62578901502fe74d5a924c1">0x61e1ea57558b81c3b62578901502fe74d5a924c1</a></p>
<pre><code class="language-solidity">function wrapX(uint256 totalTokens, bool wrapTokens)
    external {

    uint256[] memory ownersTokenIds;

    if (wrapTokens == true)
      ownersTokenIds = uwGetTokenIdsOfOwner(msg.sender);
    else
      ownersTokenIds = wGetTokenIdsOfOwner(msg.sender);

    uint256 tokenId;

    if (totalTokens == 0 || totalTokens &gt;= ownersTokenIds.length)
      totalTokens = ownersTokenIds.length;

    for (uint256 index = 0; index &lt; totalTokens; index++) {

      tokenId = ownersTokenIds[index];
      if (tokenId &lt;= 0)
        continue;

      if (wrapTokens == true)
        wrap(tokenId);
      else
        unwrap(tokenId);
    }

    emit WrapX(msg.sender, wrapTokens, totalTokens);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>wrapTokens == true</code></p>
<hr />
<h3>Contract : OMNIS</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2b17b8927a8e9844b6ca11c5e0e818bb633c044d">0x2b17b8927a8e9844b6ca11c5e0e818bb633c044d</a></p>
<pre><code class="language-solidity">function answerPaymentRequest(uint _orderId, bool _answer) external returns(bool) {
        //Get Payment Handler
        Payment storage payment = payments[_orderId];

        require(payment.status == PaymentStatus.Requested, 'Ticket wrong status, expected &quot;Requested&quot;');
        require(payment.customer == msg.sender, 'You are not allowed to manage this ticket');

        if (_answer == true) {

            address _to = address(this);

            balances[payment.provider] = balances[payment.provider].sub(payment.value);
            balances[_to] = balances[_to].add(payment.value);
            emit Transfer(payment.provider, _to, payment.value);

            //STAKING RELATED//////////////////////////////////////////////
            if (staked[payment.provider] != 0) staked[payment.provider] = 0;
            uint64 _now = uint64(now);
            lastTransfer[payment.provider] = transferInStruct(uint128(balances[payment.provider]), _now);
            ///////////////////////////////////////////////////////////////

            payments[_orderId].status = PaymentStatus.Pending;

            emit PaymentUpdate(_orderId, payment.provider, payment.customer, payment.value, PaymentStatus.Pending);

        } else {

            payments[_orderId].status = PaymentStatus.Rejected;

            emit PaymentUpdate(_orderId, payment.provider, payment.customer, payment.value, PaymentStatus.Rejected);

        }

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_answer == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x00000f02fa3403f3356e1b367a2e2cb931467205">0x00000f02fa3403f3356e1b367a2e2cb931467205</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : ComptrollerG6</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe2521873cd0f91f8be8c5372df4acf39fcae0ba5">0xe2521873cd0f91f8be8c5372df4acf39fcae0ba5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG6</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe2521873cd0f91f8be8c5372df4acf39fcae0ba5">0xe2521873cd0f91f8be8c5372df4acf39fcae0ba5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG6</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe2521873cd0f91f8be8c5372df4acf39fcae0ba5">0xe2521873cd0f91f8be8c5372df4acf39fcae0ba5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG6</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe2521873cd0f91f8be8c5372df4acf39fcae0ba5">0xe2521873cd0f91f8be8c5372df4acf39fcae0ba5</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x864b2b8639a3c0583cd91dbd8ed8e7fe5b822346">0x864b2b8639a3c0583cd91dbd8ed8e7fe5b822346</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : Rafldex</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf1df3bfa6674bf8b57ecb7d7c36bad77378ac5e4">0xf1df3bfa6674bf8b57ecb7d7c36bad77378ac5e4</a></p>
<pre><code class="language-solidity">function addTokenPayment(address _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        TokenPaymentAddresses[_address] = _isAdded;
        if (_isAdded == true) {
            emit AddedTokenPayment(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : Rafldex</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf1df3bfa6674bf8b57ecb7d7c36bad77378ac5e4">0xf1df3bfa6674bf8b57ecb7d7c36bad77378ac5e4</a></p>
<pre><code class="language-solidity">function blacklistAddressOrNot(address _address, bool _isBlacklist)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        BlacklistAddresses[_address] = _isBlacklist;
        if (_isBlacklist == true) {
            emit UserBlacklisted(_address);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBlacklist == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc72a7b022f95570399bc1fd3956ecd863b391c4e">0xc72a7b022f95570399bc1fd3956ecd863b391c4e</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x49b378d8bb46473696fbd0f6e3e38dd919915b16">0x49b378d8bb46473696fbd0f6e3e38dd919915b16</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // First the interest earned since the last call will be calculated
        // Some will sent to a strategy vault to be later processed when it becomes large enough
        calculateAndStoreInterest(); // This function will also call an update to lastATokenBalance

        // Then convert deposited stablecoins into their aToken equivalents and updates lastATokenBalance
        convertAllToAaveTokens();

        // No trading is performed on deposit
        if(nonContract == true){}
        lastActionBalance = balance(); // This action balance represents pool post stablecoin deposit
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x49b378d8bb46473696fbd0f6e3e38dd919915b16">0x49b378d8bb46473696fbd0f6e3e38dd919915b16</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // First the interest earned since the last call will be calculated and sent to vault
        calculateAndStoreInterest();

        // This is in case there are some leftover raw tokens
        convertAllToAaveTokens();

        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(DIVISION_FACTOR)){
                checkAndSwapTokens(address(0)); // This will also not call calculateAndHold due to 0 address
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : APTA</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x67fee8d0216637c8aebccb8614384ee7932abb32">0x67fee8d0216637c8aebccb8614384ee7932abb32</a></p>
<pre><code class="language-solidity">function setModeIsAuto (uint8 _Mode, bool _isAuto) public NFTOwner {
    Mode = _Mode;
    isAuto = _isAuto;

    if (_Mode == 2 &amp;&amp; _isAuto == true) {
        AutoScrambled = true;
    } else {
        AutoScrambled = false;
    }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_Mode == 2 &amp;&amp; _isAuto == true</code></p>
<hr />
<h3>Contract : LendingPoolConfigurator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x903af4b52bbec2d0e8895332cc8fdd46dc310054">0x903af4b52bbec2d0e8895332cc8fdd46dc310054</a></p>
<pre><code class="language-solidity">function enableReserveForInvoicePool(address _reserve, bool _enable) external onlyLendingPoolManager {
        require(_reserve != address(0x0), &quot;reserve address is invalid&quot;);
        if(_enable == true) {
            require(isInvoiceReserve[_reserve] == false, &quot;reserve is already been enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = true;
        } else {
            require(isInvoiceReserve[_reserve] == true, &quot;reserve is not enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enable == true</code></p>
<hr />
<h3>Contract : StabilizeStrategySGRArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb3b7d98153272e0b5ffe7022b3b43571e4605edb">0xb3b7d98153272e0b5ffe7022b3b43571e4605edb</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
        require(lastActionBalance &lt;= maxPoolSize,&quot;This strategy has reached its maximum balance&quot;);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategySGRArbV3</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb3b7d98153272e0b5ffe7022b3b43571e4605edb">0xb3b7d98153272e0b5ffe7022b3b43571e4605edb</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){
            if(_share &gt; _total.mul(percentTradeTrigger).div(divisionFactor)){
                checkAndSwapTokens(_depositor);
            }
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerBalance(_depositor, _myBalance, false); // This will withdraw based on token balance
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerBalance(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : MultiStream</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x40fb0ac11d00a30092e188683f5291b467d13517">0x40fb0ac11d00a30092e188683f5291b467d13517</a></p>
<pre><code class="language-solidity">function addStream(
        address _beneficiary,
        uint256 _cap,
        uint256 _frequency,
        bool _startsFull,
        string calldata _name
    ) external hasCorrectRole {
        if (streams[_beneficiary].last &gt; 0) {
            revert StreamAlreadyExists();
        }
        ownerIndex[streamCount] = _beneficiary;
        inverseOwnerIndex[_beneficiary] = streamCount;
        streamCount += 1;
        uint256 last;
        if (_startsFull == true) {
            last = block.timestamp - _frequency;
        } else {
            last = block.timestamp;
        }
        Stream memory stream = Stream(_cap, _frequency, last, 0, _name);
        streams[_beneficiary] = stream;
        orgInfo.totalStreams += 1;
        emit StreamAdded(_msgSender(), _beneficiary, _name);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_startsFull == true</code></p>
<hr />
<h3>Contract : MultiStream</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x40fb0ac11d00a30092e188683f5291b467d13517">0x40fb0ac11d00a30092e188683f5291b467d13517</a></p>
<pre><code class="language-solidity">function enableStream(
        address _beneficiary,
        uint256 _cap,
        uint256 _frequency,
        bool _startsFull
    ) external hasCorrectRole {

        streams[_beneficiary].cap = _cap;
        streams[_beneficiary].frequency = _frequency;

        if (_startsFull == true) {
            streams[_beneficiary].last = block.timestamp - _frequency;
        } else {
            streams[_beneficiary].last = block.timestamp;
        }

        disabled[_beneficiary] = false;
        orgInfo.totalStreams += 1;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_startsFull == true</code></p>
<hr />
<h3>Contract : DevWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe7c6f89357f97001dc6be72e758d72e0aba15db2">0xe7c6f89357f97001dc6be72e758d72e0aba15db2</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(msg.sender == _devMultiSigWalletAddress, &quot;ONLY_DEV_MULTISIG&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function editNode(
        Data storage self, 
        uint _nodeID, 
        address _nodeAddress, 
        bool _isNewProducer, 
        address _newProducer, 
        uint8 _newProducersPercent,
        bool _starmidConfirmed
        ) returns (bool) {
        if (_isNewProducer == true) {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].producer = _newProducer;
            self.nodes[_nodeID].producersPercent = _newProducersPercent;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
        else {
            self.nodes[_nodeID].node = _nodeAddress;
            self.nodes[_nodeID].starmidConfirmed = _starmidConfirmed;
            return true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isNewProducer == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : CommonLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function stockDeleteFirstOrder(StarCoinLibrary.Data storage self, uint _node, uint _price, bool _isStockSellOrders) {
        if (_isStockSellOrders == true) uint _length = self.stockSellOrders[_node][_price].length;
        else _length = self.stockBuyOrders[_node][_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isStockSellOrders == true) self.stockSellOrders[_node][_price][ii] = self.stockSellOrders[_node][_price][ii + 1];
            else self.stockBuyOrders[_node][_price][ii] = self.stockBuyOrders[_node][_price][ii + 1];
        }
        if (_isStockSellOrders == true) {
            delete self.stockSellOrders[_node][_price][self.stockSellOrders[_node][_price].length - 1];
            self.stockSellOrders[_node][_price].length--;
            //Delete _price from stockSellOrderPrices[_node][] if it's the last order
            if (self.stockSellOrders[_node][_price].length == 0) {
                uint fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.stockSellOrderPrices[_node].length - 1; iii++) {
                    if (self.stockSellOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockSellOrderPrices[_node][iii] = self.stockSellOrderPrices[_node][iii + 1];
                }
                delete self.stockSellOrderPrices[_node][self.stockSellOrderPrices[_node].length-1];
                self.stockSellOrderPrices[_node].length--;
            }
        }
        else {
            delete self.stockBuyOrders[_node][_price][self.stockBuyOrders[_node][_price].length - 1];
            self.stockBuyOrders[_node][_price].length--;
            //Delete _price from stockBuyOrderPrices[_node][] if it's the last order
            if (self.stockBuyOrders[_node][_price].length == 0) {
                fromArg = 99999;
                for (iii = 0; iii &lt; self.stockBuyOrderPrices[_node].length - 1; iii++) {
                    if (self.stockBuyOrderPrices[_node][iii] == _price) {
                        fromArg = iii;
                    }
                    if (fromArg != 99999 &amp;&amp; iii &gt;= fromArg) self.stockBuyOrderPrices[_node][iii] = self.stockBuyOrderPrices[_node][iii + 1];
                }
                delete self.stockBuyOrderPrices[_node][self.stockBuyOrderPrices[_node].length-1];
                self.stockBuyOrderPrices[_node].length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isStockSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : StarCoinLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function deleteFirstOrder(Data storage self, uint _price, bool _isSellOrders) {
        if (_isSellOrders == true) uint _length = self.sellOrders[_price].length;
        else _length = self.buyOrders[_price].length;
        for (uint ii = 0; ii &lt; _length - 1; ii++) {
            if (_isSellOrders == true) self.sellOrders[_price][ii] = self.sellOrders[_price][ii + 1];
            else self.buyOrders[_price][ii] = self.buyOrders[_price][ii+1];
        }
        if (_isSellOrders == true) {
            delete self.sellOrders[_price][self.sellOrders[_price].length - 1];
            self.sellOrders[_price].length--;
            //Delete _price from sellOrderPrices[] if it's the last order
            if (_length == 1) {
                uint _fromArg = 99999;
                for (uint8 iii = 0; iii &lt; self.sellOrderPrices.length - 1; iii++) {
                    if (self.sellOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.sellOrderPrices[iii] = self.sellOrderPrices[iii + 1];
                }
                delete self.sellOrderPrices[self.sellOrderPrices.length-1];
                self.sellOrderPrices.length--;
            }
        }
        else {
            delete self.buyOrders[_price][self.buyOrders[_price].length - 1];
            self.buyOrders[_price].length--;
            //Delete _price from buyOrderPrices[] if it's the last order
            if (_length == 1) {
                _fromArg = 99999;
                for (iii = 0; iii &lt; self.buyOrderPrices.length - 1; iii++) {
                    if (self.buyOrderPrices[iii] == _price) {
                        _fromArg = iii;
                    }
                    if (_fromArg != 99999 &amp;&amp; iii &gt;= _fromArg) self.buyOrderPrices[iii] = self.buyOrderPrices[iii + 1];
                }
                delete self.buyOrderPrices[self.buyOrderPrices.length-1];
                self.buyOrderPrices.length--;
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSellOrders == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function getOrderInfo(bool _isBuyOrder, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.buyOrders[_price][_number].client;
            _amount = sCVars.buyOrders[_price][_number].amount;
            _orderId = sCVars.buyOrders[_price][_number].orderId;
        }
        else {
            _address = sCVars.sellOrders[_price][_number].client;
            _amount = sCVars.sellOrders[_price][_number].amount;
            _orderId = sCVars.sellOrders[_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0c2f943e1478173e02e78df8562cb5633dbb9027">0x0c2f943e1478173e02e78df8562cb5633dbb9027</a></p>
<pre><code class="language-solidity">function getStockOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns(address _address, uint _amount, uint _orderId) {
        if(_isBuyOrder == true) {
            _address = sCVars.stockBuyOrders[_node][_price][_number].client;
            _amount = sCVars.stockBuyOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockBuyOrders[_node][_price][_number].orderId;
        }
        else {
            _address = sCVars.stockSellOrders[_node][_price][_number].client;
            _amount = sCVars.stockSellOrders[_node][_price][_number].amount;
            _orderId = sCVars.stockSellOrders[_node][_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : PonziBet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x485b224c97ad56dc5b145eafdee71a7b5163f735">0x485b224c97ad56dc5b145eafdee71a7b5163f735</a></p>
<pre><code class="language-solidity">function enterRound(bool _bet) 
     external 
     payable 
  {
    require(msg.value &gt;= 10000000000000000);
    if(roundTime == uint(0) || roundTime + 30 minutes &lt;= now) {
      endPrice = uint(0);
      upBetRecords.length = uint(0);
      downBetRecords.length = uint(0);
      startPrice = pyramid.buyPrice();
      roundTime = now;    
    }
    if(roundTime + 15 minutes &gt; now) {
      uint fee = msg.value.div(20);
      uint userAmount = msg.value.sub(fee);
      feeBalance[admin] =  feeBalance[admin].add(fee);
      if(_bet == true) {
        recordBet(true,userAmount);
      }
      else if(_bet == false) {
        recordBet(false,userAmount);
      }   
      lastBet[msg.sender] = now;
    }
    else {
      revert();
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_bet == true</code></p>
<hr />
<h3>Contract : RisingStackersStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x78fa4a87ea668fbc6f9bf37837cc77edd6f160f4">0x78fa4a87ea668fbc6f9bf37837cc77edd6f160f4</a></p>
<pre><code class="language-solidity">function stake(uint256 tokenId, bool _boost, uint256 _rank) public {
        uint256 _mulx = 0;
        require(_nft.ownerOf(tokenId) == msg.sender, &quot;It is not your NFT&quot;);
        require(stakingDetails[tokenId].tokenId == 0, &quot;Already Staked&quot;);
        totalStaked += 1;
        stakedNftPerAddress[msg.sender].push(tokenId);
        addStaker(msg.sender);
        if(_boost == true){
            if(_boostToken.balanceOf(msg.sender,legendaryPotion) &gt; 0){
                _boost = true;
                _mulx = 20;
            }else if(_boostToken.balanceOf(msg.sender,rarePotion) &gt; 0){
                _boost = true;
                _mulx = 15;
            }else if(_boostToken.balanceOf(msg.sender,commonPotion) &gt; 0){
                _boost = true;
                _mulx = 12;
            }else{
                _boost = false;
            }
        }
        _nft.transferFrom(msg.sender, address(this), tokenId);
        stakingDetails[tokenId] = Stake({
            owner: msg.sender,
            tokenId: uint256(tokenId),
            timestamp: uint256(block.timestamp),
            boost : _boost,
            mulx : _mulx,
            rank : _rank
        });
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_boost == true</code></p>
<hr />
<h3>Contract : The_Starry_Night_Original</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2b4469e779b7111269969b37aee5f3c47f81a756">0x2b4469e779b7111269969b37aee5f3c47f81a756</a></p>
<pre><code class="language-solidity">function mintForAll(uint256 amount, bool _isUK) external payable {
        require(mintStarted == true, &quot;Minting is not yet open.&quot;);
        require(publicMintCount + amount &lt;= publicMintSupply, &quot;Sold Out.&quot;);
        require(amount &lt;= MAX_MINT_PER_ACCOUNT, &quot;Amount Exceeds Maximum Mints Allowed Per Account.&quot;);
        require(userNftCount[msg.sender] + amount &lt;= MAX_MINT_PER_ACCOUNT, &quot;You can not mint more than Max Mint Limit.&quot;);
        require(_totalMinted() + amount &lt;= MAX_SUPPLY , &quot;Exceeds Maximum Supply&quot; );
        uint totalCost = amount * mintPrice;
        if (_isUK == true) {
            totalCost = totalCost * 120 / 100; // add 20% VAT tax for UK
        }        
        require( msg.value &gt;= totalCost, &quot;Ether sent is not correct.&quot; );
        _mintRandom(msg.sender, amount);
        publicMintCount += amount;
        userNftCount[msg.sender] += amount;
        if (msg.value &gt; totalCost) {
            payable(msg.sender).transfer(msg.value - totalCost);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isUK == true</code></p>
<hr />
<h3>Contract : HelmsForLoot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc1f0bfc1fb0d049dc903a690eae2cfe5a3e780a1">0xc1f0bfc1fb0d049dc903a690eae2cfe5a3e780a1</a></p>
<pre><code class="language-solidity">function purchaseMatching(
        ILoot claimLoot,
        uint256[] memory claimIds,
        uint256[] memory lootIds,
        bool claimRiftXP
    ) public payable {
        require(
            state == SaleState.Phase1 ||
                state == SaleState.Phase2 ||
                state == SaleState.Phase3,
            &quot;HelmsForLoot: sale not active&quot;
        );

        require(lootContracts[claimLoot], &quot;HelmsForLoot: not compatible&quot;);

        if (lootOnly == true) {
            require(
                claimLoot == ogLootContract,
                &quot;HelmsForLoot: loot-only minting period is active.&quot;
            );
        }

        require(lootIds.length &gt; 0, &quot;HelmsForLoot: buy at least one&quot;);
        require(lootIds.length &lt;= 26, &quot;HelmsForLoot: too many at once&quot;);

        uint256[] memory tokenIds = new uint256[](lootIds.length);
        uint256 price = 0;

        for (uint256 i = 0; i &lt; lootIds.length; i++) {
            // Reserve Loot IDs 7778 to 8000 for ownerClaim
            require(
                (lootIds[i] &gt; 0 &amp;&amp; lootIds[i] &lt; 7778),
                &quot;HelmsForLoot: invalid Loot ID&quot;
            );

            require(
                claimLoot.ownerOf(claimIds[i]) == msg.sender,
                &quot;HelmsForLoot: not owner&quot;
            );

            require(
                keccak256(abi.encodePacked(claimLoot.getHead(claimIds[i]))) ==
                    keccak256(
                        abi.encodePacked(ogLootContract.getHead(lootIds[i]))
                    ),
                &quot;HelmsForLoot: wrong helm&quot;
            );

            // Both the original loot bag and matching bag
            // (loot/mloot/genesis adventurer) to be unclaimed
            require(
                !lootClaimed[claimLoot][claimIds[i]],
                &quot;HelmsForLoot: bag already used for claim&quot;
            );
            require(
                !lootMinted[lootIds[i]],
                &quot;HelmsForLoot: loot bag already minted&quot;
            );

            uint256 rarity = helmRarity(lootIds[i]);

            if (rarity == 1) {
                require(
                    state == SaleState.Phase1 ||
                        state == SaleState.Phase2 ||
                        state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceCommon;
            } else if (rarity == 2) {
                require(
                    state == SaleState.Phase2 || state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceEpic;
            } else if (rarity == 3) {
                require(
                    state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceLegendary;
            } else {
                require(
                    state == SaleState.Phase3,
                    &quot;HelmsForLoot: sale not active&quot;
                );
                price += lootOwnerPriceMythic;
            }
            lootMinted[lootIds[i]] = true;
            lootClaimed[claimLoot][lootIds[i]] = true;
            tokenIds[i] = lmartContract.headId(lootIds[i]);
        }
        require(msg.value == price, &quot;HelmsForLoot: wrong price&quot;);

        // We're using a loop with _mint rather than _mintBatch
        // as currently some centralised tools like Opensea
        // have issues understanding the `TransferBatch` event
        for (uint256 i = 0; i &lt; tokenIds.length; i++) {
            uint256 riftId;
            // Add XP via The Rift
            if (claimRiftXP == true) {
                // Adjust ID for gLoot:
                if (claimLoot != ogLootContract &amp;&amp; claimIds[i] &lt; 8001) {
                    riftId = claimIds[i] + 9997460;
                } else {
                    riftId = claimIds[i];
                }
                riftDataContract.addXP(200, riftId);
            }
            _mint(msg.sender, tokenIds[i], 1, &quot;&quot;);
            emit Claimed(lootIds[i]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claimRiftXP == true</code></p>
<hr />
<h3>Contract : LendingPoolConfigurator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa5a1fcb63280080f1ba941484f23c59cedf55bb2">0xa5a1fcb63280080f1ba941484f23c59cedf55bb2</a></p>
<pre><code class="language-solidity">function enableReserveForInvoicePool(address _reserve, bool _enable) external onlyLendingPoolManager {
        require(_reserve != address(0x0), &quot;reserve address is invalid&quot;);
        if(_enable == true) {
            require(isInvoiceReserve[_reserve] == false, &quot;reserve is already been enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = true;
        } else {
            require(isInvoiceReserve[_reserve] == true, &quot;reserve is not enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enable == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0">0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0</a></p>
<pre><code class="language-solidity">function relay(
        bytes32 _txid,
        address _user,
        uint256 _amount,
        uint256 _src_chain_id,
        uint256 _dest_chain_id,
        bool _tryTeleport,
        bool _confirmed
    ) onlyRelayer external {
        // check if txid is already relayed
        require(relayed_txids[_txid] == false, &quot;txid already relayed&quot;);

        // check if txid is confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // check if txid is already voted
        require(voted_txids[msg.sender][_txid] == false, &quot;txid already voted&quot;);

        // check if network/chain ids are correct
        // Note: the tx's dest is this contract's src and vice versa
        require(_src_chain_id == dest_chain_id, &quot;invalid src chain id&quot;);
        require(_dest_chain_id == src_chain_id, &quot;invalid dest chain id&quot;);

        // check if amount is correct
        require(_amount &gt; 0, &quot;invalid amount&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // add vote
        votes[_txid].push(Vote({
            relayer: msg.sender,
            user: _user,
            amount: _amount,
            txid: _txid,
            confirmed: _confirmed
        }));

        // mark txid as voted
        voted_txids[msg.sender][_txid] = true;

        emit Relayed(msg.sender, _user, _amount, _txid);

        if (_tryTeleport == true) {
            tryTeleport(_txid, _user, _amount, true, false);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryTeleport == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0">0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0</a></p>
<pre><code class="language-solidity">function relay(
        bytes32 _txid,
        address _user,
        uint256 _amount,
        uint256 _src_chain_id,
        uint256 _dest_chain_id,
        bool _tryTeleport,
        bool _confirmed
    ) onlyRelayer external {
        // check if txid is already relayed
        require(relayed_txids[_txid] == false, &quot;txid already relayed&quot;);

        // check if txid is confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // check if txid is already voted
        require(voted_txids[msg.sender][_txid] == false, &quot;txid already voted&quot;);

        // check if network/chain ids are correct
        // Note: the tx's dest is this contract's src and vice versa
        require(_src_chain_id == dest_chain_id, &quot;invalid src chain id&quot;);
        require(_dest_chain_id == src_chain_id, &quot;invalid dest chain id&quot;);

        // check if amount is correct
        require(_amount &gt; 0, &quot;invalid amount&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // add vote
        votes[_txid].push(Vote({
            relayer: msg.sender,
            user: _user,
            amount: _amount,
            txid: _txid,
            confirmed: _confirmed
        }));

        // mark txid as voted
        voted_txids[msg.sender][_txid] = true;

        emit Relayed(msg.sender, _user, _amount, _txid);

        if (_tryTeleport == true) {
            tryTeleport(_txid, _user, _amount, true, false);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryTeleport == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0">0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryFinalize == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0">0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_failOnInsufficientQuorum == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0">0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_tryFinalize == true</code></p>
<hr />
<h3>Contract : PointBridgeV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0">0xb73ea9b1ac3ab48ea7b68a1c66a5e828cc63c2a0</a></p>
<pre><code class="language-solidity">function tryTeleport(bytes32 _txid, address _user, uint256 _amount, bool _tryFinalize, bool _failOnInsufficientQuorum) public onlyRelayerOrOwner() {
        // check if already confirmed
        require(confirmed_txids[_txid] == false, &quot;txid already confirmed&quot;);

        // txid must never be 0x0
        require(_txid != bytes32(0), &quot;invalid txid&quot;);

        // get votes
        Vote[] memory _votes = votes[_txid];

        uint256 votes_for = 0;
        uint256 votes_against = 0;

        // go through each vote
        for (uint256 i = 0; i &lt; _votes.length; i++) {
            // get vote
            Vote memory _vote = _votes[i];

            // make sure the data matches
            if (_vote.user != _user || _vote.amount != _amount) {
                continue;
            }

            // check if vote is confirmed
            if (_vote.confirmed == true) {
                votes_for++;
            } else {
                votes_against++;
            }
        }

        // check if votes are enough
        bool condition = votes_for &gt;= quorum &amp;&amp; votes_against == 0;

        if (condition) {
            // set confirmed
            confirmed_txids[_txid] = true;

            // remove votes from storage
            delete votes[_txid];

            emit Confirmed(_user, _amount, _txid);

            if (_tryFinalize == true) {
                finalizeTeleport(_txid, _user, _amount);
            }
        } else {
            // check if we should fail
            if (_failOnInsufficientQuorum == true) {
                revert(&quot;insufficient quorum&quot;);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_failOnInsufficientQuorum == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x16b6e18f2f5ea465ae862e8f3908c25df55a2956">0x16b6e18f2f5ea465ae862e8f3908c25df55a2956</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x16b6e18f2f5ea465ae862e8f3908c25df55a2956">0x16b6e18f2f5ea465ae862e8f3908c25df55a2956</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : DiscLendtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1535e51caf6a0b7e54652eb7de5d66220d00d8eb">0x1535e51caf6a0b7e54652eb7de5d66220d00d8eb</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : DiscLendtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1535e51caf6a0b7e54652eb7de5d66220d00d8eb">0x1535e51caf6a0b7e54652eb7de5d66220d00d8eb</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : DiscLendtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1535e51caf6a0b7e54652eb7de5d66220d00d8eb">0x1535e51caf6a0b7e54652eb7de5d66220d00d8eb</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : DiscLendtroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1535e51caf6a0b7e54652eb7de5d66220d00d8eb">0x1535e51caf6a0b7e54652eb7de5d66220d00d8eb</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : equalize_coin</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x1f211b9ffb62531b062c625d1dad6a74e42ad4dc">0x1f211b9ffb62531b062c625d1dad6a74e42ad4dc</a></p>
<pre><code class="language-solidity">function send_transaction(uint8 _coin_in, uint8 _coin_out, uint _amount, uint _slippage, bool _multihop, uint _timedead) public {
        if (get_poolFee(arr_token_address[_coin_in], arr_token_address[_coin_out]) != 0) {         
            send_transaction_single(_coin_in, _coin_out, _amount, _slippage, _timedead);
        } else {
            if (_multihop == true) {
                bytes memory _path = getMultiPool(arr_token_address[_coin_in], arr_token_address[_coin_out]);
                uint24 a = 0;
                if (keccak256(_path) != keccak256(abi.encodePacked(a))) {
                    send_transaction_multi(_coin_in, _coin_out, _amount, _slippage, _path, _timedead);
                } else {
                    emit errors(string(abi.encodePacked(string(&quot;three is no liquidity. Swap faild: &quot;), _coin_in, string(&quot; - &quot;), _coin_out, string(&quot; =&gt; &quot;), _amount / 100, string(&quot;.&quot;), _amount % 100)));
                }
            } else {
                emit errors(string(abi.encodePacked(string(&quot;turn on Multihop and maybe swap will complete. Swap faild: &quot;), _coin_in, string(&quot; - &quot;), _coin_out, string(&quot; =&gt; &quot;), _amount / 100, string(&quot;.&quot;), _amount % 100)));
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_multihop == true</code></p>
<hr />
<h3>Contract : SpaceAuction</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x07c3c293dc6c71bcc00142738ec1a356340a2d17">0x07c3c293dc6c71bcc00142738ec1a356340a2d17</a></p>
<pre><code class="language-solidity">function invalidateWinner(bytes32 _proposal, bool _slash) public onlyTeam {
    require(proposal[_proposal].status == 1, &quot;!1&quot;); // Can only invalidate if the winner has not been confirmed
    uint256 w = proposal[_proposal].winningBid;
    require(proposal[_proposal].bids[w].invalid == false, &quot;already invalidated&quot;); // prevents double slashing
    proposal[_proposal].bids[w].invalid = true;
    if(_slash == true) {
      uint256 slashed = bidder[_proposal][proposal[_proposal].bids[w].owner].balance*slashFee/DENOMINATOR; // calculate slashed amount
      bidder[_proposal][proposal[_proposal].bids[w].owner].balance -= slashed;  // remove slashed amount from user balance
      CRV.safeTransfer(platform, slashed); // send slashed amount to platform multi-sig
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_slash == true</code></p>
<hr />
<h3>Contract : CEther</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x104079a87ce46fe2cf27b811f6b406b69f6872b3">0x104079a87ce46fe2cf27b811f6b406b69f6872b3</a></p>
<pre><code class="language-solidity">function mint(bool enterMarket) external payable {
        (uint err,) = mintInternal(msg.value);
        requireNoError(err, &quot;mint failed&quot;);
        //If the user wants to use assets as collateral, enter them into the relevant market
        if(enterMarket == true){
            address[] memory marketToEnter = new address[](1);
            marketToEnter[0] = address(this);
            comptroller.enterMarkets(marketToEnter, msg.sender);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>enterMarket == true</code></p>
<hr />
<h3>Contract : SakeSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4429dbcbae70d33895640537b78859c47b0f980b">0x4429dbcbae70d33895640537b78859c47b0f980b</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;SakeSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;SakeSwap: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : SakeSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4429dbcbae70d33895640537b78859c47b0f980b">0x4429dbcbae70d33895640537b78859c47b0f980b</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;SakeSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : KOLVote</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0e2ef074c1a772f93d57e199d3570dab67a37bf2">0x0e2ef074c1a772f93d57e199d3570dab67a37bf2</a></p>
<pre><code class="language-solidity">function voteMission(uint16 _type,uint256 _missionId,bool _agree) onlyNodes public{
      require(!Voter[msg.sender][_missionId]);
      require(!missionList[_missionId].done);
      uint16 minNodesNum = minNodes;
      uint16 minSuperNodesNum = minSuperNodes;
      uint16 passNodes = halfNodes;
      uint16 passSuperNodes = halfSuperNodes;
      uint16 rate = half;
      if (missionList[_missionId].name == &quot;CHANGE OWNER&quot;) {
        rate = most;
        minNodesNum = totalNodes;
        passNodes = mostNodes;
      }else if (missionList[_missionId].name == &quot;CHANGE NODE&quot;){
        rate = less;
        minSuperNodesNum = minSuperNodes;
        passSuperNodes = halfSuperNodes;
      }else if (missionList[_missionId].name == &quot;CHANGE SUPER NODE&quot;){
        rate = less;
        minNodesNum = minNodes;
        passNodes = halfNodes;
      }else if (missionList[_missionId].name == &quot;CREATION ISSUING&quot;){
        minNodesNum = minNodes;
        passNodes = halfNodes;
        minSuperNodesNum = minSuperNodes;
        passSuperNodes = halfSuperNodes;
      }else if (missionList[_missionId].name == &quot;RECYCLE TOKEN FROM OWNER&quot;){
        minNodesNum = minNodes;
        passNodes = halfNodes;
      }

      if (_type == 1){
        require(isSuperNode[msg.sender]);
      }else if (_type ==2){
        require(isNode[msg.sender]);
      }

      if(now &gt; missionList[_missionId].endTime){
        if ( _type == 1 ){
          if (
            (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes)&gt;=minSuperNodesNum
            &amp;&amp;
            missionList[_missionId].agreeSuperNodes &gt;= (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes) * rate/100
            ){
              missionList[_missionId].superPassed = true;
              missionPassed(_missionId);
          }
        }else if (_type ==2 ){
          //节点投票
          if (
            (missionList[_missionId].agreeNodes + missionList[_missionId].refuseNodes)&gt;=minNodesNum
            &amp;&amp;
            missionList[_missionId].agreeNodes &gt;= (missionList[_missionId].refuseNodes + missionList[_missionId].refuseNodes) * rate/100
            ){
              missionList[_missionId].nodePassed = true;
          }
        }
      }else{
        if(_agree == true){
          if (_type == 1){
            missionList[_missionId].agreeSuperNodes++;
          }else if(_type == 2){
            missionList[_missionId].agreeNodes++;
          }
        }
        else{
          if (_type == 1){
            missionList[_missionId].refuseSuperNodes++;
          }else if(_type == 2){
            missionList[_missionId].refuseNodes++;
          }
        }
        if (_type == 1){
          if (missionList[_missionId].agreeSuperNodes &gt;= passSuperNodes) {
              missionList[_missionId].superPassed = true;
              missionPassed(_missionId);
          }else if (missionList[_missionId].refuseSuperNodes &gt;= passSuperNodes) {
              missionList[_missionId].done = true;
          }
        }else if (_type ==2){
          if (missionList[_missionId].agreeNodes &gt;= passNodes) {
              missionList[_missionId].nodePassed = true;
          }else if (missionList[_missionId].refuseNodes &gt;= passNodes) {
              missionList[_missionId].done = true;
          }
        }
      }
      Voter[msg.sender][_missionId] = true;
      excuteAuto(_missionId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_agree == true</code></p>
<hr />
<h3>Contract : KOLFund</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0e2ef074c1a772f93d57e199d3570dab67a37bf2">0x0e2ef074c1a772f93d57e199d3570dab67a37bf2</a></p>
<pre><code class="language-solidity">function voteMission(uint16 _type,uint256 _missionId,bool _agree) onlyNodes public{
    require(!Voter[msg.sender][_missionId]);
    require(!missionList[_missionId].done);
    uint16 minNodesNum = minNodes;
    uint16 minSuperNodesNum = minSuperNodes;
    uint16 passNodes = halfNodes;
    uint16 passSuperNodes = halfSuperNodes;
    uint16 rate = half;

    if (_type == 1){
      require(token.querySuperNode(msg.sender));
    }else if (_type ==2){
      require(token.queryNode(msg.sender));
    }

    if(now &gt; missionList[_missionId].endTime){
      if ( _type == 1 ){
        if (
          (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes)&gt;=minSuperNodesNum
          &amp;&amp;
          missionList[_missionId].agreeSuperNodes &gt;= (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes) * rate/100
          ){
            missionList[_missionId].superPassed = true;
            missionPassed(_missionId);
        }
      }else if (_type ==2 ){
        //节点投票
        if (
          (missionList[_missionId].agreeNodes + missionList[_missionId].refuseNodes)&gt;=minNodesNum
          &amp;&amp;
          missionList[_missionId].agreeNodes &gt;= (missionList[_missionId].refuseNodes + missionList[_missionId].refuseNodes) * rate/100
          ){
            missionList[_missionId].nodePassed = true;
        }
      }
    }else{
      if(_agree == true){
        if (_type == 1){
          missionList[_missionId].agreeSuperNodes++;
        }else if(_type == 2){
          missionList[_missionId].agreeNodes++;
        }
      }
      else{
        if (_type == 1){
          missionList[_missionId].refuseSuperNodes++;
        }else if(_type == 2){
          missionList[_missionId].refuseNodes++;
        }
      }
      if (_type == 1){
        if (missionList[_missionId].agreeSuperNodes &gt;= passSuperNodes) {
            missionList[_missionId].superPassed = true;
            missionPassed(_missionId);
        }else if (missionList[_missionId].refuseSuperNodes &gt;= passSuperNodes) {
            missionList[_missionId].done = true;
        }
      }else if (_type ==2){
        if (missionList[_missionId].agreeNodes &gt;= passNodes) {
            missionList[_missionId].nodePassed = true;
        }else if (missionList[_missionId].refuseNodes &gt;= passNodes) {
            missionList[_missionId].done = true;
        }
      }
    }
    Voter[msg.sender][_missionId] = true;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_agree == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xece0429a5130ebe0616363939067eefca4fbaceb">0xece0429a5130ebe0616363939067eefca4fbaceb</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_finish == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xece0429a5130ebe0616363939067eefca4fbaceb">0xece0429a5130ebe0616363939067eefca4fbaceb</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enableTransfer == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xece0429a5130ebe0616363939067eefca4fbaceb">0xece0429a5130ebe0616363939067eefca4fbaceb</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_finish == true</code></p>
<hr />
<h3>Contract : BISK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xece0429a5130ebe0616363939067eefca4fbaceb">0xece0429a5130ebe0616363939067eefca4fbaceb</a></p>
<pre><code class="language-solidity">function initTokens(address[] _tos, uint[] _amts, bool _finish, bool _enableTransfer) public onlyController returns (bool) {
      require(generateFinished == false);
      require(_tos.length == _amts.length);

      for(uint i=0; i&lt;_tos.length; i++) {
        require(_tos[i] != 0x0);
        require(_amts[i] &gt; 0);

        super.generateTokens(_tos[i], _amts[i]);
      }

      if(_finish == true) {
        finishGenerating();
      }
      if(_enableTransfer == true) {
        enableTransfers(true);
      }

      return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enableTransfer == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xef841587a70539603ebdcff181eef72652bdda87">0xef841587a70539603ebdcff181eef72652bdda87</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xef841587a70539603ebdcff181eef72652bdda87">0xef841587a70539603ebdcff181eef72652bdda87</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xef841587a70539603ebdcff181eef72652bdda87">0xef841587a70539603ebdcff181eef72652bdda87</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xef841587a70539603ebdcff181eef72652bdda87">0xef841587a70539603ebdcff181eef72652bdda87</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : whitelistChecker</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf2e259534247752b3f8791c6643886dc9bfc2889">0xf2e259534247752b3f8791c6643886dc9bfc2889</a></p>
<pre><code class="language-solidity">function whitelistArray(address[] memory _who, bool _status) public OnlyOwner {
        if (_status == true) {
            require((_who.length - 1) + amount.current() &lt; 3, &quot;Whitelist limit has been hit.&quot;);
        }
        for (uint256 i = 0; i &lt; _who.length;) {
            whitelisted[_who[i]] = _status;
            if (_status == true) {
                amount.increment();
            } else {
                amount.decrement();
            }
            emit WhitelistChange(_who[i], _status);
            i += 1;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : whitelistChecker</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf2e259534247752b3f8791c6643886dc9bfc2889">0xf2e259534247752b3f8791c6643886dc9bfc2889</a></p>
<pre><code class="language-solidity">function whitelistArray(address[] memory _who, bool _status) public OnlyOwner {
        if (_status == true) {
            require((_who.length - 1) + amount.current() &lt; 3, &quot;Whitelist limit has been hit.&quot;);
        }
        for (uint256 i = 0; i &lt; _who.length;) {
            whitelisted[_who[i]] = _status;
            if (_status == true) {
                amount.increment();
            } else {
                amount.decrement();
            }
            emit WhitelistChange(_who[i], _status);
            i += 1;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdc350d09f71c48c5d22fbe2741e4d6a03970e192">0xdc350d09f71c48c5d22fbe2741e4d6a03970e192</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2ef2c2daee2743af611bbfa95d7affc92430f3c3">0x2ef2c2daee2743af611bbfa95d7affc92430f3c3</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2ef2c2daee2743af611bbfa95d7affc92430f3c3">0x2ef2c2daee2743af611bbfa95d7affc92430f3c3</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : AddressesGeneratorIronBank</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa0b57619a980dfefd50f24f310ee1b55a40a9d46">0xa0b57619a980dfefd50f24f310ee1b55a40a9d46</a></p>
<pre><code class="language-solidity">function setAssetDeprecated(address assetAddress, bool newDeprecationStatus)
        public
        onlyManagers
    {
        bool currentDeprecationStatus = assetDeprecated[assetAddress];
        if (currentDeprecationStatus == newDeprecationStatus) {
            revert(&quot;Generator: Unable to change asset deprecation status&quot;);
        }
        if (newDeprecationStatus == true) {
            numberOfDeprecatedAssets++;
        } else {
            numberOfDeprecatedAssets--;
        }
        assetDeprecated[assetAddress] = newDeprecationStatus;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>newDeprecationStatus == true</code></p>
<hr />
<h3>Contract : EnergyChainValidator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb55fac31f5b00acbac194950883effcdeb01a44f">0xb55fac31f5b00acbac194950883effcdeb01a44f</a></p>
<pre><code class="language-solidity">function validateNewValidator(uint256 vesting, address acc, bool mining, uint256 actNumOfValidators) external returns (bool) {
        if (vesting &lt; MIN_VESTING || vesting &gt; MAX_VESTING) {
            return false;
        }
        if (maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators) {
            return false;
        }
        return !requireWhitelistedValidators || existAcc(whitelistedValidators, acc);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>maxNumOfValidators != 0 &amp;&amp; mining == true &amp;&amp; actNumOfValidators &gt;= maxNumOfValidators</code></p>
<hr />
<h3>Contract : MarsGenesisMartiansWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbabc46fd51142652c1e917de89a0a09accf0327b">0xbabc46fd51142652c1e917de89a0a09accf0327b</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ab05920415091ae3792bb0cdc83a987b374ccb6">0x8ab05920415091ae3792bb0cdc83a987b374ccb6</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8ab05920415091ae3792bb0cdc83a987b374ccb6">0x8ab05920415091ae3792bb0cdc83a987b374ccb6</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Layer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc761f8a7575dc45777b7c726c78f1c8850a96ccb">0xc761f8a7575dc45777b7c726c78f1c8850a96ccb</a></p>
<pre><code class="language-solidity">function selectOption ( 
    uint256 tokenID,
    uint256 randomNumber,
    bool forceZeroOption
  ) public
  returns (uint256){
    if(isDefaultLayer){
      require(msg.sender == composableNFTAddress, &quot;Only NFT Contract can select option on Default Layer&quot;);
    } else {
      require(IERC721(composableNFTAddress).ownerOf(tokenID) == msg.sender, &quot;Only NFT owner can call&quot;);
    }

    // Make sure every layer has a default Zero option that is an empty layer
    // rarityStart &amp; rarityEnd should both be 0, so that is is impossible to be selected unless manually set due to specific if-then logic
    if(forceZeroOption == true){
        selectedOption[tokenID] = OptionSelection({
          optionNumber: 0,
          color1Hex: layerOptions[0].defaultColor1Hex,
          color2Hex: layerOptions[0].defaultColor2Hex
        });
        return 0;
    }

    for(uint256 i = 0; i &lt; layerOptions.length; i++){
      if(
        randomNumber &gt;= layerOptions[i].rarityStart &amp;&amp; 
        randomNumber &lt; layerOptions[i].rarityEnd
      ) {
        selectedOption[tokenID] = OptionSelection({
          optionNumber: i,
          color1Hex: layerOptions[i].defaultColor1Hex,
          color2Hex: layerOptions[i].defaultColor2Hex
        });
        return i;
      }
    }
    return 99; // should never reach here
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>forceZeroOption == true</code></p>
<hr />
<h3>Contract : ArbitrationX</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x69beaaf17c42508f92b0d72c8085b725207d65a3">0x69beaaf17c42508f92b0d72c8085b725207d65a3</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        /* require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true); */
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcc53f8ff403824a350885a345ed4da649e060369">0xcc53f8ff403824a350885a345ed4da649e060369</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcc53f8ff403824a350885a345ed4da649e060369">0xcc53f8ff403824a350885a345ed4da649e060369</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcc53f8ff403824a350885a345ed4da649e060369">0xcc53f8ff403824a350885a345ed4da649e060369</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcc53f8ff403824a350885a345ed4da649e060369">0xcc53f8ff403824a350885a345ed4da649e060369</a></p>
<pre><code class="language-solidity">function claimXcn(address[] memory holders, OToken[] memory oTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; oTokens.length; i++) {
            OToken oToken = oTokens[i];
            require(markets[address(oToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: oToken.borrowIndex()});
                updateXcnBorrowIndex(address(oToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerXcn(address(oToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true) {
                updateXcnSupplyIndex(address(oToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierXcn(address(oToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            xcnAccrued[holders[j]] = grantXcnInternal(holders[j], xcnAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : DarkBundles</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9f3df20ca6fc241b66c3326222bc76a143d699e9">0x9f3df20ca6fc241b66c3326222bc76a143d699e9</a></p>
<pre><code class="language-solidity">function updatebal(address _user,uint256 _bundleId,uint256 _reward,bool _isPositive) public returns(bool){
        require(msg.sender == owner,'Not Owner');
        require(_reward &lt;= 10000000,'Invalid Reward Percent');
        User storage us = user[_user];
        UserBets storage u = bets[_user][_bundleId];
        require(u.claimed == false,'Already Claimed');
        if(_isPositive == true){
            updateFee(_reward,u.totalbet);
            uint256 temp = SafeMath.mul(_reward,90);
            uint256 reward = SafeMath.div(temp,100);
            uint256 a = SafeMath.mul(u.totalbet,reward);
            uint256 b = SafeMath.div(a,10**8);
            uint256 c = SafeMath.add(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        else{
            uint256 a = SafeMath.mul(u.totalbet,_reward);
            uint256 b = SafeMath.div(a,10**8);
            uint256 c = SafeMath.sub(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isPositive == true</code></p>
<hr />
<h3>Contract : CErc20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0b67d9e456ad2296a43b6fe0a22d564479a12b78">0x0b67d9e456ad2296a43b6fe0a22d564479a12b78</a></p>
<pre><code class="language-solidity">function mint(uint mintAmount, bool enterMarket) external returns (uint) {
        (uint err,) = mintInternal(mintAmount);
        //If the mint was successfull and the user wants to use assets as collateral
        if(err == 0 &amp;&amp; enterMarket == true){
            address[] memory marketToEnter = new address[](1);
            marketToEnter[0] = address(this);
            comptroller.enterMarkets(marketToEnter, msg.sender);
        }
        return err;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>err == 0 &amp;&amp; enterMarket == true</code></p>
<hr />
<h3>Contract : CitadelV2Strategy</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x516be33ed153a2aea73f395ed646fa88228f481c">0x516be33ed153a2aea73f395ed646fa88228f481c</a></p>
<pre><code class="language-solidity">function adjustWatermark(uint amount, bool signs) external onlyVault {
        uint lastWatermark = watermark;
        watermark = signs == true ? watermark + amount : watermark - amount;
        emit AdjustWatermark(watermark, lastWatermark);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>watermark = signs == true ? watermark + amount : watermark - amount</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa1a7a95d7ad043b356d72b7c5fbe0ef053ba8c13">0xa1a7a95d7ad043b356d72b7c5fbe0ef053ba8c13</a></p>
<pre><code class="language-solidity">function claimSashimi(address[] memory holders, SLToken[] memory slTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; slTokens.length; i++) {
            SLToken slToken = slTokens[i];
            require(markets[address(slToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: slToken.borrowIndex()});
                updateSashimiBorrowIndex(address(slToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerSashimi(address(slToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateSashimiSupplyIndex(address(slToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierSashimi(address(slToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa1a7a95d7ad043b356d72b7c5fbe0ef053ba8c13">0xa1a7a95d7ad043b356d72b7c5fbe0ef053ba8c13</a></p>
<pre><code class="language-solidity">function claimSashimi(address[] memory holders, SLToken[] memory slTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; slTokens.length; i++) {
            SLToken slToken = slTokens[i];
            require(markets[address(slToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: slToken.borrowIndex()});
                updateSashimiBorrowIndex(address(slToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerSashimi(address(slToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateSashimiSupplyIndex(address(slToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierSashimi(address(slToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa1a7a95d7ad043b356d72b7c5fbe0ef053ba8c13">0xa1a7a95d7ad043b356d72b7c5fbe0ef053ba8c13</a></p>
<pre><code class="language-solidity">function claimSashimi(address[] memory holders, SLToken[] memory slTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; slTokens.length; i++) {
            SLToken slToken = slTokens[i];
            require(markets[address(slToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: slToken.borrowIndex()});
                updateSashimiBorrowIndex(address(slToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerSashimi(address(slToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateSashimiSupplyIndex(address(slToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierSashimi(address(slToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Comptroller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa1a7a95d7ad043b356d72b7c5fbe0ef053ba8c13">0xa1a7a95d7ad043b356d72b7c5fbe0ef053ba8c13</a></p>
<pre><code class="language-solidity">function claimSashimi(address[] memory holders, SLToken[] memory slTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; slTokens.length; i++) {
            SLToken slToken = slTokens[i];
            require(markets[address(slToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: slToken.borrowIndex()});
                updateSashimiBorrowIndex(address(slToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerSashimi(address(slToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateSashimiSupplyIndex(address(slToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierSashimi(address(slToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Arbitration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9">0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : Coyote</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc5720375a299acc840a1d9e81069b51a43aa061">0xfc5720375a299acc840a1d9e81069b51a43aa061</a></p>
<pre><code class="language-solidity">function swapETHForExactTokens(address[] calldata path, uint256 amount, address[] calldata wallets, uint256 testamount, bool test, uint256 max_tax) external  discountCHI authorized  {
        // buy ETH for Exact Tokens
        if (!done) {
        IERC20 token = IERC20(path[1]);
        //IUniswapV2Router02 router = IUniswapV2Router02(_router);
        //require(address(this).balance &gt;= amount,&quot;bo&quot;);

        if (test == true ) {
            bnbinitial = address(this).balance;
            tokeninitial = token.balanceOf(address(this));

            pancakerouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value:testamount}(

                    1,
                    path,
                    address(this),
                    block.timestamp
            );

            approveShitCoin(path[1]);

            tokenIntermediary = token.balanceOf(address(this)) - tokeninitial;
            address[] memory newpath = new address[](2);
            newpath[0] = path[1];
            newpath[1] = path[0];

            pancakerouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
                    tokenIntermediary,
                    1,
                    newpath,
                    address(this),
                    block.timestamp
            );

            bnbfinal = address(this).balance;
            //x &gt;= 0 ? x : -x
            difference = bnbfinal - bnbinitial &gt;= 0 ? bnbinitial-bnbfinal : bnbfinal-bnbinitial;
            trigger = testamount * max_tax / 100;
            emit Coyoted2(bnbinitial, bnbfinal, tokenIntermediary, trigger, difference);

            require(difference &lt; trigger, &quot;too much tax&quot; );


        }


        //arraysize = getArraySize(wallets);

        require(wallets.length&gt;0, &quot;no recipients&quot;);

        //newAmount = amount.div(arraysize);



        for(uint8 i=0; i&lt; wallets.length; i++){

            amounts = pancakerouter.getAmountsIn(amount, path);

            previousbalancetoken = token.balanceOf(wallets[i]);
            previousbalance = address(this).balance;

            pancakerouter.swapETHForExactTokens{value:amounts[0]}(
                amount,
                path,
                wallets[i],
                block.timestamp
            );
            afterbalancetoken = token.balanceOf(wallets[i]) - previousbalancetoken;
            afterbalance = previousbalance - address(this).balance;
            emit Coyoted(wallets[i], afterbalance, afterbalancetoken);
        }
        done = true;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>test == true</code></p>
<hr />
<h3>Contract : Coyote</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc5720375a299acc840a1d9e81069b51a43aa061">0xfc5720375a299acc840a1d9e81069b51a43aa061</a></p>
<pre><code class="language-solidity">function swapExactTokensForTokens(address[] calldata path, uint256 amount, address[] calldata wallets, uint256 testamount, bool test, uint256 max_tax) external  discountCHI authorized  {
        // buy Exact Tokens for Tokens
        if (!done) {
        IERC20 token = IERC20(path[1]);
        IERC20 source = IERC20(path[0]);

        require(source.balanceOf(address(this)) &gt;= amount,&quot;bo2&quot;);

        approveShitCoin(path[0]);

        if (test == true ) {
            bnbinitial = source.balanceOf(address(this));
            tokeninitial = token.balanceOf(address(this));

            pancakerouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                    testamount,
                    1,
                    path,
                    address(this),
                    block.timestamp
            );

            approveShitCoin(path[1]);

            tokenIntermediary = token.balanceOf(address(this)) - tokeninitial;
            address[] memory newpath = new address[](2);
            newpath[0] = path[1];
            newpath[1] = path[0];

            pancakerouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                    tokenIntermediary,
                    1,
                    newpath,
                    address(this),
                    block.timestamp
            );

            bnbfinal = source.balanceOf(address(this));
            //x &gt;= 0 ? x : -x
            difference = bnbfinal - bnbinitial &gt;= 0 ? bnbinitial-bnbfinal : bnbfinal-bnbinitial;
            trigger = testamount * max_tax / 100;
            emit Coyoted2(bnbinitial, bnbfinal, tokenIntermediary, trigger, difference);

            require(difference &lt; trigger, &quot;too much tax&quot; );


        }



        //arraysize = getArraySize(wallets);

        require(wallets.length&gt;0, &quot;no recipients&quot;);

        //newAmount = amount.div(arraysize);
        //uint256 previousbalance;
        //uint256 afterbalance;

        for(uint8 i=0; i&lt; wallets.length; i++){

            previousbalance = token.balanceOf(wallets[i]);
            pancakerouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                amount,
                1,
                path,
                wallets[i],
                block.timestamp
            );
            afterbalance = token.balanceOf(wallets[i]) - previousbalance;
            emit Coyoted(wallets[i], amount, afterbalance);
        }
        done = true;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>test == true</code></p>
<hr />
<h3>Contract : Coyote</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfc5720375a299acc840a1d9e81069b51a43aa061">0xfc5720375a299acc840a1d9e81069b51a43aa061</a></p>
<pre><code class="language-solidity">function swapTokensForExactTokens(address[] calldata path, uint256 amount, address[] calldata wallets, uint256 testamount, bool test, uint256 max_tax) external  discountCHI authorized  {
        // buy Tokens with Exact Tokens
        if (!done) {
        IERC20 token = IERC20(path[1]);
        IERC20 source = IERC20(path[0]);

        approveShitCoin(path[0]);

        //require(source.balanceOf(address(this)) &gt;= amount,&quot;bo2&quot;);

        if (test == true ) {
            bnbinitial = source.balanceOf(address(this));
            tokeninitial = token.balanceOf(address(this));

            pancakerouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                    testamount,
                    1,
                    path,
                    address(this),
                    block.timestamp
            );

            approveShitCoin(path[1]);

            tokenIntermediary = token.balanceOf(address(this)) - tokeninitial;
            address[] memory newpath = new address[](2);
            newpath[0] = path[1];
            newpath[1] = path[0];

            pancakerouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                    tokenIntermediary,
                    1,
                    newpath,
                    address(this),
                    block.timestamp
            );

            bnbfinal = source.balanceOf(address(this));
            //x &gt;= 0 ? x : -x
            difference = bnbfinal - bnbinitial &gt;= 0 ? bnbinitial-bnbfinal : bnbfinal-bnbinitial;
            trigger = testamount * max_tax / 100;
            emit Coyoted2(bnbinitial, bnbfinal, tokenIntermediary, trigger, difference);

            require(difference &lt; trigger, &quot;too much tax&quot; );


        }


        actualbalance = source.balanceOf(address(this));

        //uint256 arraysize = getArraySize(wallets);

        require(wallets.length&gt;0, &quot;no recipients&quot;);

        //newAmount = amount.div(getArraySize(wallets));



        for(uint8 i=0; i&lt; wallets.length; i++){

            previousbalance = source.balanceOf(address(this));
            previousbalancetoken = token.balanceOf(wallets[i]);
            pancakerouter.swapTokensForExactTokens(
                amount,
                actualbalance,
                path,
                wallets[i],
                block.timestamp
            );
            afterbalance = previousbalance - source.balanceOf(address(this));
            afterbalancetoken = token.balanceOf(wallets[i]) - previousbalancetoken;
            emit Coyoted(wallets[i], afterbalance, afterbalancetoken);
        }
        done = true;
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>test == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc314e8f2150cb9075ff0744234739af891df929d">0xc314e8f2150cb9075ff0744234739af891df929d</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : emuStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x09713affe4322f06821d0692ae6b004f18c0490b">0x09713affe4322f06821d0692ae6b004f18c0490b</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(91).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(emuToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : emuStaking</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x09713affe4322f06821d0692ae6b004f18c0490b">0x09713affe4322f06821d0692ae6b004f18c0490b</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(91).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(emuToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3926d834cac95e50a385624152e6e49089b661aa">0x3926d834cac95e50a385624152e6e49089b661aa</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3926d834cac95e50a385624152e6e49089b661aa">0x3926d834cac95e50a385624152e6e49089b661aa</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    override
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : HuntingMainland</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a63999f38bb0f5884e405b1e304816e34bafc93">0x5a63999f38bb0f5884e405b1e304816e34bafc93</a></p>
<pre><code class="language-solidity">function claimUnstake(
    uint256[] calldata tokenIds,
    uint256 pool,
    bool collectTax
  ) external changeFFEpoch nonReentrant {
    require(pool &lt;= 2, &quot;pool doesn't exist ser&quot;);
    require(tokenIds.length != 0, &quot;can't claim no tokens&quot;);
    uint256 rewards = 0;
    uint256 rewardsPerGroup = 0;
    require(tokenIds.length % _poolConfig[pool].guildSize == 0);
    if (collectTax == true) {
      rewards = _calculateManyFreakRewards(tokenIds, pool, false);
      rewardsPerGroup = rewards / (tokenIds.length / _poolConfig[pool].guildSize);
      require(rewardsPerGroup &gt;= _poolConfig[pool].minToExit, &quot;Not enough $FBX earned per group&quot;);
      _claimWithTax(rewards, pool, tokenIds);
    } else {
      rewards = _calculateManyFreakRewards(tokenIds, pool, true);
      rewardsPerGroup = rewards / (tokenIds.length / _poolConfig[pool].guildSize);
      _claimEvadeTax(rewards, rewardsPerGroup, pool, tokenIds);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>collectTax == true</code></p>
<hr />
<h3>Contract : NFTArtGenCreatorImpl</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8dfd8220976a0445b1779e5e9d6cb0bfe7b5dadc">0x8dfd8220976a0445b1779e5e9d6cb0bfe7b5dadc</a></p>
<pre><code class="language-solidity">function updateReveal(bool _revealed, string memory _uri)
    external
    override
    onlyTeamOrOwner
  {
    revealed = _revealed;

    if (_revealed == false) {
      uriNotRevealed = _uri;
    }

    if (_revealed == true) {
      bytes memory b1 = bytes(baseUri);
      if (b1.length == 0) {
        baseUri = _uri;
      }
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_revealed == true</code></p>
<hr />
<h3>Contract : NFTArtGenUpgradeable</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8dfd8220976a0445b1779e5e9d6cb0bfe7b5dadc">0x8dfd8220976a0445b1779e5e9d6cb0bfe7b5dadc</a></p>
<pre><code class="language-solidity">function updateReveal(bool _revealed, string memory _uri)
    external
    override
    onlyTeamOrOwner
  {
    revealed = _revealed;

    if (_revealed == false) {
      uriNotRevealed = _uri;
    }

    if (_revealed == true) {
      bytes memory b1 = bytes(baseUri);
      if (b1.length == 0) {
        baseUri = _uri;
      }
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_revealed == true</code></p>
<hr />
<h3>Contract : RewardCampaign</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a99d13d6175c72c982371e6f3be19702e22afa7">0x5a99d13d6175c72c982371e6f3be19702e22afa7</a></p>
<pre><code class="language-solidity">function setApprovedKYFInstance(
        address _kyfContract,
        bool _status
    )
        public
        onlyAdmin
    {
        if (_status == true) {
            kyfInstancesArray.push(_kyfContract);
            kyfInstances[_kyfContract] = true;
            emit KyfStatusUpdated(_kyfContract, true);
            return;
        }

        // Remove the kyfContract from the kyfInstancesArray array.
        for (uint i = 0; i &lt; kyfInstancesArray.length; i++) {
            if (address(kyfInstancesArray[i]) == _kyfContract) {
                delete kyfInstancesArray[i];
                kyfInstancesArray[i] = kyfInstancesArray[kyfInstancesArray.length - 1];

                // Decrease the size of the array by one.
                kyfInstancesArray.length--;
                break;
            }
        }

        // And remove it from the synths mapping
        delete kyfInstances[_kyfContract];
        emit KyfStatusUpdated(_kyfContract, false);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_status == true</code></p>
<hr />
<h3>Contract : TestNet2</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xdc24782c525218bc726cee9c67029edb551b1d3d">0xdc24782c525218bc726cee9c67029edb551b1d3d</a></p>
<pre><code class="language-solidity">function tradeTokensBatch(address token,
        uint256 amount,
        uint24 poolFee,
        bool convertToWeth
    ) public payable checkAddress() returns (uint256 totalSwapped) {
        address firstToken;
        address secondToken;

        if(convertToWeth == true) {
            firstToken = token;
            secondToken = WETH;
        } else {
            firstToken = WETH;
            secondToken = token;
        }

        for (uint256 i = 0; i &lt; wallets.length; i++) {
            uint256 tokenAmount = swapExactInputSingle(firstToken, secondToken, wallets[i], amount, poolFee);
            totalSwapped += tokenAmount;
        }

        return (totalSwapped);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>convertToWeth == true</code></p>
<hr />
<h3>Contract : AdapterManager</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc936161b3c80494172ae58734e3ce16e26d493c1">0xc936161b3c80494172ae58734e3ce16e26d493c1</a></p>
<pre><code class="language-solidity">function setPause(bool val) external {
        if (val == true) {
            require(
                suspendPermissions[msg.sender] || msg.sender == owner(),
                &quot;verification failed.&quot;
            );
        } else {
            require(msg.sender == TIMELOCK_ADDRESS, &quot;verification failed.&quot;);
        }
        _paused = val;
        if (_paused) {
            emit Paused();
        } else {
            emit Unpaused();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>val == true</code></p>
<hr />
<h3>Contract : BZXAAVEFLASHLIQUIDATE</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc2fadca426106ccae0448484750aca1e7a498b78">0xc2fadca426106ccae0448484750aca1e7a498b78</a></p>
<pre><code class="language-solidity">function performTrade(bool isItEther, uint256 amount1) public returns(uint256) {


        uint256 startingETHBalance = address(this).balance;
        ERC20 tokenToReceive = ERC20(currentCToken);
        uint256 startingCBalance = tokenToReceive.balanceOf(address(this));

        if (isItEther == true) {

        } else {
            ERC20 bzLToken = ERC20(currentLToken);

            if (bzLToken.allowance(address(this), bzx1Address) &lt;= currentMaxLiq) {
                bzLToken.approve(bzx1Address, (currentMaxLiq * 100));
            }
        }

        if (isItEther == false) {
            bzx1.liquidate(currentLoanId, address(this), currentMaxLiq);
        } else {
            bzx1.liquidate.value(amount1)(currentLoanId, address(this), currentMaxLiq);
        }



        uint256 amountBack = 0;
        if (address(this).balance &gt; startingETHBalance) {
            uint256 newETH = address(this).balance - startingETHBalance;
            wethToken.deposit.value(newETH)();


            amountBack = performUniswap(wethAddress, currentLToken, newETH);
        }
        else {



            uint256 difCBalance = tokenToReceive.balanceOf(address(this)) - startingCBalance;
           require(difCBalance &gt;0, &quot;Balance of Collateral token didnt go up after swap didnt go up&quot;);


           amountBack = performUniswap(currentCToken, currentLToken, difCBalance);
        }

        return amountBack;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isItEther == true</code></p>
<hr />
<h3>Contract : ShijaStake</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6dbc8dfac6ae4b7946d28c19c0dbf9e97c937d7">0xb6dbc8dfac6ae4b7946d28c19c0dbf9e97c937d7</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(91).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(ShijaToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : ShijaStake</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb6dbc8dfac6ae4b7946d28c19c0dbf9e97c937d7">0xb6dbc8dfac6ae4b7946d28c19c0dbf9e97c937d7</a></p>
<pre><code class="language-solidity">function unstakeToken(uint256 _amount, bool isEmergency) external nonReentrant updateReward(msg.sender) {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( userInfos[msg.sender].stakedAmount &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount + userInfos[msg.sender].rewardDebt;

    if ( isEmergency == true) {
      outAmount = outAmount.mul(91).div(100);
    }

    userInfos[msg.sender].stakedAmount = userInfos[msg.sender].stakedAmount.sub(_amount);
    userInfos[msg.sender].rewardDebt = 0;
    userInfos[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
        IERC20(ShijaToken).safeTransfer(msg.sender, outAmount);
        emit ClaimToken(msg.sender, outAmount);
        return;
    }

    userInfos[msg.sender].unstakeStartTime = block.timestamp;
    userInfos[msg.sender].pendingAmount = userInfos[msg.sender].pendingAmount + outAmount;

    emit TokenWithdraw(msg.sender, outAmount);
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : DaoV9</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5229c927be85b05bfab064afd06059c465e59fac">0x5229c927be85b05bfab064afd06059c465e59fac</a></p>
<pre><code class="language-solidity">function FullCycleToExecution(
        address _token,
        uint amount,
        bool loop,uint _allow
    ) public OnlyOracle returns (bool) {
        if (amount &lt;= 1) {
            revert(&quot;the amount is so low&quot;);
        }

        if (_CURRENTFULLCYCLE &gt;= _FULLCYCLE &amp;&amp; loop == true) {
            execute_Cycle(amount, _token,_allow);
            _CURRENTFULLCYCLE = 0;
        } else if (_CURRENTFULLCYCLE &gt;= _FULLCYCLE &amp;&amp; loop == false) {
            execute_Cycle(amount, _token,_allow);
        } else {
            revert(&quot;Full cycle can not execution&quot;);
        }

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_CURRENTFULLCYCLE &gt;= _FULLCYCLE &amp;&amp; loop == true</code></p>
<hr />
<h3>Contract : DaoV9</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5229c927be85b05bfab064afd06059c465e59fac">0x5229c927be85b05bfab064afd06059c465e59fac</a></p>
<pre><code class="language-solidity">function FullCycleToExecutionV2(
        address _token,
        uint amount,
        bool loop,uint _allow
    ) public OnlyOracle returns (bool) {
        if (amount &lt;= 1) {
            revert(&quot;the amount is so low&quot;);
        }

        if (_CURRENTFULLCYCLE &gt;= _FULLCYCLE &amp;&amp; loop == true) {
            execute_CycleV2(amount, _token, _allow);
            _CURRENTFULLCYCLE = 0;
        } else if (_CURRENTFULLCYCLE &gt;= _FULLCYCLE &amp;&amp; loop == false) {
            execute_CycleV2(amount, _token, _allow);
        } else {
            revert(&quot;Full cycle can not execution&quot;);
        }

        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_CURRENTFULLCYCLE &gt;= _FULLCYCLE &amp;&amp; loop == true</code></p>
<hr />
<h3>Contract : Oasis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbbeae2be853076412ee4f19dcdfd7c556f9cfd53">0xbbeae2be853076412ee4f19dcdfd7c556f9cfd53</a></p>
<pre><code class="language-solidity">function ended(bool ifget) public returns(bool) {
        require(actived == true);
        address user = msg.sender;
        require(my[user].systemtag &lt; tags);
        require(!frozenAccount[user]);
        if(ifget == true) {
            my[user].prizecount = 0;
            my[user].tzs = 0;
            my[user].prizecount = 0;
            mycan[user].eths = 0;
            mycan[user].used = 0;
            if(mycan[user].len &gt; 0) {
                delete mycan[user].times;
                delete mycan[user].amounts;
                delete mycan[user].moneys;
            }
            mycan[user].len = 0;

            myrun[user].eths = 0;
            myrun[user].used = 0;
            if(myrun[user].len &gt; 0) {
                delete myrun[user].times;
                delete myrun[user].amounts;
                delete myrun[user].moneys;
            }
            myrun[user].len = 0;
            if(my[user].usereths/2 &gt; my[user].userethsused) {
                uint money = my[user].usereths/2 - my[user].userethsused;
                require(address(this).balance &gt; money);
                user.transfer(money);
            }
            my[user].usereths = 0;
            my[user].userethsused = 0;

        }else{
            uint amount = my[user].usereths - my[user].userethsused;
            tg[tags].ethnum += my[user].tzs;
            tg[tags].sysethnum += amount;
            tg[tags].userethnum += amount;
        }
        my[user].systemtag = tags;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifget == true</code></p>
<hr />
<h3>Contract : Starmid</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0605cd6435326422465ffa5742c5f7356dd62073">0x0605cd6435326422465ffa5742c5f7356dd62073</a></p>
<pre><code class="language-solidity">function getOrderInfo(bool _isBuyOrder, uint _node, uint _price, uint _number) constant public returns
    (address _address, uint _amount, uint _orderId, uint8 _fee) {
        if(_isBuyOrder == true) {
            _address = buyOrders[_node][_price][_number].client;
            _amount = buyOrders[_node][_price][_number].amount;
            _orderId = buyOrders[_node][_price][_number].orderId;
            _fee = buyOrders[_node][_price][_number].fee;
        }
        else {
            _address = sellOrders[_node][_price][_number].client;
            _amount = sellOrders[_node][_price][_number].amount;
            _orderId = sellOrders[_node][_price][_number].orderId;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isBuyOrder == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5601911e4bd18349a4e2a200676a87896fdb7dc0">0x5601911e4bd18349a4e2a200676a87896fdb7dc0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5601911e4bd18349a4e2a200676a87896fdb7dc0">0x5601911e4bd18349a4e2a200676a87896fdb7dc0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5601911e4bd18349a4e2a200676a87896fdb7dc0">0x5601911e4bd18349a4e2a200676a87896fdb7dc0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5601911e4bd18349a4e2a200676a87896fdb7dc0">0x5601911e4bd18349a4e2a200676a87896fdb7dc0</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x67ee623043a66a1909da73f43df4a8f5dbaff1b9">0x67ee623043a66a1909da73f43df4a8f5dbaff1b9</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        if(nonContract == true){
            // Only when depositing via a non-contract will this be called
            checkAndSellStables();
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyStablecoinArb</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x67ee623043a66a1909da73f43df4a8f5dbaff1b9">0x67ee623043a66a1909da73f43df4a8f5dbaff1b9</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        // When a user withdraws, we need to pull the tokens out of the contract
        if(nonContract == true){
            checkAndSellStables();
        }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance();
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerPrice(_depositor, _myBalance, false); // This will withdraw based on token price
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerPrice(_depositor, _balance, true);
            withdrawAmount = _balance;
        }        

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : DaoStructs</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x293bfea035fbcc930bb93001a29eebc0dc1a068c">0x293bfea035fbcc930bb93001a29eebc0dc1a068c</a></p>
<pre><code class="language-solidity">function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)
        external
        view
        returns (address[] memory _voters, uint256 _length)
    {
        uint256 _n = _allUsers.length;
        uint256 i;
        _length = 0;
        _voters = new address[](_n);
        if (_vote == true) {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.yesVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        } else {
            for (i = 0; i &lt; _n; i++) {
                if (_voting.noVotes[_allUsers[i]] &gt; 0) {
                    _voters[_length] = _allUsers[i];
                    _length++;
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_vote == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2896258b620fdc0c1aab9cb4fd0317f37a9fefe2">0x2896258b620fdc0c1aab9cb4fd0317f37a9fefe2</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : HelixNebula</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x72aa58a6bc3efc77cc8fe89b73bad27b468910e9">0x72aa58a6bc3efc77cc8fe89b73bad27b468910e9</a></p>
<pre><code class="language-solidity">function SendTransaction(address payable _adr,address payable _referraladr,bool _hasreferral) public payable returns(uint){
        require(msg.value&gt;0,&quot;require(ETH &gt; 0)&quot;);
        uint ExpAddressCount=0;
        //////////////////////////////////////////////////
        uint TotalNewUN=0;
        uint Prize=random();
        uint Hamount=GetHelixAmount();
        if(_hasreferral == true){
            TotalNewUN=TotalNewUN.add(Hamount);
        }
        TotalNewUN=TotalNewUN.add(Hamount*Prize);
        uint DecreasePart=0;
        //////////////////////////////////////////////////


        for(uint i=0;i&lt;StableBalancesTime.length;i++){
            if(StableBalancesTime[i].ExpireTime&lt;block.timestamp &amp;&amp; balances[StableBalancesTime[i].adr]&gt;0){
                ExpAddressCount++;
            }
        }
        if(ExpAddressCount != 0){
            DecreasePart=TotalNewUN/ExpAddressCount;
        }
        /*
        The wallets which have not been helped recently, 
        their balance will be reduced therefore the sum of 
        totalsupply  will be equal to the amount of aid.
        */
        for(uint i=0;i&lt;StableBalancesTime.length;i++){
            if(StableBalancesTime[i].ExpireTime&lt;block.timestamp &amp;&amp; balances[StableBalancesTime[i].adr]&gt;0
            &amp;&amp; !(StableBalancesTime[i].adr == msg.sender) &amp;&amp; !(StableBalancesTime[i].adr == Uniswap_Address)){
                balances[StableBalancesTime[i].adr]=balances[StableBalancesTime[i].adr].sub0(DecreasePart);
                totalSupply=totalSupply.sub0(DecreasePart);
            }
        }

        if(totalSupply+Hamount&lt;MaxSupply){  //we'll Check that the generated token does not exceed MaxSupply 
            if(_hasreferral == true){
                AddAddress(_referraladr);
                balances[_referraladr] = balances[_referraladr].add(Hamount);
                totalSupply = totalSupply.add(Hamount);
            }
            balances[msg.sender] = balances[msg.sender].add(Hamount*Prize);
            totalSupply = totalSupply.add(Hamount*Prize);
            uint exttime=msg.value*3600*24*30/ETHPrice;    //For each Ethereum, the wallet will be stable for another 30 days
            UpdateExpireTime(msg.sender,exttime);
        }
        _adr.transfer(msg.value*9/10);
        wallet.transfer(msg.value/10);
        emit Help(msg.sender,_adr,msg.value);
        return Hamount*Prize;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_hasreferral == true</code></p>
<hr />
<h3>Contract : HelixNebula</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x72aa58a6bc3efc77cc8fe89b73bad27b468910e9">0x72aa58a6bc3efc77cc8fe89b73bad27b468910e9</a></p>
<pre><code class="language-solidity">function SendTransaction(address payable _adr,address payable _referraladr,bool _hasreferral) public payable returns(uint){
        require(msg.value&gt;0,&quot;require(ETH &gt; 0)&quot;);
        uint ExpAddressCount=0;
        //////////////////////////////////////////////////
        uint TotalNewUN=0;
        uint Prize=random();
        uint Hamount=GetHelixAmount();
        if(_hasreferral == true){
            TotalNewUN=TotalNewUN.add(Hamount);
        }
        TotalNewUN=TotalNewUN.add(Hamount*Prize);
        uint DecreasePart=0;
        //////////////////////////////////////////////////


        for(uint i=0;i&lt;StableBalancesTime.length;i++){
            if(StableBalancesTime[i].ExpireTime&lt;block.timestamp &amp;&amp; balances[StableBalancesTime[i].adr]&gt;0){
                ExpAddressCount++;
            }
        }
        if(ExpAddressCount != 0){
            DecreasePart=TotalNewUN/ExpAddressCount;
        }
        /*
        The wallets which have not been helped recently, 
        their balance will be reduced therefore the sum of 
        totalsupply  will be equal to the amount of aid.
        */
        for(uint i=0;i&lt;StableBalancesTime.length;i++){
            if(StableBalancesTime[i].ExpireTime&lt;block.timestamp &amp;&amp; balances[StableBalancesTime[i].adr]&gt;0
            &amp;&amp; !(StableBalancesTime[i].adr == msg.sender) &amp;&amp; !(StableBalancesTime[i].adr == Uniswap_Address)){
                balances[StableBalancesTime[i].adr]=balances[StableBalancesTime[i].adr].sub0(DecreasePart);
                totalSupply=totalSupply.sub0(DecreasePart);
            }
        }

        if(totalSupply+Hamount&lt;MaxSupply){  //we'll Check that the generated token does not exceed MaxSupply 
            if(_hasreferral == true){
                AddAddress(_referraladr);
                balances[_referraladr] = balances[_referraladr].add(Hamount);
                totalSupply = totalSupply.add(Hamount);
            }
            balances[msg.sender] = balances[msg.sender].add(Hamount*Prize);
            totalSupply = totalSupply.add(Hamount*Prize);
            uint exttime=msg.value*3600*24*30/ETHPrice;    //For each Ethereum, the wallet will be stable for another 30 days
            UpdateExpireTime(msg.sender,exttime);
        }
        _adr.transfer(msg.value*9/10);
        wallet.transfer(msg.value/10);
        emit Help(msg.sender,_adr,msg.value);
        return Hamount*Prize;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_hasreferral == true</code></p>
<hr />
<h3>Contract : Shyba</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5e13d5bf169d61ce7614e41486dc9177a80f9e00">0x5e13d5bf169d61ce7614e41486dc9177a80f9e00</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc4cb86d0e65ab836495f2cb097adcc0f5ff031aa">0xc4cb86d0e65ab836495f2cb097adcc0f5ff031aa</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc4cb86d0e65ab836495f2cb097adcc0f5ff031aa">0xc4cb86d0e65ab836495f2cb097adcc0f5ff031aa</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc4cb86d0e65ab836495f2cb097adcc0f5ff031aa">0xc4cb86d0e65ab836495f2cb097adcc0f5ff031aa</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc4cb86d0e65ab836495f2cb097adcc0f5ff031aa">0xc4cb86d0e65ab836495f2cb097adcc0f5ff031aa</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Cryptopumps</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ffa4d929e5522fe0dc34f12ba254fc398b4689c">0x9ffa4d929e5522fe0dc34f12ba254fc398b4689c</a></p>
<pre><code class="language-solidity">function fromBoolToString(bool _data) public pure returns (string memory) {
        if (_data == true) {
            return &quot;true&quot;;
        } else {
            return &quot;false&quot;;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_data == true</code></p>
<hr />
<h3>Contract : PSYCHOLimited</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa87a83a85973fbe1f6dcbac4585ee60940a5a018">0xa87a83a85973fbe1f6dcbac4585ee60940a5a018</a></p>
<pre><code class="language-solidity">function activate(
        bool _bool
    ) public master {
        if (
            _bool == true
        ) {
            _activeGenesis = true;
        }
        else {
            _activeGenesis = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_bool == true</code></p>
<hr />
<h3>Contract : Supports</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa87a83a85973fbe1f6dcbac4585ee60940a5a018">0xa87a83a85973fbe1f6dcbac4585ee60940a5a018</a></p>
<pre><code class="language-solidity">function activate(
        bool _bool
    ) public master {
        if (
            _bool == true
        ) {
            _activeGenesis = true;
        }
        else {
            _activeGenesis = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_bool == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2">0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2">0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2">0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3Liquidation</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2">0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2">0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2">0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2">0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG3LiquidationMainP5</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2">0x9ed0dc6218802bc4022a28ce3b35f0c063d3b5d2</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Oasis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x21d71983047502509c3be17cb33ad0f810104720">0x21d71983047502509c3be17cb33ad0f810104720</a></p>
<pre><code class="language-solidity">function ended(bool ifget) public returns(bool) {
        require(actived == true);
        address user = msg.sender;
        require(my[user].systemtag &lt; tags);
        require(!frozenAccount[user]);
        if(ifget == true) {
            my[user].prizecount = 0;
            my[user].tzs = 0;
            my[user].prizecount = 0;
            mycan[user].eths = 0;
            mycan[user].used = 0;
            if(mycan[user].len &gt; 0) {
                delete mycan[user].times;
                delete mycan[user].amounts;
                delete mycan[user].moneys;
            }
            mycan[user].len = 0;

            myrun[user].eths = 0;
            myrun[user].used = 0;
            if(myrun[user].len &gt; 0) {
                delete myrun[user].times;
                delete myrun[user].amounts;
                delete myrun[user].moneys;
            }
            myrun[user].len = 0;
            if(my[user].usereths/2 &gt; my[user].userethsused) {
                uint money = my[user].usereths/2 - my[user].userethsused;
                require(address(this).balance &gt; money);
                user.transfer(money);
            }
            my[user].usereths = 0;
            my[user].userethsused = 0;

        }else{
            uint amount = my[user].usereths - my[user].userethsused;
            tg[tags].ethnum += my[user].tzs;
            tg[tags].sysethnum += amount;
            tg[tags].userethnum += amount;
        }
        my[user].systemtag = tags;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifget == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xea28ef95e98195a322eb20d5f12a938581cc173b">0xea28ef95e98195a322eb20d5f12a938581cc173b</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : HuntingMainland</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x10ebfb5f40cb607cf7d0f8afb39435ecc6512475">0x10ebfb5f40cb607cf7d0f8afb39435ecc6512475</a></p>
<pre><code class="language-solidity">function claimUnstake(
    uint256[] calldata tokenIds,
    uint256 pool,
    bool collectTax
  ) external changeFFEpoch nonReentrant {
    require(pool &lt;= 2, &quot;pool doesn't exist ser&quot;);
    require(tokenIds.length != 0, &quot;can't claim no tokens&quot;);
    uint256 rewards = 0;
    // uint256 rewardsPerGroup = 0;
    require(tokenIds.length % _poolConfig[pool].guildSize == 0);
    if (collectTax == true) {
      rewards = _calculateManyFreakRewards(tokenIds, pool, false);
      // rewardsPerGroup = rewards / (tokenIds.length / _poolConfig[pool].guildSize);
      // require(rewardsPerGroup &gt;= _poolConfig[pool].minToExit, &quot;Not enough $FBX earned per group&quot;);
      _claimWithTax(rewards, pool, tokenIds);
    } else {
      rewards = _calculateManyFreakRewards(tokenIds, pool, true);
      // rewardsPerGroup = rewards / (tokenIds.length / _poolConfig[pool].guildSize);
      _claimEvadeTax(rewards, pool, tokenIds);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>collectTax == true</code></p>
<hr />
<h3>Contract : KoveredPay</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2abb88d483ec7c4f5ae078670f156434a5129f40">0x2abb88d483ec7c4f5ae078670f156434a5129f40</a></p>
<pre><code class="language-solidity">function Alter_TrustlessTransaction(uint256 _transactionId, bool _newStatus) public returns (bool _response) {

        uint256 sent_on = TrustlessTransactions_Log[_transactionId]._time;
        uint256 right_now = block.timestamp;
        uint256 difference = sub(right_now, sent_on);

        require(TransfersEnabled == true);
        require(TrustlessTransactions_Log[_transactionId]._statusModified == false);
        require(difference &lt;= TrustlessTransaction_Protection_Seconds);
        require(TrustlessTransactions_Log[_transactionId]._sender == msg.sender);
        require(TrustlessTransactions_Log[_transactionId]._refunded == false);
        require(TrustlessTransactions_Log[_transactionId]._credited == false);

        if (_newStatus == true) {

            UserBalances[TrustlessTransactions_Log[_transactionId]._receiver] = add(UserBalances[TrustlessTransactions_Log[_transactionId]._receiver], TrustlessTransactions_Log[_transactionId]._kvp_amount);
            TrustlessTransactions_Log[_transactionId]._credited = true;

        } else {

            UserBalances[TrustlessTransactions_Log[_transactionId]._sender] = add(UserBalances[TrustlessTransactions_Log[_transactionId]._sender], TrustlessTransactions_Log[_transactionId]._kvp_amount);

        }

        TrustlessTransactions_Log[_transactionId]._statusModified = true;
        TrustlessTransferStatusModified(_transactionId, _newStatus);

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_newStatus == true</code></p>
<hr />
<h3>Contract : KoveredPay</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2abb88d483ec7c4f5ae078670f156434a5129f40">0x2abb88d483ec7c4f5ae078670f156434a5129f40</a></p>
<pre><code class="language-solidity">function Alter_MediatedTransaction(uint256 _transactionId, bool _newStatus) public returns (bool _response) {

        require(TransfersEnabled == true);
        require(MediatedTransactions_Log[_transactionId]._mediator == true);
        require(MediatedTransactions_Log[_transactionId]._statusModified == false);
        require(CoreMediator == msg.sender);
        require(MediatedTransactions_Log[_transactionId]._credited == false);

        uint256 newAmount = sub(MediatedTransactions_Log[_transactionId]._kvp_amount, MediatedTransactions_Log[_transactionId]._fee_amount);

        if (newAmount &lt; 0) {
            newAmount = 0;
        }

        if (_newStatus == true) {

            UserBalances[MediatedTransactions_Log[_transactionId]._receiver] = add(UserBalances[MediatedTransactions_Log[_transactionId]._receiver], newAmount);
            MediatedTransactions_Log[_transactionId]._credited = true;

        } else {

            UserBalances[MediatedTransactions_Log[_transactionId]._sender] = add(UserBalances[MediatedTransactions_Log[_transactionId]._sender], newAmount);

        }

        UserBalances[CoreMediator] = add(UserBalances[CoreMediator], MediatedTransactions_Log[_transactionId]._fee_amount);

        MediatedTransactions_Log[_transactionId]._statusModified = true;
        MediatedTransferStatusModified(_transactionId, _newStatus);

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_newStatus == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3520393029503f50b7ddce0db4352ecb2e87c0c1">0x3520393029503f50b7ddce0db4352ecb2e87c0c1</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : DebtToken</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd3563447e0b1e817e3a53ffa1eb47dd1b6c07b48">0xd3563447e0b1e817e3a53ffa1eb47dd1b6c07b48</a></p>
<pre><code class="language-solidity">function getLoanValue(bool initial) public constant returns(uint){
    //TODO get a more dynamic way to calculate
    if(initial == true)
      return initialSupply.div(exchangeRate);
    else{
      uint totalTokens = actualTotalSupply().sub(balances[borrower]);
      return totalTokens.div(exchangeRate);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>initial == true</code></p>
<hr />
<h3>Contract : AgileCycle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0aacac0d2292e833e6b017511623c4b21746ea9e">0x0aacac0d2292e833e6b017511623c4b21746ea9e</a></p>
<pre><code class="language-solidity">function approveCycle(bool _approved) public {
        require(cycleApproved != true &amp;&amp; roundFailedToStart != true);
        require(msg.sender == juryOperator);
        if (_approved == true) {
            cycleApproved = true;
        } else {
            roundFailedToStart = true;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approved == true</code></p>
<hr />
<h3>Contract : AgileArbitration</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0aacac0d2292e833e6b017511623c4b21746ea9e">0x0aacac0d2292e833e6b017511623c4b21746ea9e</a></p>
<pre><code class="language-solidity">function vote(uint _disputeId, bool _voteForInvestor) public {
        require(disputes[_disputeId].pending == true);
        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);
        require(disputes[_disputeId].voters[msg.sender] != true);
        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }
        else { disputes[_disputeId].votesForProject += 1; }
        if (disputes[_disputeId].votesForInvestor == quorum) {
            executeVerdict(_disputeId,true);
        }
        if (disputes[_disputeId].votesForProject == quorum) {
            executeVerdict(_disputeId,false);
        }
        disputes[_disputeId].voters[msg.sender] == true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_voteForInvestor == true</code></p>
<hr />
<h3>Contract : BabySer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x90734a326ca0bedf057cd7fda3bba66230a0bcab">0x90734a326ca0bedf057cd7fda3bba66230a0bcab</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : DelegationManagementContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2202cb9c00487e7e8ef21e6d8e914b32e709f43d">0x2202cb9c00487e7e8ef21e6d8e914b32e709f43d</a></p>
<pre><code class="language-solidity">function registerDelegationAddress(address _collectionAddress, address _delegationAddress, uint256 _expiryDate, uint256 _useCase, bool _allTokens, uint256 _tokenId) public {
        require((_useCase &gt; 0 &amp;&amp; _useCase &lt;= useCaseCounter));
        bytes32 delegatorHash;
        bytes32 delegationAddressHash;
        bytes32 globalHash;
        bytes32 collectionLockHash;
        bytes32 collectionUsecaseLockHash;
        bytes32 collectionUsecaseLockHashAll;
        // Locks
        collectionLockHash = keccak256(abi.encodePacked(_collectionAddress, _delegationAddress));
        collectionUsecaseLockHash = keccak256(abi.encodePacked(_collectionAddress, _delegationAddress, _useCase));
        collectionUsecaseLockHashAll = keccak256(abi.encodePacked(ALL_COLLECTIONS, _delegationAddress, _useCase));
        require(globalLock[_delegationAddress] == false);
        require(collectionLock[collectionLockHash] == false);
        require(collectionUsecaseLock[collectionUsecaseLockHash] == false);
        require(collectionUsecaseLock[collectionUsecaseLockHashAll] == false);
        // Push data to mappings
        globalHash = keccak256(abi.encodePacked(msg.sender, _collectionAddress, _delegationAddress, _useCase));
        delegatorHash = keccak256(abi.encodePacked(msg.sender, _collectionAddress, _useCase));
        // Stores delegation addresses on a delegator hash
        delegationAddressHash = keccak256(abi.encodePacked(_delegationAddress, _collectionAddress, _useCase));
        delegatorHashes[delegatorHash].push(_delegationAddress);
        // Stores delegators addresses on a delegation address hash
        delegationAddressHashes[delegationAddressHash].push(msg.sender);
        // Push additional data to the globalDelegationHashes mapping
        if (_allTokens == true) {
            GlobalData memory newdelegationGlobalData = GlobalData(msg.sender, _delegationAddress, block.timestamp, _expiryDate, true, 0);
            globalDelegationHashes[globalHash].push(newdelegationGlobalData);
        } else {
            GlobalData memory newdelegationGlobalData = GlobalData(msg.sender, _delegationAddress, block.timestamp, _expiryDate, false, _tokenId);
            globalDelegationHashes[globalHash].push(newdelegationGlobalData);
        }
        emit RegisterDelegation(msg.sender, _collectionAddress, _delegationAddress, _useCase, _allTokens, _tokenId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_allTokens == true</code></p>
<hr />
<h3>Contract : DelegationManagementContract</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2202cb9c00487e7e8ef21e6d8e914b32e709f43d">0x2202cb9c00487e7e8ef21e6d8e914b32e709f43d</a></p>
<pre><code class="language-solidity">function registerDelegationAddressUsingSubDelegation(address _delegatorAddress, address _collectionAddress, address _delegationAddress, uint256 _expiryDate, uint256 _useCase, bool _allTokens, uint256 _tokenId) public {
        // Check subdelegation rights for the specific collection
        {
            bool subdelegationRightsCol;
            address[] memory allDelegators = retrieveDelegators(msg.sender, _collectionAddress, USE_CASE_SUB_DELEGATION);
            if (allDelegators.length &gt; 0) {
                for (uint i = 0; i &lt; allDelegators.length; ) {
                    if (_delegatorAddress == allDelegators[i]) {
                        subdelegationRightsCol = true;
                        break;
                    }

                    unchecked {
                        ++i;
                    }
                }
            }
            // Check subdelegation rights for All collections
            allDelegators = retrieveDelegators(msg.sender, ALL_COLLECTIONS, USE_CASE_SUB_DELEGATION);
            if (allDelegators.length &gt; 0) {
                if (subdelegationRightsCol != true) {
                    for (uint i = 0; i &lt; allDelegators.length; ) {
                        if (_delegatorAddress == allDelegators[i]) {
                            subdelegationRightsCol = true;
                            break;
                        }

                        unchecked {
                            ++i;
                        }
                    }
                }
            }
            // Allow to register
            require((subdelegationRightsCol == true));
        }
        // If check passed then register delegation address for Delegator
        require((_useCase &gt; 0 &amp;&amp; _useCase &lt;= useCaseCounter));
        bytes32 delegatorHash;
        bytes32 delegationAddressHash;
        bytes32 globalHash;
        bytes32 collectionLockHash;
        bytes32 collectionUsecaseLockHash;
        bytes32 collectionUsecaseLockHashAll;
        // Locks
        collectionLockHash = keccak256(abi.encodePacked(_collectionAddress, _delegationAddress));
        collectionUsecaseLockHash = keccak256(abi.encodePacked(_collectionAddress, _delegationAddress, _useCase));
        collectionUsecaseLockHashAll = keccak256(abi.encodePacked(ALL_COLLECTIONS, _delegationAddress, _useCase));
        require(globalLock[_delegationAddress] == false);
        require(collectionLock[collectionLockHash] == false);
        require(collectionUsecaseLock[collectionUsecaseLockHash] == false);
        require(collectionUsecaseLock[collectionUsecaseLockHashAll] == false);
        // Push data to mappings
        globalHash = keccak256(abi.encodePacked(_delegatorAddress, _collectionAddress, _delegationAddress, _useCase));
        delegatorHash = keccak256(abi.encodePacked(_delegatorAddress, _collectionAddress, _useCase));
        // Stores delegation addresses on a delegator hash
        delegationAddressHash = keccak256(abi.encodePacked(_delegationAddress, _collectionAddress, _useCase));
        delegatorHashes[delegatorHash].push(_delegationAddress);
        // Stores delegators addresses on a delegation address hash
        delegationAddressHashes[delegationAddressHash].push(_delegatorAddress);
        // Push additional data to the globalDelegationHashes mapping
        if (_allTokens == true) {
            GlobalData memory newdelegationGlobalData = GlobalData(_delegatorAddress, _delegationAddress, block.timestamp, _expiryDate, true, 0);
            globalDelegationHashes[globalHash].push(newdelegationGlobalData);
        } else {
            GlobalData memory newdelegationGlobalData = GlobalData(_delegatorAddress, _delegationAddress, block.timestamp, _expiryDate, false, _tokenId);
            globalDelegationHashes[globalHash].push(newdelegationGlobalData);
        }
        emit RegisterDelegationUsingSubDelegation(_delegatorAddress, msg.sender, _collectionAddress, _delegationAddress, _useCase, _allTokens, _tokenId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_allTokens == true</code></p>
<hr />
<h3>Contract : Oasis</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x6e171e80024232ebd4e8fa7eaf08b88eae280369">0x6e171e80024232ebd4e8fa7eaf08b88eae280369</a></p>
<pre><code class="language-solidity">function ended(bool ifget) public returns(bool) {
        address user = msg.sender;
        require(my[user].systemtag &lt; tags);
        require(!frozenAccount[user]);
        if(ifget == true) {

            my[user].prizecount = 0;
            my[user].tzs = 0;
            my[user].prizecount = 0;
            mycan[user].eths = 0;
            mycan[user].used = 0;
            if(mycan[user].len &gt; 0) {
                delete mycan[user].times;
                delete mycan[user].amounts;
                delete mycan[user].moneys;
            }
            mycan[user].len = 0;

            myrun[user].eths = 0;
            myrun[user].used = 0;
            if(myrun[user].len &gt; 0) {
                delete myrun[user].times;
                delete myrun[user].amounts;
                delete myrun[user].moneys;
            }
            myrun[user].len = 0;
            if(my[user].usereths/2 &gt; my[user].userethsused) {
                uint money = my[user].usereths/2 - my[user].userethsused;
                require(address(this).balance &gt; money);
                user.transfer(money);
            }
            my[user].usereths = 0;
            my[user].userethsused = 0;

        }else{
            uint amount = my[user].usereths - my[user].userethsused;
            tg[tags].ethnum += my[user].tzs;
            tg[tags].sysethnum += amount;
            tg[tags].userethnum += amount;
        }
        my[user].systemtag = tags;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifget == true</code></p>
<hr />
<h3>Contract : JBController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xffdd70c318915879d5192e8a0dcbfcb0285b3c98">0xffdd70c318915879d5192e8a0dcbfcb0285b3c98</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        SafeCast.toInt256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          SafeCast.toInt256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : JBController</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xffdd70c318915879d5192e8a0dcbfcb0285b3c98">0xffdd70c318915879d5192e8a0dcbfcb0285b3c98</a></p>
<pre><code class="language-solidity">function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &amp;&amp;
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;

      // Override the claimed token preference with the funding cycle value.
      _preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride();
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        SafeCast.toInt256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          SafeCast.toInt256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_preferClaimedTokens = _preferClaimedTokens == true
        ? _preferClaimedTokens
        : _fundingCycle.preferClaimedTokenOverride()</code></p>
<hr />
<h3>Contract : KoveredPay</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf24b487192af0202746f832bb5242896a2e1769e">0xf24b487192af0202746f832bb5242896a2e1769e</a></p>
<pre><code class="language-solidity">function Alter_TrustlessTransaction(uint256 _transactionId, bool _newStatus) public returns (bool _response) {

        uint256 sent_on = TrustlessTransactions_Log[_transactionId]._time;
        uint256 right_now = block.timestamp;
        uint256 difference = sub(right_now, sent_on);

        require(TransfersEnabled == true);
        require(TrustlessTransactions_Log[_transactionId]._statusModified == false);
        require(difference &lt;= TrustlessTransaction_Protection_Seconds);
        require(TrustlessTransactions_Log[_transactionId]._sender == msg.sender);
        require(TrustlessTransactions_Log[_transactionId]._refunded == false);
        require(TrustlessTransactions_Log[_transactionId]._credited == false);

        if (_newStatus == true) {

            UserBalances[TrustlessTransactions_Log[_transactionId]._receiver] = add(UserBalances[TrustlessTransactions_Log[_transactionId]._receiver], TrustlessTransactions_Log[_transactionId]._kvp_amount);
            TrustlessTransactions_Log[_transactionId]._credited = true;

        } else {

            UserBalances[TrustlessTransactions_Log[_transactionId]._sender] = add(UserBalances[TrustlessTransactions_Log[_transactionId]._sender], TrustlessTransactions_Log[_transactionId]._kvp_amount);

        }

        TrustlessTransactions_Log[_transactionId]._statusModified = true;
        TrustlessTransferStatusModified(_transactionId, _newStatus);

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_newStatus == true</code></p>
<hr />
<h3>Contract : KoveredPay</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf24b487192af0202746f832bb5242896a2e1769e">0xf24b487192af0202746f832bb5242896a2e1769e</a></p>
<pre><code class="language-solidity">function Alter_MediatedTransaction(uint256 _transactionId, bool _newStatus) public returns (bool _response) {

        require(TransfersEnabled == true);
        require(MediatedTransactions_Log[_transactionId]._mediator == true);
        require(MediatedTransactions_Log[_transactionId]._statusModified == false);
        require(CoreMediator == msg.sender);
        require(MediatedTransactions_Log[_transactionId]._credited == false);

        uint256 newAmount = sub(MediatedTransactions_Log[_transactionId]._kvp_amount, MediatedTransactions_Log[_transactionId]._fee_amount);

        if (newAmount &lt; 0) {
            newAmount = 0;
        }

        if (_newStatus == true) {

            UserBalances[MediatedTransactions_Log[_transactionId]._receiver] = add(UserBalances[MediatedTransactions_Log[_transactionId]._receiver], newAmount);
            MediatedTransactions_Log[_transactionId]._credited = true;

        } else {

            UserBalances[MediatedTransactions_Log[_transactionId]._sender] = add(UserBalances[MediatedTransactions_Log[_transactionId]._sender], newAmount);

        }

        UserBalances[CoreMediator] = add(UserBalances[CoreMediator], MediatedTransactions_Log[_transactionId]._fee_amount);

        MediatedTransactions_Log[_transactionId]._statusModified = true;
        MediatedTransferStatusModified(_transactionId, _newStatus);

        return true;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_newStatus == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x773b2201a3e528328bea117bcf3c0100e2ae785c">0x773b2201a3e528328bea117bcf3c0100e2ae785c</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
        public
        onlyAction
        returns (bool success)
    {
        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;
            success = executions[_id].to.call(executions[_id].data, 0);
            if (success) {
                executions[_id].executed = true;
                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );
            }
            return success;
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : GameEngine</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9f5fc9a2737ef601c6881f2a4859ca02da1fca13">0x9f5fc9a2737ef601c6881f2a4859ca02da1fca13</a></p>
<pre><code class="language-solidity">function claimAndUnstake (bool claim,uint[] memory tokenAmount) external nonReentrant{

        for (uint i=0;i&lt;tokenAmount.length;i++) {
            require(nftToken.tokenOwnerCall(tokenAmount[i]) == msg.sender, &quot;Caller not the owner&quot;);
            require(nftToken.ownerOf(tokenAmount[i]) == address(this),&quot;Contract not the owner&quot;);
            require(isStaked[tokenAmount[i]] = true, &quot;Not Staked&quot;);
            require (stakeTime[tokenAmount[i]]+ tokenToRandomHourInStake[tokenAmount[i]]&lt;= block.timestamp,&quot;Be Patient&quot;);
            if (claim == true) {
                claimStake(tokenAmount[i]);
            }
            else {
                bool isBurnt = claimStake(tokenAmount[i]);
                if (isBurnt == false)
                {
                    unstakeNFT(tokenAmount[i]);
                    isStaked[tokenAmount[i]] = false;
                }
            }
            // nftToken.setTimeStamp(tokenAmount[i]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>claim == true</code></p>
<hr />
<h3>Contract : Exchange</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8856a607269336fd58f5c34d98efac075a33c826">0x8856a607269336fd58f5c34d98efac075a33c826</a></p>
<pre><code class="language-solidity">function closeFuturesPosition (bytes32 futuresContract, bool side)
    {
        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);

        if (futuresContracts[futuresContract].closed == false &amp;&amp; futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled
        if (retrievePosition(positionHash)[1] == 0) throw; // position not found
        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed

        uint256 profit;
        uint256 loss;

        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;

        FuturesClosePositionValues memory v = FuturesClosePositionValues({
            reserve         : EtherMium(exchangeContract).getReserve(baseToken, msg.sender),
            balance         : EtherMium(exchangeContract).balanceOf(baseToken, msg.sender),
            floorPrice      : futuresContracts[futuresContract].floorPrice,
            capPrice        : futuresContracts[futuresContract].capPrice,
            closingPrice    : futuresContracts[futuresContract].closingPrice,
            futuresContract : futuresContract
        });

        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);
        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);
        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;
        // uint256 capPrice = futuresContracts[futuresContract].capPrice;
        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;



        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);
        uint256 fee = calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract);



        // close long position
        if (side == true)
        {            

            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);
            // return;
            // reserve = reserve - (entryPrice - floorPrice) * size;
            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));


            subReserve(
                baseToken, 
                msg.sender, 
                v.reserve, 
                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice
                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &gt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);



                // LogUint(15, profit);
                // LogUint(16, fee);
                // LogUint(17, safeSub(profit * 1e10, fee));
                // return;
                if (profit &gt; fee)
                {
                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }
                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  


                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }   
        // close short position 
        else
        {
            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);
            // return;

            // reserve = reserve - (capPrice - entryPrice) * size;
            subReserve(
                baseToken, 
                msg.sender,  
                v.reserve, 
                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice
                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &lt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                // profit = (entryPrice - closingPrice) * size
                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);

                if (profit &gt; fee)
                {
                    addBalance(baseToken, msg.sender, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, msg.sender, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                // profit = (closingPrice - entryPrice) * size
                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  

                subBalance(baseToken, msg.sender, v.balance, safeAdd(loss * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }  

        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount
        updatePositionSize(positionHash, 0, 0);

        emit FuturesPositionClosed(positionHash);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>side == true</code></p>
<hr />
<h3>Contract : Exchange</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x8856a607269336fd58f5c34d98efac075a33c826">0x8856a607269336fd58f5c34d98efac075a33c826</a></p>
<pre><code class="language-solidity">function closeFuturesPositionForUser (bytes32 futuresContract, bool side, address user, uint256 gasFee) onlyAdmin
    {
        bytes32 positionHash = keccak256(this, user, futuresContract, side);

        if (futuresContracts[futuresContract].closed == false &amp;&amp; futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled
        if (retrievePosition(positionHash)[1] == 0) throw; // position not found
        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed

        // failsafe, gas fee cannot be greater than 5% of position value
        if (safeMul(gasFee * 1e10, 20) &gt; calculateTradeValue(retrievePosition(positionHash)[0], retrievePosition(positionHash)[1], futuresContract))
        {
            emit LogError(uint8(Errors.GAS_TOO_HIGH), futuresContract, positionHash);
            return;
        }


        uint256 profit;
        uint256 loss;

        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;

        FuturesClosePositionValues memory v = FuturesClosePositionValues({
            reserve         : EtherMium(exchangeContract).getReserve(baseToken, user),
            balance         : EtherMium(exchangeContract).balanceOf(baseToken, user),
            floorPrice      : futuresContracts[futuresContract].floorPrice,
            capPrice        : futuresContracts[futuresContract].capPrice,
            closingPrice    : futuresContracts[futuresContract].closingPrice,
            futuresContract : futuresContract
        });

        // uint256 reserve = EtherMium(exchangeContract).getReserve(baseToken, msg.sender);
        // uint256 balance = EtherMium(exchangeContract).balanceOf(baseToken, msg.sender);
        // uint256 floorPrice = futuresContracts[futuresContract].floorPrice;
        // uint256 capPrice = futuresContracts[futuresContract].capPrice;
        // uint256 closingPrice =  futuresContracts[futuresContract].closingPrice;



        //uint256 fee = safeMul(safeMul(retrievePosition(positionHash)[0], v.closingPrice), takerFee) / (1 ether);
        uint256 fee = safeAdd(calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract), gasFee);

        // close long position
        if (side == true)
        {            

            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(retrievePosition(positionHash)[1], futuresContracts[futuresContract].floorPrice), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].floorPrice);
            // return;
            // reserve = reserve - (entryPrice - floorPrice) * size;
            //subReserve(baseToken, msg.sender, EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[positionHash].size));


            subReserve(
                baseToken, 
                user, 
                v.reserve, 
                //safeMul(safeSub(retrievePosition(positionHash)[1], v.floorPrice), retrievePosition(positionHash)[0]) / v.floorPrice
                calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(positions[msg.sender][positionHash].entryPrice, futuresContracts[futuresContract].floorPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &gt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                //profit = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);



                // LogUint(15, profit);
                // LogUint(16, fee);
                // LogUint(17, safeSub(profit * 1e10, fee));
                // return;
                if (profit &gt; fee)
                {
                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }
                //EtherMium(exchangeContract).updateBalance(baseToken, msg.sender, safeAdd(EtherMium(exchangeContract).balanceOf(baseToken, msg.sender), profit);
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                //loss = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  


                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));
                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }   
        // close short position 
        else
        {
            // LogUint(11, EtherMium(exchangeContract).getReserve(baseToken, msg.sender));
            // LogUint(12, safeMul(safeSub(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / futuresContracts[futuresContract].capPrice);
            // return;

            // reserve = reserve - (capPrice - entryPrice) * size;
            subReserve(
                baseToken, 
                user,  
                v.reserve, 
                //safeMul(safeSub(v.capPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.capPrice
                calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract)
            );
            //EtherMium(exchangeContract).setReserve(baseToken, msg.sender, safeSub(EtherMium(exchangeContract).getReserve(baseToken, msg.sender), safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));
            //reserve[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(reserve[futuresContracts[futuresContract].baseToken][msg.sender], safeMul(safeSub(futuresContracts[futuresContract].capPrice, positions[msg.sender][positionHash].entryPrice), positions[msg.sender][positionHash].size));



            if (v.closingPrice &lt; retrievePosition(positionHash)[1])
            {
                // user made a profit
                // profit = (entryPrice - closingPrice) * size
                // profit = safeMul(safeSub(retrievePosition(positionHash)[1], v.closingPrice), retrievePosition(positionHash)[0]) / v.closingPrice;
                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);

                if (profit &gt; fee)
                {
                    addBalance(baseToken, user, v.balance, safeSub(profit * 1e10, fee * 1e10)); 
                }
                else
                {
                    subBalance(baseToken, user, v.balance, safeSub(fee * 1e10, profit * 1e10)); 
                }


                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeAdd(tokens[futuresContracts[futuresContract].baseToken][msg.sender], profit);
            }
            else
            {
                // user made a loss
                // profit = (closingPrice - entryPrice) * size
                //loss = safeMul(safeSub(v.closingPrice, retrievePosition(positionHash)[1]), retrievePosition(positionHash)[0]) / v.closingPrice;
                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  

                subBalance(baseToken, user, v.balance, safeAdd(loss * 1e10, fee * 1e10));

                //tokens[futuresContracts[futuresContract].baseToken][msg.sender] = safeSub(tokens[futuresContracts[futuresContract].baseToken][msg.sender], loss);
            }
        }  

        addBalance(baseToken, feeAccount, EtherMium(exchangeContract).balanceOf(baseToken, feeAccount), fee * 1e10); // send fee to feeAccount
        updatePositionSize(positionHash, 0, 0);

        emit FuturesPositionClosed(positionHash);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>side == true</code></p>
<hr />
<h3>Contract : KOLVote</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0946e36c2887025c389ef85ea5f9150e0bed4d69">0x0946e36c2887025c389ef85ea5f9150e0bed4d69</a></p>
<pre><code class="language-solidity">function voteMission(uint16 _type,uint256 _missionId,bool _agree) onlyNodes public{
      require(!Voter[msg.sender][_missionId]);
      require(!missionList[_missionId].done);
      uint16 minNodesNum = minNodes;
      uint16 minSuperNodesNum = minSuperNodes;
      uint16 passNodes = halfNodes;
      uint16 passSuperNodes = halfSuperNodes;
      uint16 rate = half;
      if (missionList[_missionId].name == &quot;CHANGE OWNER&quot;) {
        rate = most;
        minNodesNum = totalNodes;
        passNodes = mostNodes;
      }else if (missionList[_missionId].name == &quot;CHANGE NODE&quot;){
        rate = less;
        minSuperNodesNum = minSuperNodes;
        passSuperNodes = halfSuperNodes;
      }else if (missionList[_missionId].name == &quot;CHANGE SUPER NODE&quot;){
        rate = less;
        minNodesNum = minNodes;
        passNodes = halfNodes;
      }else if (missionList[_missionId].name == &quot;CREATION ISSUING&quot;){
        minNodesNum = minNodes;
        passNodes = halfNodes;
        minSuperNodesNum = minSuperNodes;
        passSuperNodes = halfSuperNodes;
      }else if (missionList[_missionId].name == &quot;RECYCLE TOKEN FROM OWNER&quot;){
        minNodesNum = minNodes;
        passNodes = halfNodes;
      }

      if (_type == 1){
        require(isSuperNode[msg.sender]);
      }else if (_type ==2){
        require(isNode[msg.sender]);
      }

      if(now &gt; missionList[_missionId].endTime){
        if ( _type == 1 ){
          if (
            (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes)&gt;=minSuperNodesNum
            &amp;&amp;
            missionList[_missionId].agreeSuperNodes &gt;= (missionList[_missionId].agreeSuperNodes + missionList[_missionId].refuseSuperNodes) * rate/100
            ){
              missionList[_missionId].superPassed = true;
              missionPassed(_missionId);
          }
        }else if (_type ==2 ){
          //节点投票
          if (
            (missionList[_missionId].agreeNodes + missionList[_missionId].refuseNodes)&gt;=minNodesNum
            &amp;&amp;
            missionList[_missionId].agreeNodes &gt;= (missionList[_missionId].refuseNodes + missionList[_missionId].refuseNodes) * rate/100
            ){
              missionList[_missionId].nodePassed = true;
          }
        }
      }else{
        if(_agree == true){
          if (_type == 1){
            missionList[_missionId].agreeSuperNodes++;
          }else if(_type == 2){
            missionList[_missionId].agreeNodes++;
          }
        }
        else{
          if (_type == 1){
            missionList[_missionId].refuseSuperNodes++;
          }else if(_type == 2){
            missionList[_missionId].refuseNodes++;
          }
        }
        if (_type == 1){
          if (missionList[_missionId].agreeSuperNodes &gt;= passSuperNodes) {
              missionList[_missionId].superPassed = true;
              missionPassed(_missionId);
          }else if (missionList[_missionId].refuseSuperNodes &gt;= passSuperNodes) {
              missionList[_missionId].done = true;
          }
        }else if (_type ==2){
          if (missionList[_missionId].agreeNodes &gt;= passNodes) {
              missionList[_missionId].nodePassed = true;
          }else if (missionList[_missionId].refuseNodes &gt;= passNodes) {
              missionList[_missionId].done = true;
          }
        }
      }
      Voter[msg.sender][_missionId] = true;
      excuteAuto(_missionId);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_agree == true</code></p>
<hr />
<h3>Contract : VOLTBANK</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xab4e6caa3e4b17576c30bb2fe25105f5d24c6812">0xab4e6caa3e4b17576c30bb2fe25105f5d24c6812</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc90564061f3076084e8fb5aa1be1ceec0434fe2e">0xc90564061f3076084e8fb5aa1be1ceec0434fe2e</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc90564061f3076084e8fb5aa1be1ceec0434fe2e">0xc90564061f3076084e8fb5aa1be1ceec0434fe2e</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc90564061f3076084e8fb5aa1be1ceec0434fe2e">0xc90564061f3076084e8fb5aa1be1ceec0434fe2e</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : PiggyDistribution</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc90564061f3076084e8fb5aa1be1ceec0434fe2e">0xc90564061f3076084e8fb5aa1be1ceec0434fe2e</a></p>
<pre><code class="language-solidity">function claimWpc(address[] memory holders, PToken[] memory pTokens, bool borrowers, bool suppliers) public {
        require(enableWpcClaim, &quot;Claim is not enabled&quot;);

        for (uint i = 0; i &lt; pTokens.length; i++) {
            PToken pToken = pTokens[i];
            require(comptroller.isMarketListed(address(pToken)), &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa : pToken.borrowIndex()});
                updateWpcBorrowIndex(address(pToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerWpc(address(pToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateWpcSupplyIndex(address(pToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierWpc(address(pToken), holders[j], true);
                }
            }
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : V1StakingRewards</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x74a17d482dd2407cb60eab189c295ac572c50ecc">0x74a17d482dd2407cb60eab189c295ac572c50ecc</a></p>
<pre><code class="language-solidity">function withdraw(uint256 amount, bool payingCharges) public override nonReentrant updateReward(msg.sender)  {
        require(amount &gt; minimumWithdraw, &quot;Cannot withdraw 0&quot;);
        if(payingCharges == true){
            _balances[msg.sender] = _balances[msg.sender].sub(amount);
            _totalSupply = _totalSupply.sub(amount);
            uint256 fee = amount.mul(withdrawCharges).div(100);
            X22Token.safeTransfer(wallet, fee);
            amount = amount.sub(fee);
            X22Token.safeTransfer(msg.sender, amount);
            emit Withdrawn(msg.sender, amount);
        }
        else{
            if(requestedAmount[msg.sender] != amount){
            requestedAmount[msg.sender] = amount;
            requestedTime[msg.sender] = block.timestamp;
        }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>payingCharges == true</code></p>
<hr />
<h3>Contract : V1StakingRewards</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x74a17d482dd2407cb60eab189c295ac572c50ecc">0x74a17d482dd2407cb60eab189c295ac572c50ecc</a></p>
<pre><code class="language-solidity">function claim(bool payingCharges) public nonReentrant updateReward(msg.sender) {
        uint256 amount = requestedAmount[msg.sender];
        if(payingCharges == true){
            _balances[msg.sender] = _balances[msg.sender].sub(amount);
            _totalSupply = _totalSupply.sub(amount);
            uint256 fee = amount.mul(withdrawCharges).div(100);
            X22Token.safeTransfer(wallet, fee);
            amount = amount.sub(fee);
        }
        else{
            require(requestedTime[msg.sender].add(coolDownPeriod) &lt;= block.timestamp, 'You can withdraw after 8 days of requesting otherwise pay charges first');
            _balances[msg.sender] = _balances[msg.sender].sub(amount);
            _totalSupply = _totalSupply.sub(amount);
        }
        X22Token.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
        requestedTime[msg.sender] = 0;
        requestedAmount[msg.sender] = 0;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>payingCharges == true</code></p>
<hr />
<h3>Contract : GameUtil</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9a32cab8886f1d41af8777194253b62567e3aa5e">0x9a32cab8886f1d41af8777194253b62567e3aa5e</a></p>
<pre><code class="language-solidity">function getNodeReward(uint256 nodeLevel,uint256 level,bool superReward) public pure returns(uint256){
        if(nodeLevel == 1 &amp;&amp; level == 1){
            return 50;
        }if(nodeLevel == 2 &amp;&amp; level == 1){
            return 70;
        }if(nodeLevel == 2 &amp;&amp; level == 2){
            return 50;
        }if(nodeLevel == 3) {
            if(level == 1){
                return 100;
            }if(level == 2){
                return 70;
            }if(level == 3){
                return 50;
            }if(level &gt;= 4 &amp;&amp; level &lt;= 10){
                return 10;
            }if(level &gt;= 11 &amp;&amp; level &lt;= 20){
                return 5;
            }if(level &gt;= 21){
                if(superReward == true){
                    return 10;
                }
                else{
                    return 1;
                }
            }
        } return 0;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>superReward == true</code></p>
<hr />
<h3>Contract : Game</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9a32cab8886f1d41af8777194253b62567e3aa5e">0x9a32cab8886f1d41af8777194253b62567e3aa5e</a></p>
<pre><code class="language-solidity">function getNodeReward(uint256 nodeLevel,uint256 level,bool superReward) public pure returns(uint256){
        if(nodeLevel == 1 &amp;&amp; level == 1){
            return 50;
        }if(nodeLevel == 2 &amp;&amp; level == 1){
            return 70;
        }if(nodeLevel == 2 &amp;&amp; level == 2){
            return 50;
        }if(nodeLevel == 3) {
            if(level == 1){
                return 100;
            }if(level == 2){
                return 70;
            }if(level == 3){
                return 50;
            }if(level &gt;= 4 &amp;&amp; level &lt;= 10){
                return 10;
            }if(level &gt;= 11 &amp;&amp; level &lt;= 20){
                return 5;
            }if(level &gt;= 21){
                if(superReward == true){
                    return 10;
                }
                else{
                    return 1;
                }
            }
        } return 0;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>superReward == true</code></p>
<hr />
<h3>Contract : DeganDarkBundles</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4217000a117b293f8bb22e70c0a7492a14db4579">0x4217000a117b293f8bb22e70c0a7492a14db4579</a></p>
<pre><code class="language-solidity">function updatebal(address _user,uint256 _bundleId,uint256 _reward,bool _isPositive) public returns(bool){
        require(msg.sender == owner,'Not Owner');
        require(_reward &lt;= 50000000,'Invalid Reward Percent');
        User storage us = user[_user];
        //require(us.active == true,'Invalid User');
        UserBets storage u = bets[_user][_bundleId];
        require(u.claimed == false,'Already Claimed');
        if(_isPositive == true){
            updateFee(_reward,u.totalbet);
            uint256 temp = SafeMath.mul(_reward,90);
            uint256 reward = SafeMath.div(temp,100);
            uint256 a = SafeMath.mul(u.totalbet,reward);
            uint256 b = SafeMath.div(a,10**8);
            uint256 c = SafeMath.add(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        else{
            uint256 a = SafeMath.mul(u.totalbet,_reward);
            uint256 b = SafeMath.div(a,10**8);
            uint256 c = SafeMath.sub(u.totalbet,b);
            u.claimed = true;
            us.freebal = SafeMath.add(c,us.freebal);
            us.balance = SafeMath.sub(us.balance,u.totalbet);
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isPositive == true</code></p>
<hr />
<h3>Contract : TeamJust</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0d5c01a161a12901c214d2985ac1f6d7fa4644d6">0x0d5c01a161a12901c214d2985ac1f6d7fa4644d6</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xbc0b5970a01ba7c22104c85a4e2b05e01157638d">0xbc0b5970a01ba7c22104c85a4e2b05e01157638d</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external override moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                IModule(_module).init(address(this));
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : LendingPoolConfigurator</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf308df0f7e72a1f574d323e54de6988ba5507dfe">0xf308df0f7e72a1f574d323e54de6988ba5507dfe</a></p>
<pre><code class="language-solidity">function enableReserveForInvoicePool(address _reserve, bool _enable) external onlyLendingPoolManager {
        require(_reserve != address(0x0), &quot;reserve address is invalid&quot;);
        if(_enable == true) {
            require(isInvoiceReserve[_reserve] == false, &quot;reserve is already been enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = true;
        } else {
            require(isInvoiceReserve[_reserve] == true, &quot;reserve is not enabled for invoice lending pool&quot;);
            isInvoiceReserve[_reserve] = false;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_enable == true</code></p>
<hr />
<h3>Contract : ActionNFT</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe60a7825a80509de847ffe30ce2936dfc770db6b">0xe60a7825a80509de847ffe30ce2936dfc770db6b</a></p>
<pre><code class="language-solidity">function signResolution(bool _resolution) public onlyAdmin {
    canMint = false;

    // Floor Vote Successful
    if (_resolution == true) {
      // Admin can claim immediately
      adminClaimTime = block.timestamp;

      // Floor Vote Unsuccessful
    } else {
      // Withdraw period is active
      adminClaimTime = block.timestamp + withdrawWindow;
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_resolution == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf2b1039ba575cbeb126827816cfa59d748af3ae7">0xf2b1039ba575cbeb126827816cfa59d748af3ae7</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf2b1039ba575cbeb126827816cfa59d748af3ae7">0xf2b1039ba575cbeb126827816cfa59d748af3ae7</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf2b1039ba575cbeb126827816cfa59d748af3ae7">0xf2b1039ba575cbeb126827816cfa59d748af3ae7</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : ComptrollerG7</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xf2b1039ba575cbeb126827816cfa59d748af3ae7">0xf2b1039ba575cbeb126827816cfa59d748af3ae7</a></p>
<pre><code class="language-solidity">function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                    compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xca0bd2d68b19553826e34201c89248f809507e4e">0xca0bd2d68b19553826e34201c89248f809507e4e</a></p>
<pre><code class="language-solidity">function addorRemoveTokens(address[] memory _addresses, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            TokenAddresses[_addresses[i]] = _isAdded;
            if (_isAdded == true) {
                emit TokenAdded(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xca0bd2d68b19553826e34201c89248f809507e4e">0xca0bd2d68b19553826e34201c89248f809507e4e</a></p>
<pre><code class="language-solidity">function giveorRemoveSubscriptionTo(
        address[] memory _addresses,
        bool _isSubscriber
    ) external onlyRole(OPERATOR_ROLE, msg.sender) {
        for (uint256 i = 0; i &lt; _addresses.length; i++) {
            Subscribers[_addresses[i]] = _isSubscriber;
            if (_isSubscriber == true) {
                emit GotSubscription(_addresses[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isSubscriber == true</code></p>
<hr />
<h3>Contract : RafldexCryptoCoins_V1_1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xca0bd2d68b19553826e34201c89248f809507e4e">0xca0bd2d68b19553826e34201c89248f809507e4e</a></p>
<pre><code class="language-solidity">function addTokenPayments(address[] memory _address, bool _isAdded)
        external
        onlyRole(OPERATOR_ROLE, msg.sender)
    {
        for (uint256 i = 0; i &lt; _address.length; i++) {
            TokenPaymentAddresses[_address[i]] = _isAdded;
            if (_isAdded == true) {
                emit AddedTokenPayment(_address[i]);
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isAdded == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcafea7c0f6f4c579d982747ef000a1dd36e59570">0xcafea7c0f6f4c579d982747ef000a1dd36e59570</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

    if (flag == true) {
      require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);
    }

    depositedCN[coverId].isDeposited = flag;
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9c11dab4bd3624bd930c22c4ac15e633668ac797">0x9c11dab4bd3624bd930c22c4ac15e633668ac797</a></p>
<pre><code class="language-solidity">function refund(bool _state) public onlyRole(ADMIN_ROLE) {
        require(genesisStatus == false, &quot;GENESIS MINT STILL OPEN&quot;);
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(refundFlag != _state, string(abi.encodePacked(&quot;Refund Flag already &quot;, boolString)));
        refundFlag = _state;
        emit RefundStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9c11dab4bd3624bd930c22c4ac15e633668ac797">0x9c11dab4bd3624bd930c22c4ac15e633668ac797</a></p>
<pre><code class="language-solidity">function switchGenesisMint(bool _state) public onlyRole(ADMIN_ROLE) {
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(genesisStatus != _state, string(abi.encodePacked(&quot;Genesis Flag already &quot;, boolString)));
        genesisStatus = _state;
        emit GenesisMintStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : DynamicNft</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9c11dab4bd3624bd930c22c4ac15e633668ac797">0x9c11dab4bd3624bd930c22c4ac15e633668ac797</a></p>
<pre><code class="language-solidity">function switchSubscriptionMint(bool _state) public onlyRole(ADMIN_ROLE) {
        string memory boolString = _state == true ? &quot;true&quot; : &quot;false&quot;;
        require(subscriptionStatus != _state, string(abi.encodePacked(&quot;Subscription Flag already &quot;, boolString)));
        subscriptionStatus = _state;
        emit SubscriptionMintStateUpdated(_state);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>string memory boolString = _state == true ? "true" : "false"</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x00000ddbc92c9501c6b48fc9a9e0ef8a97ca1884">0x00000ddbc92c9501c6b48fc9a9e0ef8a97ca1884</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xccb40a11aa8c5dfafaa9de9311fe7bd47d0bade7">0xccb40a11aa8c5dfafaa9de9311fe7bd47d0bade7</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5a77a0167de05c959cbc08a98ccffacd16079617">0x5a77a0167de05c959cbc08a98ccffacd16079617</a></p>
<pre><code class="language-solidity">function makeNewGame(
        address payable _ownerWallet,
        address payable _contractOwnerWallet,
        uint _systemOwnerPercent,
        uint _percentOwner,
        uint _percentReferrer,
        uint _percentFundDay, uint _percentFundWeek, uint _percentFundMonth, uint _percentFundYear,
        address _myAccountToJpFund, address _myAccountToReferFund,
        bool isMyGame
    ) public {
        require(_percentOwner &gt;= _percentReferrer);
        require(_contractOwnerWallet != address(0));
        address myGameAddress;
        if (_percentOwner &gt; 100) {
            _percentOwner = 100;
        }
        if (countContractByOwner(owner()) &gt; 0) {
            myGameAddress = getAddressContract(owner(), indexMyGame);
        }

        if (isMyGame == true) {
            require(myGameWhitelist[msg.sender]);
            _myAccountToJpFund = myGameAddress;
            _myAccountToReferFund = myGameAddress;
            _ownerWallet = owner();
        }

        address payable newContractAddress = headsOrTails.makeNewGame(
            _ownerWallet,
            _contractOwnerWallet,
                _systemOwnerPercent,
            _percentOwner,
            _myAccountToJpFund, _myAccountToReferFund
        );

        if (isMyGame == false) {
            settingJpPercentNewGameContract(
                newContractAddress, _myAccountToJpFund,
                _percentFundDay, _percentFundWeek, _percentFundMonth, _percentFundYear
            );
            settingReferPercentNewGameContract(
                newContractAddress, _myAccountToReferFund,
                _percentReferrer
            );

            _checkNewOwner(_ownerWallet);
            _listOfContract[msg.sender].push(newContractAddress);
        } else {
            _listOfContract[_ownerWallet].push(newContractAddress);
            _listOfJoinedMyGame[msg.sender].push(newContractAddress);
            _getSundayLottery(_ownerWallet, indexMyGame).payToMyGameContract(newContractAddress);
        }

        _ownerByContract[newContractAddress] = _ownerWallet;
        fundsStorage.setWhitelist(newContractAddress, true);
        referStorage.setWhitelist(newContractAddress, true);

        emit MakeNewGameContract(msg.sender, newContractAddress);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isMyGame == true</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5b8a210b6a1a3827b4571b198a8fdc3ca01bfcbf">0x5b8a210b6a1a3827b4571b198a8fdc3ca01bfcbf</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5b8a210b6a1a3827b4571b198a8fdc3ca01bfcbf">0x5b8a210b6a1a3827b4571b198a8fdc3ca01bfcbf</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD</code></p>
<hr />
<h3>Contract : ArbBot</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x5b8a210b6a1a3827b4571b198a8fdc3ca01bfcbf">0x5b8a210b6a1a3827b4571b198a8fdc3ca01bfcbf</a></p>
<pre><code class="language-solidity">function trade(bool _fromUSDB) public returns(bool) {
        IERC20Token tokenUSD = (_fromUSDB == true) ? tokenUSDB : tokenPEGUSD;
        ISmartToken relayUSD = (_fromUSDB == true) ? relayUSDB : relayPEGUSD;
        IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner());
        IBancorConverter converterSAI = IBancorConverter(relaySAI.owner());

        uint256 returnUSD = getReturnUSD(_fromUSDB);
        uint256 returnSAI = getReturnSAI(_fromUSDB);
        IERC20Token[] memory path = new IERC20Token[](5);
        if(returnSAI &gt; tradeValue) {
            require((returnSAI - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenUSD.balanceOf(address(this)) &gt; tradeValue, 'Insufficient USD balance.');
            // [tokenUSD, relayUSD, tokenBNT, relaySAI, tokenSAI];
            path[0] = tokenUSD;
            path[1] = IERC20Token(relayUSD);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relaySAI);
            path[4] = tokenSAI;
            converterUSD.quickConvert(path, tradeValue, tradeValue);
        } else {
            require((returnUSD - tradeValue) &gt; threshold, 'Trade not yet available.');
            require(tokenSAI.balanceOf(address(this)) &gt; tradeValue, 'Insufficient SAI balance.');
            // [tokenSAI, relaySAI, tokenBNT, relayUSD, tokenUSD];
            path[0] = tokenSAI;
            path[1] = IERC20Token(relaySAI);
            path[2] = tokenBNT;
            path[3] = IERC20Token(relayUSD);
            path[4] = tokenUSD;
            converterSAI.quickConvert(path, tradeValue, tradeValue);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>IBancorConverter converterUSD = (_fromUSDB == true) ? IBancorConverter(relayUSD.owner()) : IBancorConverter(relayUSD.owner())</code></p>
<hr />
<h3>Contract : WrappedPocket</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x67f4c72a50f8df6487720261e188f2abe83f57d7">0x67f4c72a50f8df6487720261e188f2abe83f57d7</a></p>
<pre><code class="language-solidity">function setFee(bool flag, uint256 newFee, address newCollector) public onlyRole(DEFAULT_ADMIN_ROLE) {
        if (newCollector == address(0) &amp;&amp; flag == true) {
            revert FeeCollectorZero();
        }

        if (newFee &gt; MAX_FEE_BASIS) {
            revert MaxBasis();
        }

        feeBasis = newFee;
        feeFlag = flag;
        feeCollector = newCollector;
        emit FeeSet(flag, newFee, newCollector);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>newCollector == address(0) &amp;&amp; flag == true</code></p>
<hr />
<h3>Contract : PriorityPool</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0bc122c224b875ca79250a54a08a6e5df8def817">0x0bc122c224b875ca79250a54a08a6e5df8def817</a></p>
<pre><code class="language-solidity">function withdraw(
        uint256 _amountToWithdraw,
        uint256 _amount,
        uint256 _sharesAmount,
        bytes32[] calldata _merkleProof,
        bool _shouldUnqueue
    ) external {
        if (_amountToWithdraw == 0) revert InvalidAmount();

        uint256 toWithdraw = _amountToWithdraw;
        address account = msg.sender;

        if (_shouldUnqueue == true) {
            _requireNotPaused();

            if (_merkleProof.length != 0) {
                bytes32 node = keccak256(bytes.concat(keccak256(abi.encode(account, _amount, _sharesAmount))));
                if (!MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, node)) revert InvalidProof();
            } else if (accountIndexes[account] &lt; merkleTreeSize) {
                revert InvalidProof();
            }

            uint256 queuedTokens = getQueuedTokens(account, _amount);
            uint256 canUnqueue = queuedTokens &lt;= totalQueued ? queuedTokens : totalQueued;
            uint256 amountToUnqueue = toWithdraw &lt;= canUnqueue ? toWithdraw : canUnqueue;

            if (amountToUnqueue != 0) {
                accountQueuedTokens[account] -= amountToUnqueue;
                totalQueued -= amountToUnqueue;
                toWithdraw -= amountToUnqueue;
                emit UnqueueTokens(account, amountToUnqueue);
            }
        }

        if (toWithdraw != 0) {
            IERC20Upgradeable(address(stakingPool)).safeTransferFrom(account, address(this), toWithdraw);
            _withdraw(toWithdraw);
            emit Withdraw(account, toWithdraw);
        }

        token.safeTransfer(account, _amountToWithdraw);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_shouldUnqueue == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x21790f2a8c6117cd93e65c30f55c6bb99cb6c16d">0x21790f2a8c6117cd93e65c30f55c6bb99cb6c16d</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x21790f2a8c6117cd93e65c30f55c6bb99cb6c16d">0x21790f2a8c6117cd93e65c30f55c6bb99cb6c16d</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x21790f2a8c6117cd93e65c30f55c6bb99cb6c16d">0x21790f2a8c6117cd93e65c30f55c6bb99cb6c16d</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x21790f2a8c6117cd93e65c30f55c6bb99cb6c16d">0x21790f2a8c6117cd93e65c30f55c6bb99cb6c16d</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : MVFStrategy</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x219996d7a069cba2fadfc3775cf9233152066b5a">0x219996d7a069cba2fadfc3775cf9233152066b5a</a></p>
<pre><code class="language-solidity">function adjustWatermark(uint amount, bool signs) external onlyVault {
        uint lastWatermark = watermark;
        watermark = signs == true ? watermark + amount : watermark - amount;
        emit AdjustWatermark(watermark, lastWatermark);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>watermark = signs == true ? watermark + amount : watermark - amount</code></p>
<hr />
<h3>Contract : Etheraffle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x45c58bbd535b8661110ef5296e6987573d0c8276">0x45c58bbd535b8661110ef5296e6987573d0c8276</a></p>
<pre><code class="language-solidity">function manuallyMakeOraclizeCall
    (
        uint _week,
        uint _delay,
        bool _isRandom,
        bool _isManual,
        bool _status
    )
        onlyEtheraffle external
    {
        paused = _status;
        string memory weekNumStr = uint2str(_week);
        if (_isRandom == true){
            bytes32 query = oraclize_query(_delay, &quot;nested&quot;, strConcat(randomStr1, weekNumStr, randomStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isRandom = true;
            qID[query].isManual = _isManual;
        } else {
            query = oraclize_query(_delay, &quot;nested&quot;, strConcat(apiStr1, weekNumStr, apiStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isManual = _isManual;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isRandom == true</code></p>
<hr />
<h3>Contract : Etheraffle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x45c58bbd535b8661110ef5296e6987573d0c8276">0x45c58bbd535b8661110ef5296e6987573d0c8276</a></p>
<pre><code class="language-solidity">function manuallyMakeOraclizeCall
    (
        uint _week,
        uint _delay,
        bool _isRandom,
        bool _isManual,
        bool _status
    )
        onlyEtheraffle external
    {
        paused = _status;
        string memory weekNumStr = uint2str(_week);
        if (_isRandom == true){
            bytes32 query = oraclize_query(_delay, &quot;nested&quot;, strConcat(randomStr1, weekNumStr, randomStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isRandom = true;
            qID[query].isManual = _isManual;
        } else {
            query = oraclize_query(_delay, &quot;nested&quot;, strConcat(apiStr1, weekNumStr, apiStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isManual = _isManual;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isRandom == true</code></p>
<hr />
<h3>Contract : Etheraffle</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x45c58bbd535b8661110ef5296e6987573d0c8276">0x45c58bbd535b8661110ef5296e6987573d0c8276</a></p>
<pre><code class="language-solidity">function manuallyMakeOraclizeCall
    (
        uint _week,
        uint _delay,
        bool _isRandom,
        bool _isManual,
        bool _status
    )
        onlyEtheraffle external
    {
        paused = _status;
        string memory weekNumStr = uint2str(_week);
        if (_isRandom == true){
            bytes32 query = oraclize_query(_delay, &quot;nested&quot;, strConcat(randomStr1, weekNumStr, randomStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isRandom = true;
            qID[query].isManual = _isManual;
        } else {
            query = oraclize_query(_delay, &quot;nested&quot;, strConcat(apiStr1, weekNumStr, apiStr2), gasAmt);
            qID[query].weekNo   = _week;
            qID[query].isManual = _isManual;
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isRandom == true</code></p>
<hr />
<h3>Contract : VeriswapERC20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d416d72ec596b830889abf95037ac7e0f887aa6">0x9d416d72ec596b830889abf95037ac7e0f887aa6</a></p>
<pre><code class="language-solidity">function createSwap(

        address _inputToken,

        uint256 _inputAmount,

        address _outputToken,

        uint256 _outputAmount,

        address _executor,

        bool _requireIdentity,

        bool _requireKyc,

        bool _requireSanctionCheck

    ) public {

        if (_requireIdentity == true) {

            address senderId = signataIdentity.getIdentity(msg.sender);

            require(

                !signataIdentity.isLocked(senderId),

                &quot;createSwap::Creator must not be locked&quot;

            );

            // don't check the executor yet, just in case they go and register after the fact.

        }

        if (_requireKyc == true) {

            require(

                signataRight.holdsTokenOfSchema(

                    msg.sender,

                    claimRight.schemaId()

                ),

                &quot;createSwap::Creator must have kyc nft&quot;

            );

            // don't check the executor yet, just in case they go and kyc after the fact.

        }



        if (_requireSanctionCheck == true) {

            SanctionsList sanctionsList = SanctionsList(sanctionsContract);

            require(

                !sanctionsList.isSanctioned(msg.sender),

                &quot;createSwap::Creator must not be sanctioned&quot;

            );

            require(

                !sanctionsList.isSanctioned(_executor),

                &quot;createSwap::Executor must not be sanctioned&quot;

            );

        }



        EscrowSwap memory swapToCheck = swaps[msg.sender];

        require(

            swapToCheck.state != States.OPEN,

            &quot;createSwap::already have an open swap&quot;

        );



        IERC20 inputToken = IERC20(_inputToken);



        // check allowance

        require(

            _inputAmount &lt;= inputToken.allowance(msg.sender, address(this)),

            &quot;createSwap::insufficient allowance&quot;

        );



        // transfer into escrow

        require(

            inputToken.transferFrom(msg.sender, address(this), _inputAmount),

            &quot;createSwap::transferFrom failed&quot;

        );



        // store the details

        EscrowSwap memory newSwap = EscrowSwap({

            inputToken: _inputToken,

            inputAmount: _inputAmount,

            outputToken: _outputToken,

            outputAmount: _outputAmount,

            executor: _executor,

            creator: msg.sender,

            requireIdentity: _requireIdentity,

            requireKyc: _requireKyc,

            requireSanctionCheck: _requireSanctionCheck,

            state: States.OPEN

        });

        swaps[msg.sender] = newSwap;



        emit SwapCreated(newSwap);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_requireIdentity == true</code></p>
<hr />
<h3>Contract : VeriswapERC20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d416d72ec596b830889abf95037ac7e0f887aa6">0x9d416d72ec596b830889abf95037ac7e0f887aa6</a></p>
<pre><code class="language-solidity">function createSwap(

        address _inputToken,

        uint256 _inputAmount,

        address _outputToken,

        uint256 _outputAmount,

        address _executor,

        bool _requireIdentity,

        bool _requireKyc,

        bool _requireSanctionCheck

    ) public {

        if (_requireIdentity == true) {

            address senderId = signataIdentity.getIdentity(msg.sender);

            require(

                !signataIdentity.isLocked(senderId),

                &quot;createSwap::Creator must not be locked&quot;

            );

            // don't check the executor yet, just in case they go and register after the fact.

        }

        if (_requireKyc == true) {

            require(

                signataRight.holdsTokenOfSchema(

                    msg.sender,

                    claimRight.schemaId()

                ),

                &quot;createSwap::Creator must have kyc nft&quot;

            );

            // don't check the executor yet, just in case they go and kyc after the fact.

        }



        if (_requireSanctionCheck == true) {

            SanctionsList sanctionsList = SanctionsList(sanctionsContract);

            require(

                !sanctionsList.isSanctioned(msg.sender),

                &quot;createSwap::Creator must not be sanctioned&quot;

            );

            require(

                !sanctionsList.isSanctioned(_executor),

                &quot;createSwap::Executor must not be sanctioned&quot;

            );

        }



        EscrowSwap memory swapToCheck = swaps[msg.sender];

        require(

            swapToCheck.state != States.OPEN,

            &quot;createSwap::already have an open swap&quot;

        );



        IERC20 inputToken = IERC20(_inputToken);



        // check allowance

        require(

            _inputAmount &lt;= inputToken.allowance(msg.sender, address(this)),

            &quot;createSwap::insufficient allowance&quot;

        );



        // transfer into escrow

        require(

            inputToken.transferFrom(msg.sender, address(this), _inputAmount),

            &quot;createSwap::transferFrom failed&quot;

        );



        // store the details

        EscrowSwap memory newSwap = EscrowSwap({

            inputToken: _inputToken,

            inputAmount: _inputAmount,

            outputToken: _outputToken,

            outputAmount: _outputAmount,

            executor: _executor,

            creator: msg.sender,

            requireIdentity: _requireIdentity,

            requireKyc: _requireKyc,

            requireSanctionCheck: _requireSanctionCheck,

            state: States.OPEN

        });

        swaps[msg.sender] = newSwap;



        emit SwapCreated(newSwap);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_requireKyc == true</code></p>
<hr />
<h3>Contract : VeriswapERC20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d416d72ec596b830889abf95037ac7e0f887aa6">0x9d416d72ec596b830889abf95037ac7e0f887aa6</a></p>
<pre><code class="language-solidity">function createSwap(

        address _inputToken,

        uint256 _inputAmount,

        address _outputToken,

        uint256 _outputAmount,

        address _executor,

        bool _requireIdentity,

        bool _requireKyc,

        bool _requireSanctionCheck

    ) public {

        if (_requireIdentity == true) {

            address senderId = signataIdentity.getIdentity(msg.sender);

            require(

                !signataIdentity.isLocked(senderId),

                &quot;createSwap::Creator must not be locked&quot;

            );

            // don't check the executor yet, just in case they go and register after the fact.

        }

        if (_requireKyc == true) {

            require(

                signataRight.holdsTokenOfSchema(

                    msg.sender,

                    claimRight.schemaId()

                ),

                &quot;createSwap::Creator must have kyc nft&quot;

            );

            // don't check the executor yet, just in case they go and kyc after the fact.

        }



        if (_requireSanctionCheck == true) {

            SanctionsList sanctionsList = SanctionsList(sanctionsContract);

            require(

                !sanctionsList.isSanctioned(msg.sender),

                &quot;createSwap::Creator must not be sanctioned&quot;

            );

            require(

                !sanctionsList.isSanctioned(_executor),

                &quot;createSwap::Executor must not be sanctioned&quot;

            );

        }



        EscrowSwap memory swapToCheck = swaps[msg.sender];

        require(

            swapToCheck.state != States.OPEN,

            &quot;createSwap::already have an open swap&quot;

        );



        IERC20 inputToken = IERC20(_inputToken);



        // check allowance

        require(

            _inputAmount &lt;= inputToken.allowance(msg.sender, address(this)),

            &quot;createSwap::insufficient allowance&quot;

        );



        // transfer into escrow

        require(

            inputToken.transferFrom(msg.sender, address(this), _inputAmount),

            &quot;createSwap::transferFrom failed&quot;

        );



        // store the details

        EscrowSwap memory newSwap = EscrowSwap({

            inputToken: _inputToken,

            inputAmount: _inputAmount,

            outputToken: _outputToken,

            outputAmount: _outputAmount,

            executor: _executor,

            creator: msg.sender,

            requireIdentity: _requireIdentity,

            requireKyc: _requireKyc,

            requireSanctionCheck: _requireSanctionCheck,

            state: States.OPEN

        });

        swaps[msg.sender] = newSwap;



        emit SwapCreated(newSwap);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_requireSanctionCheck == true</code></p>
<hr />
<h3>Contract : VeriswapERC20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d416d72ec596b830889abf95037ac7e0f887aa6">0x9d416d72ec596b830889abf95037ac7e0f887aa6</a></p>
<pre><code class="language-solidity">function createSwap(

        address _inputToken,

        uint256 _inputAmount,

        address _outputToken,

        uint256 _outputAmount,

        address _executor,

        bool _requireIdentity,

        bool _requireKyc,

        bool _requireSanctionCheck

    ) public {

        if (_requireIdentity == true) {

            address senderId = signataIdentity.getIdentity(msg.sender);

            require(

                !signataIdentity.isLocked(senderId),

                &quot;createSwap::Creator must not be locked&quot;

            );

            // don't check the executor yet, just in case they go and register after the fact.

        }

        if (_requireKyc == true) {

            require(

                signataRight.holdsTokenOfSchema(

                    msg.sender,

                    claimRight.schemaId()

                ),

                &quot;createSwap::Creator must have kyc nft&quot;

            );

            // don't check the executor yet, just in case they go and kyc after the fact.

        }



        if (_requireSanctionCheck == true) {

            SanctionsList sanctionsList = SanctionsList(sanctionsContract);

            require(

                !sanctionsList.isSanctioned(msg.sender),

                &quot;createSwap::Creator must not be sanctioned&quot;

            );

            require(

                !sanctionsList.isSanctioned(_executor),

                &quot;createSwap::Executor must not be sanctioned&quot;

            );

        }



        EscrowSwap memory swapToCheck = swaps[msg.sender];

        require(

            swapToCheck.state != States.OPEN,

            &quot;createSwap::already have an open swap&quot;

        );



        IERC20 inputToken = IERC20(_inputToken);



        // check allowance

        require(

            _inputAmount &lt;= inputToken.allowance(msg.sender, address(this)),

            &quot;createSwap::insufficient allowance&quot;

        );



        // transfer into escrow

        require(

            inputToken.transferFrom(msg.sender, address(this), _inputAmount),

            &quot;createSwap::transferFrom failed&quot;

        );



        // store the details

        EscrowSwap memory newSwap = EscrowSwap({

            inputToken: _inputToken,

            inputAmount: _inputAmount,

            outputToken: _outputToken,

            outputAmount: _outputAmount,

            executor: _executor,

            creator: msg.sender,

            requireIdentity: _requireIdentity,

            requireKyc: _requireKyc,

            requireSanctionCheck: _requireSanctionCheck,

            state: States.OPEN

        });

        swaps[msg.sender] = newSwap;



        emit SwapCreated(newSwap);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_requireIdentity == true</code></p>
<hr />
<h3>Contract : VeriswapERC20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d416d72ec596b830889abf95037ac7e0f887aa6">0x9d416d72ec596b830889abf95037ac7e0f887aa6</a></p>
<pre><code class="language-solidity">function createSwap(

        address _inputToken,

        uint256 _inputAmount,

        address _outputToken,

        uint256 _outputAmount,

        address _executor,

        bool _requireIdentity,

        bool _requireKyc,

        bool _requireSanctionCheck

    ) public {

        if (_requireIdentity == true) {

            address senderId = signataIdentity.getIdentity(msg.sender);

            require(

                !signataIdentity.isLocked(senderId),

                &quot;createSwap::Creator must not be locked&quot;

            );

            // don't check the executor yet, just in case they go and register after the fact.

        }

        if (_requireKyc == true) {

            require(

                signataRight.holdsTokenOfSchema(

                    msg.sender,

                    claimRight.schemaId()

                ),

                &quot;createSwap::Creator must have kyc nft&quot;

            );

            // don't check the executor yet, just in case they go and kyc after the fact.

        }



        if (_requireSanctionCheck == true) {

            SanctionsList sanctionsList = SanctionsList(sanctionsContract);

            require(

                !sanctionsList.isSanctioned(msg.sender),

                &quot;createSwap::Creator must not be sanctioned&quot;

            );

            require(

                !sanctionsList.isSanctioned(_executor),

                &quot;createSwap::Executor must not be sanctioned&quot;

            );

        }



        EscrowSwap memory swapToCheck = swaps[msg.sender];

        require(

            swapToCheck.state != States.OPEN,

            &quot;createSwap::already have an open swap&quot;

        );



        IERC20 inputToken = IERC20(_inputToken);



        // check allowance

        require(

            _inputAmount &lt;= inputToken.allowance(msg.sender, address(this)),

            &quot;createSwap::insufficient allowance&quot;

        );



        // transfer into escrow

        require(

            inputToken.transferFrom(msg.sender, address(this), _inputAmount),

            &quot;createSwap::transferFrom failed&quot;

        );



        // store the details

        EscrowSwap memory newSwap = EscrowSwap({

            inputToken: _inputToken,

            inputAmount: _inputAmount,

            outputToken: _outputToken,

            outputAmount: _outputAmount,

            executor: _executor,

            creator: msg.sender,

            requireIdentity: _requireIdentity,

            requireKyc: _requireKyc,

            requireSanctionCheck: _requireSanctionCheck,

            state: States.OPEN

        });

        swaps[msg.sender] = newSwap;



        emit SwapCreated(newSwap);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_requireKyc == true</code></p>
<hr />
<h3>Contract : VeriswapERC20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d416d72ec596b830889abf95037ac7e0f887aa6">0x9d416d72ec596b830889abf95037ac7e0f887aa6</a></p>
<pre><code class="language-solidity">function createSwap(

        address _inputToken,

        uint256 _inputAmount,

        address _outputToken,

        uint256 _outputAmount,

        address _executor,

        bool _requireIdentity,

        bool _requireKyc,

        bool _requireSanctionCheck

    ) public {

        if (_requireIdentity == true) {

            address senderId = signataIdentity.getIdentity(msg.sender);

            require(

                !signataIdentity.isLocked(senderId),

                &quot;createSwap::Creator must not be locked&quot;

            );

            // don't check the executor yet, just in case they go and register after the fact.

        }

        if (_requireKyc == true) {

            require(

                signataRight.holdsTokenOfSchema(

                    msg.sender,

                    claimRight.schemaId()

                ),

                &quot;createSwap::Creator must have kyc nft&quot;

            );

            // don't check the executor yet, just in case they go and kyc after the fact.

        }



        if (_requireSanctionCheck == true) {

            SanctionsList sanctionsList = SanctionsList(sanctionsContract);

            require(

                !sanctionsList.isSanctioned(msg.sender),

                &quot;createSwap::Creator must not be sanctioned&quot;

            );

            require(

                !sanctionsList.isSanctioned(_executor),

                &quot;createSwap::Executor must not be sanctioned&quot;

            );

        }



        EscrowSwap memory swapToCheck = swaps[msg.sender];

        require(

            swapToCheck.state != States.OPEN,

            &quot;createSwap::already have an open swap&quot;

        );



        IERC20 inputToken = IERC20(_inputToken);



        // check allowance

        require(

            _inputAmount &lt;= inputToken.allowance(msg.sender, address(this)),

            &quot;createSwap::insufficient allowance&quot;

        );



        // transfer into escrow

        require(

            inputToken.transferFrom(msg.sender, address(this), _inputAmount),

            &quot;createSwap::transferFrom failed&quot;

        );



        // store the details

        EscrowSwap memory newSwap = EscrowSwap({

            inputToken: _inputToken,

            inputAmount: _inputAmount,

            outputToken: _outputToken,

            outputAmount: _outputAmount,

            executor: _executor,

            creator: msg.sender,

            requireIdentity: _requireIdentity,

            requireKyc: _requireKyc,

            requireSanctionCheck: _requireSanctionCheck,

            state: States.OPEN

        });

        swaps[msg.sender] = newSwap;



        emit SwapCreated(newSwap);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_requireSanctionCheck == true</code></p>
<hr />
<h3>Contract : VeriswapERC20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d416d72ec596b830889abf95037ac7e0f887aa6">0x9d416d72ec596b830889abf95037ac7e0f887aa6</a></p>
<pre><code class="language-solidity">function createSwap(

        address _inputToken,

        uint256 _inputAmount,

        address _outputToken,

        uint256 _outputAmount,

        address _executor,

        bool _requireIdentity,

        bool _requireKyc,

        bool _requireSanctionCheck

    ) public {

        if (_requireIdentity == true) {

            address senderId = signataIdentity.getIdentity(msg.sender);

            require(

                !signataIdentity.isLocked(senderId),

                &quot;createSwap::Creator must not be locked&quot;

            );

            // don't check the executor yet, just in case they go and register after the fact.

        }

        if (_requireKyc == true) {

            require(

                signataRight.holdsTokenOfSchema(

                    msg.sender,

                    claimRight.schemaId()

                ),

                &quot;createSwap::Creator must have kyc nft&quot;

            );

            // don't check the executor yet, just in case they go and kyc after the fact.

        }



        if (_requireSanctionCheck == true) {

            SanctionsList sanctionsList = SanctionsList(sanctionsContract);

            require(

                !sanctionsList.isSanctioned(msg.sender),

                &quot;createSwap::Creator must not be sanctioned&quot;

            );

            require(

                !sanctionsList.isSanctioned(_executor),

                &quot;createSwap::Executor must not be sanctioned&quot;

            );

        }



        EscrowSwap memory swapToCheck = swaps[msg.sender];

        require(

            swapToCheck.state != States.OPEN,

            &quot;createSwap::already have an open swap&quot;

        );



        IERC20 inputToken = IERC20(_inputToken);



        // check allowance

        require(

            _inputAmount &lt;= inputToken.allowance(msg.sender, address(this)),

            &quot;createSwap::insufficient allowance&quot;

        );



        // transfer into escrow

        require(

            inputToken.transferFrom(msg.sender, address(this), _inputAmount),

            &quot;createSwap::transferFrom failed&quot;

        );



        // store the details

        EscrowSwap memory newSwap = EscrowSwap({

            inputToken: _inputToken,

            inputAmount: _inputAmount,

            outputToken: _outputToken,

            outputAmount: _outputAmount,

            executor: _executor,

            creator: msg.sender,

            requireIdentity: _requireIdentity,

            requireKyc: _requireKyc,

            requireSanctionCheck: _requireSanctionCheck,

            state: States.OPEN

        });

        swaps[msg.sender] = newSwap;



        emit SwapCreated(newSwap);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_requireIdentity == true</code></p>
<hr />
<h3>Contract : VeriswapERC20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d416d72ec596b830889abf95037ac7e0f887aa6">0x9d416d72ec596b830889abf95037ac7e0f887aa6</a></p>
<pre><code class="language-solidity">function createSwap(

        address _inputToken,

        uint256 _inputAmount,

        address _outputToken,

        uint256 _outputAmount,

        address _executor,

        bool _requireIdentity,

        bool _requireKyc,

        bool _requireSanctionCheck

    ) public {

        if (_requireIdentity == true) {

            address senderId = signataIdentity.getIdentity(msg.sender);

            require(

                !signataIdentity.isLocked(senderId),

                &quot;createSwap::Creator must not be locked&quot;

            );

            // don't check the executor yet, just in case they go and register after the fact.

        }

        if (_requireKyc == true) {

            require(

                signataRight.holdsTokenOfSchema(

                    msg.sender,

                    claimRight.schemaId()

                ),

                &quot;createSwap::Creator must have kyc nft&quot;

            );

            // don't check the executor yet, just in case they go and kyc after the fact.

        }



        if (_requireSanctionCheck == true) {

            SanctionsList sanctionsList = SanctionsList(sanctionsContract);

            require(

                !sanctionsList.isSanctioned(msg.sender),

                &quot;createSwap::Creator must not be sanctioned&quot;

            );

            require(

                !sanctionsList.isSanctioned(_executor),

                &quot;createSwap::Executor must not be sanctioned&quot;

            );

        }



        EscrowSwap memory swapToCheck = swaps[msg.sender];

        require(

            swapToCheck.state != States.OPEN,

            &quot;createSwap::already have an open swap&quot;

        );



        IERC20 inputToken = IERC20(_inputToken);



        // check allowance

        require(

            _inputAmount &lt;= inputToken.allowance(msg.sender, address(this)),

            &quot;createSwap::insufficient allowance&quot;

        );



        // transfer into escrow

        require(

            inputToken.transferFrom(msg.sender, address(this), _inputAmount),

            &quot;createSwap::transferFrom failed&quot;

        );



        // store the details

        EscrowSwap memory newSwap = EscrowSwap({

            inputToken: _inputToken,

            inputAmount: _inputAmount,

            outputToken: _outputToken,

            outputAmount: _outputAmount,

            executor: _executor,

            creator: msg.sender,

            requireIdentity: _requireIdentity,

            requireKyc: _requireKyc,

            requireSanctionCheck: _requireSanctionCheck,

            state: States.OPEN

        });

        swaps[msg.sender] = newSwap;



        emit SwapCreated(newSwap);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_requireKyc == true</code></p>
<hr />
<h3>Contract : VeriswapERC20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x9d416d72ec596b830889abf95037ac7e0f887aa6">0x9d416d72ec596b830889abf95037ac7e0f887aa6</a></p>
<pre><code class="language-solidity">function createSwap(

        address _inputToken,

        uint256 _inputAmount,

        address _outputToken,

        uint256 _outputAmount,

        address _executor,

        bool _requireIdentity,

        bool _requireKyc,

        bool _requireSanctionCheck

    ) public {

        if (_requireIdentity == true) {

            address senderId = signataIdentity.getIdentity(msg.sender);

            require(

                !signataIdentity.isLocked(senderId),

                &quot;createSwap::Creator must not be locked&quot;

            );

            // don't check the executor yet, just in case they go and register after the fact.

        }

        if (_requireKyc == true) {

            require(

                signataRight.holdsTokenOfSchema(

                    msg.sender,

                    claimRight.schemaId()

                ),

                &quot;createSwap::Creator must have kyc nft&quot;

            );

            // don't check the executor yet, just in case they go and kyc after the fact.

        }



        if (_requireSanctionCheck == true) {

            SanctionsList sanctionsList = SanctionsList(sanctionsContract);

            require(

                !sanctionsList.isSanctioned(msg.sender),

                &quot;createSwap::Creator must not be sanctioned&quot;

            );

            require(

                !sanctionsList.isSanctioned(_executor),

                &quot;createSwap::Executor must not be sanctioned&quot;

            );

        }



        EscrowSwap memory swapToCheck = swaps[msg.sender];

        require(

            swapToCheck.state != States.OPEN,

            &quot;createSwap::already have an open swap&quot;

        );



        IERC20 inputToken = IERC20(_inputToken);



        // check allowance

        require(

            _inputAmount &lt;= inputToken.allowance(msg.sender, address(this)),

            &quot;createSwap::insufficient allowance&quot;

        );



        // transfer into escrow

        require(

            inputToken.transferFrom(msg.sender, address(this), _inputAmount),

            &quot;createSwap::transferFrom failed&quot;

        );



        // store the details

        EscrowSwap memory newSwap = EscrowSwap({

            inputToken: _inputToken,

            inputAmount: _inputAmount,

            outputToken: _outputToken,

            outputAmount: _outputAmount,

            executor: _executor,

            creator: msg.sender,

            requireIdentity: _requireIdentity,

            requireKyc: _requireKyc,

            requireSanctionCheck: _requireSanctionCheck,

            state: States.OPEN

        });

        swaps[msg.sender] = newSwap;



        emit SwapCreated(newSwap);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_requireSanctionCheck == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x75d917d2a9484dd9c15f6b09ac812370dc3b8422">0x75d917d2a9484dd9c15f6b09ac812370dc3b8422</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x75d917d2a9484dd9c15f6b09ac812370dc3b8422">0x75d917d2a9484dd9c15f6b09ac812370dc3b8422</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x75d917d2a9484dd9c15f6b09ac812370dc3b8422">0x75d917d2a9484dd9c15f6b09ac812370dc3b8422</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x75d917d2a9484dd9c15f6b09ac812370dc3b8422">0x75d917d2a9484dd9c15f6b09ac812370dc3b8422</a></p>
<pre><code class="language-solidity">function claimPie(address[] memory holders, address[] memory pTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; pTokens.length; i++) {
            address pToken = pTokens[i];
            require(markets[pToken].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: PTokenInterface(pToken).borrowIndex()});
                updatePieBorrowIndex(pToken, borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerPie(pToken, holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updatePieSupplyIndex(pToken);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierPie(pToken, holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2d04a81798ec74de48e09e3fd43ca41757d33e6a">0x2d04a81798ec74de48e09e3fd43ca41757d33e6a</a></p>
<pre><code class="language-solidity">function purchaseKingdom(string _key, string _title, bool _locked) public 
    payable 
    nonReentrant()
    checkKingdomExistence(_key)
    checkIsNotLocked(_key)
    {
        require(now &lt; rounds[currentRound].endTime);
        Round storage round = rounds[currentRound];
        uint kingdomId = round.kingdomsKeys[_key];
        Kingdom storage kingdom = kingdoms[kingdomId];
        require((kingdom.kingdomTier + 1) &lt; 6);
        uint requiredPrice = kingdom.minimumPrice;
        if (_locked == true) {
            requiredPrice = requiredPrice.add(ACTION_TAX);
        }

        require (msg.value &gt;= requiredPrice);
        uint jackpotCommission = (msg.value).sub(kingdom.returnPrice);

        if (kingdom.returnPrice &gt; 0) {
            round.nbKingdoms[kingdom.owner]--;
            if (kingdom.kingdomType == 1) {
                round.nbKingdomsType1[kingdom.owner]--;
            } else if (kingdom.kingdomType == 2) {
                round.nbKingdomsType2[kingdom.owner]--;
            } else if (kingdom.kingdomType == 3) {
                round.nbKingdomsType3[kingdom.owner]--;
            } else if (kingdom.kingdomType == 4) {
                round.nbKingdomsType4[kingdom.owner]--;
            } else if (kingdom.kingdomType == 5) {
                round.nbKingdomsType5[kingdom.owner]--;
            }

            compensateLatestMonarch(kingdom.lastTransaction, kingdom.returnPrice);
        }

        uint jackpotSplitted = jackpotCommission.mul(50).div(100);
        round.globalJackpot.balance = round.globalJackpot.balance.add(jackpotSplitted);

        kingdom.kingdomTier++;
        kingdom.title = _title;

        if (kingdom.kingdomTier == 5) {
            kingdom.returnPrice = 0;
        } else {
            kingdom.returnPrice = kingdom.minimumPrice.mul(2);
            kingdom.minimumPrice = kingdom.minimumPrice.add(kingdom.minimumPrice.mul(2));
        }

        kingdom.owner = msg.sender;
        kingdom.locked = _locked;

        uint transactionId = kingdomTransactions.push(Transaction(&quot;&quot;, msg.sender, msg.value, 0, jackpotSplitted)) - 1;
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdom.transactionCount++;
        kingdom.lastTransaction = transactionId;

        setNewJackpot(kingdom.kingdomType, jackpotSplitted, msg.sender);
        LandPurchasedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2d04a81798ec74de48e09e3fd43ca41757d33e6a">0x2d04a81798ec74de48e09e3fd43ca41757d33e6a</a></p>
<pre><code class="language-solidity">function setLock(string _key, bool _locked) public payable checkKingdomExistence(_key) onlyKingdomOwner(_key, msg.sender) {
        if (_locked == true) { require(msg.value &gt;= ACTION_TAX); }
        kingdoms[rounds[currentRound].kingdomsKeys[_key]].locked = _locked;
        if (msg.value &gt; 0) { asyncSend(bookerAddress, msg.value); }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : Map</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2d04a81798ec74de48e09e3fd43ca41757d33e6a">0x2d04a81798ec74de48e09e3fd43ca41757d33e6a</a></p>
<pre><code class="language-solidity">function createKingdom(address owner, string _key, string _title, uint _type, bool _locked) onlyForRemainingKingdoms() public payable {
        require(now &lt; rounds[currentRound].endTime);
        require(_type &gt; 0);
        require(_type &lt; 6);
        uint basePrice = STARTING_CLAIM_PRICE_WEI;
        uint requiredPrice = basePrice;
        if (_locked == true) { requiredPrice = requiredPrice.add(ACTION_TAX); }
        require(msg.value &gt;= requiredPrice);
        require(rounds[currentRound].kingdomsCreated[_key] == false);
        uint refundPrice = STARTING_CLAIM_PRICE_WEI.mul(2);
        uint nextMinimumPrice = STARTING_CLAIM_PRICE_WEI.add(refundPrice);
        uint kingdomId = kingdoms.push(Kingdom(&quot;&quot;, &quot;&quot;, 1, _type, 0, 0, 1, refundPrice, address(0), false)) - 1;

        kingdoms[kingdomId].title = _title;
        kingdoms[kingdomId].owner = owner;
        kingdoms[kingdomId].key = _key;
        kingdoms[kingdomId].minimumPrice = nextMinimumPrice;
        kingdoms[kingdomId].locked = _locked;

        rounds[currentRound].kingdomsKeys[_key] = kingdomId;
        rounds[currentRound].kingdomsCreated[_key] = true;

        uint jackpotSplitted = requiredPrice.mul(50).div(100);
        rounds[currentRound].globalJackpot.balance = rounds[currentRound].globalJackpot.balance.add(jackpotSplitted);

        uint transactionId = kingdomTransactions.push(Transaction(&quot;&quot;, msg.sender, msg.value, 0, jackpotSplitted)) - 1;
        kingdomTransactions[transactionId].kingdomKey = _key;
        kingdoms[kingdomId].lastTransaction = transactionId;

        setNewJackpot(_type, jackpotSplitted, msg.sender);
        LandCreatedEvent(_key, msg.sender);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_locked == true</code></p>
<hr />
<h3>Contract : BZXAAVEFLASHLIQUIDATE</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x385f83cb8b8c82693b0ccd85c08140b5218410cb">0x385f83cb8b8c82693b0ccd85c08140b5218410cb</a></p>
<pre><code class="language-solidity">function performTrade(bool isItEther, uint256 amount1) public returns(uint256) {


        uint256 startingETHBalance = address(this).balance;
        ERC20 tokenToReceive = ERC20(currentCToken);
        uint256 startingCBalance = tokenToReceive.balanceOf(address(this));

        if (isItEther == true) {

        } else {
            ERC20 bzLToken = ERC20(currentLToken);

            if (bzLToken.allowance(address(this), bzx1Address) &lt;= currentMaxLiq) {
                bzLToken.approve(bzx1Address, (currentMaxLiq * 100));
            }
        }

        if (isItEther == false) {
            bzx1.liquidate(currentLoanId, address(this), currentMaxLiq);
        } else {
            bzx1.liquidate.value(amount1)(currentLoanId, address(this), currentMaxLiq);
        }



        uint256 amountBack = 0;
        if (address(this).balance &gt; startingETHBalance) {
            uint256 newETH = address(this).balance - startingETHBalance;
            wethToken.deposit.value(newETH)();


            amountBack = performUniswap(wethAddress, currentLToken, newETH);
        }
        else {



            uint256 difCBalance = tokenToReceive.balanceOf(address(this)) - startingCBalance;
           require(difCBalance &gt;0, &quot;Balance of Collateral token didnt go up after swap didnt go up&quot;);


           amountBack = performUniswap(currentCToken, currentLToken, difCBalance);
        }

        return amountBack;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isItEther == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xb61e48422def02c380c505383c13dacd1b55f8c7">0xb61e48422def02c380c505383c13dacd1b55f8c7</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xc17d432bd8e8850fd7b32b0270f5afac65db0105">0xc17d432bd8e8850fd7b32b0270f5afac65db0105</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
            emit AuthorisedModule(_module, _value);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : Team</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x01653e20d03d450658740691087ea7155bcd9726">0x01653e20d03d450658740691087ea7155bcd9726</a></p>
<pre><code class="language-solidity">function addAdmin(address _who, bytes32 _name, bool _isDev)
        public
        onlyDevs()
    {
        if (MSFun.multiSig(msData, requiredDevSignatures_, &quot;addAdmin&quot;) == true) 
        {
            MSFun.deleteProposal(msData, &quot;addAdmin&quot;);

            // must check this so we dont mess up admin count by adding someone
            // who is already an admin
            if (admins_[_who].isAdmin == false) 
            { 

                // set admins flag to true in admin mapping
                admins_[_who].isAdmin = true;

                // adjust admin count and required signatures
                adminCount_ += 1;
                requiredSignatures_ += 1;
            }

            // are we setting them as a dev?
            // by putting this outside the above if statement, we can upgrade existing
            // admins to devs.
            if (_isDev == true) 
            {
                // bestow the honored dev status
                admins_[_who].isDev = _isDev;

                // increase dev count and required dev signatures
                devCount_ += 1;
                requiredDevSignatures_ += 1;
            }
        }

        // by putting this outside the above multisig, we can allow easy name changes
        // without having to bother with multisig.  this will still create a proposal though
        // so use the deleteAnyProposal to delete it if you want to
        admins_[_who].name = _name;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isDev == true</code></p>
<hr />
<h3>Contract : CULTRYOSHI</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3f42f60c48b5bd1a218c89b9196b55917a9d3d0c">0x3f42f60c48b5bd1a218c89b9196b55917a9d3d0c</a></p>
<pre><code class="language-solidity">function excludeAccountFromFees(address account, bool exclude) external authorized {
        if(exclude == true)
            _excluded.add(account);
        else
            _excluded.remove(account);
        emit ExcludedAccountFromFees(account, exclude);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>exclude == true</code></p>
<hr />
<h3>Contract : SatoshiFutures</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3e4f5dd1be2db446f4ddbdb1e4b2be0e58bbb408">0x3e4f5dd1be2db446f4ddbdb1e4b2be0e58bbb408</a></p>
<pre><code class="language-solidity">function startTrade(string _coinSymbol, uint _tradePeriod, bool _putOrCall) 
        payable 
        onlyIfNotStopped
        // onlyIfRightCoinChoosen(_coinSymbol)
        onlyMoreThanMinTrade 
        onlyIfValidTradePeriod(_tradePeriod)
        onlyIfEnoughBalanceToPayOut(msg.value) {
        string memory serializePutOrCall; 
        if(_putOrCall == true) {
            serializePutOrCall = &quot;put&quot;;
        } else  {
            serializePutOrCall = &quot;call&quot;;
        }
        var finalTime = block.timestamp + ((_tradePeriod + 1) * 60);
        string memory queryUrl = generateUrl(_coinSymbol, block.timestamp,  _tradePeriod );
        bytes32 queryId = oraclize_query(block.timestamp + ((_tradePeriod + 5) * 60), &quot;URL&quot;, queryUrl,ORACLIZE_GAS_LIMIT + safeGas);
        var thisTrade = trades[queryId];
        var thisTradeStats = tradesStats[queryId];
        thisTrade.investor = msg.sender;
        thisTrade.amountInvested = msg.value - (msg.value * ownerFee / 100 ); 
        thisTrade.initialPrice = 0; 
        thisTrade.finalPrice = 0; 
        thisTrade.coinSymbol = _coinSymbol; 
        thisTradeStats.tradePeriod = _tradePeriod; 
        thisTrade.putOrCall = serializePutOrCall; 
        thisTradeStats.wonOrLost = false; 
        thisTradeStats.initialTime = block.timestamp; 
        thisTradeStats.finalTime = finalTime - 60; 
        thisTradeStats.resolved = false; 
        thisTradeStats.query = queryUrl; 
        allOpenTradesAmounts += thisTrade.amountInvested + ((thisTrade.amountInvested * currentProfitPct) / 100);
        tradesIds[tradesCount++] = queryId;
        owner.transfer(msg.value  * ownerFee / 100); 
        getMaxTradeAmount();
        if (investorIDs[msg.sender] == 0) {
           numInvestors++;
           addInvestorAtID(numInvestors); 
        } 

        LOG_NewTradeCreated(queryId, thisTrade.investor);

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_putOrCall == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x811a7f70d12fbd29ec494edc75645e66f5fcccfc">0x811a7f70d12fbd29ec494edc75645e66f5fcccfc</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x2fe1f9bbc9ce8ea4e00f89fc1a8936de6934b63d">0x2fe1f9bbc9ce8ea4e00f89fc1a8936de6934b63d</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if(_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            }
            else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : ERC20Lean</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x96fd442b9402d47e83714c9075d446d34c37776f">0x96fd442b9402d47e83714c9075d446d34c37776f</a></p>
<pre><code class="language-solidity">constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_mainetFee == true</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcb03c8f714a3e67fe787f05cfa90abad0fd5bbf7">0xcb03c8f714a3e67fe787f05cfa90abad0fd5bbf7</a></p>
<pre><code class="language-solidity">function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public payable {
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee;
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            if(prices[_tokenId].price == 0) {
                if (ethfee &gt;= limitETHFee) {
                    require(msg.value == ethfee + _hightLightFee);
                } else {
                    require(msg.value == limitETHFee + _hightLightFee);
                    ethfee = limitETHFee;
                }
            }
            ethfee += prices[_tokenId].fee;
        } else ethfee = _ethPrice * ETHFee / Percen;

        setPrice(_tokenId, _ethPrice, ethfee, 0, _isHightLight);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : Bussiness</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcb03c8f714a3e67fe787f05cfa90abad0fd5bbf7">0xcb03c8f714a3e67fe787f05cfa90abad0fd5bbf7</a></p>
<pre><code class="language-solidity">function setPriceFeeHBWALLET(uint256 _tokenId, uint256 _ethPrice, bool _isHightLight) public returns (bool){
        require(erc721Address.ownerOf(_tokenId) == msg.sender &amp;&amp; prices[_tokenId].price != _ethPrice);
        uint256 fee;
        uint256 ethfee;
        uint256 _hightLightFee = 0;
        if (_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)) {
            _hightLightFee = hightLightFee * HBWALLETExchange / 2 / (10 ** 16);
        }
        if (prices[_tokenId].price &lt; _ethPrice) {
            ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
            // ethfee * HBWALLETExchange / 2 * (10 ** 2) / (10 ** 18)
            if(prices[_tokenId].price == 0) {
                if (fee &gt;= limitHBWALLETFee) {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), fee + _hightLightFee));
                } else {
                    require(hbwalletToken.transferFrom(msg.sender, address(this), limitHBWALLETFee + _hightLightFee));
                    fee = limitHBWALLETFee;
                }
            }
            fee += prices[_tokenId].hbfee;
        } else {
            ethfee = _ethPrice * ETHFee / Percen;
            fee = ethfee * HBWALLETExchange / 2 / (10 ** 16);
        }

        setPrice(_tokenId, _ethPrice, 0, fee, _isHightLight);
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_isHightLight == true &amp;&amp; (prices[_tokenId].price == 0 || prices[_tokenId].isHightlight == false)</code></p>
<hr />
<h3>Contract : MarsGenesisCore</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe6ddbea6749cc793ba12ac22bca03c3f1fcf3a80">0xe6ddbea6749cc793ba12ac22bca03c3f1fcf3a80</a></p>
<pre><code class="language-solidity">function mintLand(bool isPromo, string memory topLeftLatLong, string memory bottomRightLatLong, bytes memory signature, string memory ipfsHash, string memory metadataURI, uint cardId, address promoOwner) external payable returns (uint) {
        if (isPromo == true) {
            require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
            require(_hashes[ipfsHash] != 1, &quot;HASH_EXISTS&quot;);
            require(_promoTokenIdTracker.current() &lt; MAX_PROMO_LANDS, &quot;LIMIT_REACHED&quot;);
            _promoTokenIdTracker.increment();
        } else {
            require(msg.value &gt;= _currentPrice(), &quot;PAYMENT_TOO_LOW&quot;);
            require(_hashes[ipfsHash] != 1, &quot;HASH_EXISTS&quot;);
            bytes32 hash = keccak256(abi.encodePacked(topLeftLatLong, bottomRightLatLong, address(this), cardId, msg.sender));
            address signer = _recoverSigner(hash, signature);
            require(signer == _deployerAddress, &quot;INVALID_SIGNATURE&quot;);
        }
        address landOwner;
        if (isPromo == true) {
            landOwner = promoOwner;
        } else {
            landOwner = _msgSender();
        }

        uint newTokenId = _mintLand(landOwner, topLeftLatLong, bottomRightLatLong, ipfsHash, metadataURI, cardId);
        return newTokenId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isPromo == true</code></p>
<hr />
<h3>Contract : MarsGenesisCore</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe6ddbea6749cc793ba12ac22bca03c3f1fcf3a80">0xe6ddbea6749cc793ba12ac22bca03c3f1fcf3a80</a></p>
<pre><code class="language-solidity">function mintLand(bool isPromo, string memory topLeftLatLong, string memory bottomRightLatLong, bytes memory signature, string memory ipfsHash, string memory metadataURI, uint cardId, address promoOwner) external payable returns (uint) {
        if (isPromo == true) {
            require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
            require(_hashes[ipfsHash] != 1, &quot;HASH_EXISTS&quot;);
            require(_promoTokenIdTracker.current() &lt; MAX_PROMO_LANDS, &quot;LIMIT_REACHED&quot;);
            _promoTokenIdTracker.increment();
        } else {
            require(msg.value &gt;= _currentPrice(), &quot;PAYMENT_TOO_LOW&quot;);
            require(_hashes[ipfsHash] != 1, &quot;HASH_EXISTS&quot;);
            bytes32 hash = keccak256(abi.encodePacked(topLeftLatLong, bottomRightLatLong, address(this), cardId, msg.sender));
            address signer = _recoverSigner(hash, signature);
            require(signer == _deployerAddress, &quot;INVALID_SIGNATURE&quot;);
        }
        address landOwner;
        if (isPromo == true) {
            landOwner = promoOwner;
        } else {
            landOwner = _msgSender();
        }

        uint newTokenId = _mintLand(landOwner, topLeftLatLong, bottomRightLatLong, ipfsHash, metadataURI, cardId);
        return newTokenId;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isPromo == true</code></p>
<hr />
<h3>Contract : MarsGenesisWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe6ddbea6749cc793ba12ac22bca03c3f1fcf3a80">0xe6ddbea6749cc793ba12ac22bca03c3f1fcf3a80</a></p>
<pre><code class="language-solidity">function updateCapTable(address who, uint equity, bool isRemoval) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), &quot;INVALID_ROLE&quot;);
        require(equity &lt;= TOTAL_CAP, &quot;INVALID EQUITY (0-10000)&quot;);
        require(equity &gt;= 0, &quot;INVALID EQUITY (0-10000)&quot;);

        FounderAuthorization[] storage auths = _addressToFounderAuthorization[who];
        uint equityYes = 0;

        for (uint i = 0; i &lt; auths.length; i++) {
            if (equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval) {
                equityYes += founderToEquity[auths[i].founder];
            } 
        }

        if (equityYes &gt;= 7000) {
            if (isRemoval) {
                _removeFounder(who);
            } else {
                _addFounder(who, equity);
            }  
            delete _addressToFounderAuthorization[who];
        } 
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>equity == auths[i].equity &amp;&amp; auths[i].approved == true &amp;&amp; isRemoval == auths[i].isRemoval</code></p>
<hr />
<h3>Contract : N2MERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xde9a07e5f1eaf3236e84724e0a221ce44d7b2657">0xde9a07e5f1eaf3236e84724e0a221ce44d7b2657</a></p>
<pre><code class="language-solidity">function initialize(
        string memory tokenName,
        string memory tokenSymbol,
        uint256 iMintPrice,
        bytes32 baseURICIDHash,
        bytes32 placeholderImageCIDHash,
        RevenueAddress[] calldata revenueAddresses,
        address iErc20PaymentAddress,
        uint32 iTotalSupply,
        uint16 iRoyaltyFee,
        bool soulboundCollection,
        MintingType iMintingType
    ) public payable override initializer {
        __ERC721_init(tokenName, tokenSymbol);

        if (iTotalSupply == 0) revert TotalSupplyMustBeGreaterThanZero();
        if (baseURICIDHash != 0 &amp;&amp; placeholderImageCIDHash != 0) revert CantSetBaseURIAndPlaceholderAtTheSameTime();
        if (iRoyaltyFee &gt; 10_00) revert RoyaltyFeeTooHigh();

        _collectionSize = iTotalSupply;
        if (baseURICIDHash == 0) {
            if (placeholderImageCIDHash == 0) {
                if (iMintingType != MintingType.CUSTOM_URI)
                    revert NoBaseURINorPlaceholderSet();
            } else {
                _placeholderImageCIDHash = placeholderImageCIDHash;
            }
        } else {
            _baseURICIDHash = baseURICIDHash;
        }

        _mintPrice = iMintPrice;
        _royaltyFee = iRoyaltyFee;
        if (iMintingType != MintingType.SEQUENTIAL) {
            _mintingType = iMintingType;
        }
        if (iErc20PaymentAddress != address(0)) {
            _isERC20Payment = true;
            _erc20PaymentAddress = iErc20PaymentAddress;
        }
        if (soulboundCollection == true) {
            _soulboundCollection = true;
        }

        if (revenueAddresses.length &gt; 0) {
            uint256 revenuePercentageTotal;
            for (uint256 i; i &lt; revenueAddresses.length; ) {
                revenuePercentageTotal += revenueAddresses[i].percentage;
                unchecked {
                    ++i;
                }
            }
            _revenueInfo = revenueAddresses;
            if (revenuePercentageTotal &gt; 100_00 - N2M_FEE) revert InvalidRevenuePercentage();
        }

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>soulboundCollection == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0475675085484498c003fc02fd58bb34a8397484">0x0475675085484498c003fc02fd58bb34a8397484</a></p>
<pre><code class="language-solidity">function claimArtem(address[] memory holders, AToken[] memory aTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; aTokens.length; i++) {
            AToken aToken = aTokens[i];
            require(markets[address(aToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: aToken.borrowIndex()});
                updateArtemBorrowIndex(address(aToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerArtem(address(aToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateArtemSupplyIndex(address(aToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierArtem(address(aToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0475675085484498c003fc02fd58bb34a8397484">0x0475675085484498c003fc02fd58bb34a8397484</a></p>
<pre><code class="language-solidity">function claimArtem(address[] memory holders, AToken[] memory aTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; aTokens.length; i++) {
            AToken aToken = aTokens[i];
            require(markets[address(aToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: aToken.borrowIndex()});
                updateArtemBorrowIndex(address(aToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerArtem(address(aToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateArtemSupplyIndex(address(aToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierArtem(address(aToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0475675085484498c003fc02fd58bb34a8397484">0x0475675085484498c003fc02fd58bb34a8397484</a></p>
<pre><code class="language-solidity">function claimArtem(address[] memory holders, AToken[] memory aTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; aTokens.length; i++) {
            AToken aToken = aTokens[i];
            require(markets[address(aToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: aToken.borrowIndex()});
                updateArtemBorrowIndex(address(aToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerArtem(address(aToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateArtemSupplyIndex(address(aToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierArtem(address(aToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true</code></p>
<hr />
<h3>Contract : Controller</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x0475675085484498c003fc02fd58bb34a8397484">0x0475675085484498c003fc02fd58bb34a8397484</a></p>
<pre><code class="language-solidity">function claimArtem(address[] memory holders, AToken[] memory aTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; aTokens.length; i++) {
            AToken aToken = aTokens[i];
            require(markets[address(aToken)].isListed, &quot;market must be listed&quot;);
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: aToken.borrowIndex()});
                updateArtemBorrowIndex(address(aToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerArtem(address(aToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateArtemSupplyIndex(address(aToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierArtem(address(aToken), holders[j], true);
                }
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true</code></p>
<hr />
<h3>Contract : BaseWallet</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4b0e6ccb42471d9f044fbad5acf5cdaed687d116">0x4b0e6ccb42471d9f044fbad5acf5cdaed687d116</a></p>
<pre><code class="language-solidity">function authoriseModule(address _module, bool _value) external moduleOnly {
        if (authorised[_module] != _value) {
            emit AuthorisedModule(_module, _value);
            if (_value == true) {
                modules += 1;
                authorised[_module] = true;
                Module(_module).init(this);
            } else {
                modules -= 1;
                require(modules &gt; 0, &quot;BW: wallet must have at least one module&quot;);
                delete authorised[_module];
            }
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_value == true</code></p>
<hr />
<h3>Contract : CErc20</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x11900786cf04be6178287bcef5f53ffc63d110bf">0x11900786cf04be6178287bcef5f53ffc63d110bf</a></p>
<pre><code class="language-solidity">function mint(uint mintAmount, bool enterMarket) external returns (uint) {
        (uint err,) = mintInternal(mintAmount);
        //If the mint was successfull and the user wants to use assets as collateral
        if(err == 0 &amp;&amp; enterMarket == true){
            address[] memory marketToEnter = new address[](1);
            marketToEnter[0] = address(this);
            comptroller.enterMarkets(marketToEnter, msg.sender);
        }
        return err;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>err == 0 &amp;&amp; enterMarket == true</code></p>
<hr />
<h3>Contract : CErc20Delegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x11900786cf04be6178287bcef5f53ffc63d110bf">0x11900786cf04be6178287bcef5f53ffc63d110bf</a></p>
<pre><code class="language-solidity">function mint(uint mintAmount, bool enterMarket) external returns (uint) {
        (uint err,) = mintInternal(mintAmount);
        //If the mint was successfull and the user wants to use assets as collateral
        if(err == 0 &amp;&amp; enterMarket == true){
            address[] memory marketToEnter = new address[](1);
            marketToEnter[0] = address(this);
            comptroller.enterMarkets(marketToEnter, msg.sender);
        }
        return err;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>err == 0 &amp;&amp; enterMarket == true</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xec19e052e7a5c1fd6cd85a3d57814527facb59bb">0xec19e052e7a5c1fd6cd85a3d57814527facb59bb</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xec19e052e7a5c1fd6cd85a3d57814527facb59bb">0xec19e052e7a5c1fd6cd85a3d57814527facb59bb</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xec19e052e7a5c1fd6cd85a3d57814527facb59bb">0xec19e052e7a5c1fd6cd85a3d57814527facb59bb</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : RewardsDistributorDelegate</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xec19e052e7a5c1fd6cd85a3d57814527facb59bb">0xec19e052e7a5c1fd6cd85a3d57814527facb59bb</a></p>
<pre><code class="language-solidity">function claimRewards(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i &lt; cTokens.length; i++) {
            CToken cToken = cTokens[i];
            if (borrowers == true &amp;&amp; compBorrowState[address(cToken)].index &gt; 0) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
                }
            }
            if (suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j &lt; holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j]);
                }
            }
        }
        for (uint j = 0; j &lt; holders.length; j++) {
            compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>suppliers == true &amp;&amp; compSupplyState[address(cToken)].index &gt; 0</code></p>
<hr />
<h3>Contract : BZXAAVEFLASHLIQUIDATE</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa462648a555a7e5598003320dce1b71c44db954f">0xa462648a555a7e5598003320dce1b71c44db954f</a></p>
<pre><code class="language-solidity">function performTrade(bool isItEther, uint256 amount1) public returns(uint256) {


        uint256 startingETHBalance = address(this).balance;
        ERC20 tokenToReceive = ERC20(currentCToken);
        uint256 startingCBalance = tokenToReceive.balanceOf(address(this));

        if (isItEther == true) {

        } else {
            ERC20 bzLToken = ERC20(currentLToken);

            if (bzLToken.allowance(address(this), bzx1Address) &lt;= currentMaxLiq) {
                bzLToken.approve(bzx1Address, (currentMaxLiq * 100));
            }
        }

        if (isItEther == false) {
            bzx1.liquidate(currentLoanId, address(this), currentMaxLiq);
        } else {
            bzx1.liquidate.value(amount1)(currentLoanId, address(this), currentMaxLiq);
        }



        uint256 amountBack = 0;
        if (address(this).balance &gt; startingETHBalance) {
            uint256 newETH = address(this).balance - startingETHBalance;
            wethToken.deposit.value(newETH)();


            amountBack = performUniswap(wethAddress, currentLToken, newETH);
        }
        else {



            uint256 difCBalance = tokenToReceive.balanceOf(address(this)) - startingCBalance;
           require(difCBalance &gt;0, &quot;Balance of Collateral token didnt go up after swap didnt go up&quot;);


           amountBack = performUniswap(currentCToken, currentLToken, difCBalance);
        }

        return amountBack;

    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isItEther == true</code></p>
<hr />
<h3>Contract : PrivateFundFactory</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x257a6338baefbb99ead8610d1c148ba5980edc8d">0x257a6338baefbb99ead8610d1c148ba5980edc8d</a></p>
<pre><code class="language-solidity">function buildSecondStep(
    bytes32 _fundId,
    bool _finishFlag,
    string calldata _name,
    string calldata _dataLink,
    address[] calldata _initialRegistriesToApprove,
    uint256[] calldata _initialTokensToApprove
  )
    external
  {
    FundContracts storage c = fundContracts[_fundId];
    require(msg.sender == c.creator || msg.sender == c.operator, &quot;Only creator/operator allowed&quot;);
    require(c.currentStep == Step.SECOND, &quot;Requires second step&quot;);

    PrivateFundStorage _fundStorage = PrivateFundStorage(c.fundRegistry.getStorageAddress());
    IACL _fundACL = c.fundRegistry.getACL();
    address _fundProposalManager = c.fundRegistry.getProposalManagerAddress();

    _fundACL.setRole(_fundStorage.ROLE_CHANGE_NAME_AND_DESCRIPTION_MANAGER(), address(this), true);
    _fundStorage.setNameAndDataLink(_name, _dataLink);
    _fundACL.setRole(_fundStorage.ROLE_CHANGE_NAME_AND_DESCRIPTION_MANAGER(), address(this), false);

    uint256 len = _initialTokensToApprove.length;

    _fundACL.setRole(_fundStorage.ROLE_NEW_MEMBER_MANAGER(), address(this), true);

    _fundStorage.approveMintAll(_initialRegistriesToApprove, _initialTokensToApprove);

    _fundACL.setRole(_fundStorage.ROLE_NEW_MEMBER_MANAGER(), address(this), false);

    _fundACL.setRole(_fundStorage.ROLE_PROPOSAL_MARKERS_MANAGER(), address(this), true);

    for (uint i = 0; i &lt; proposalMarkersSignatures.length; i++) {
      if (bytes8(proposalMarkersNames[i]) == bytes8(&quot;storage.&quot;)) {
        _fundStorage.addProposalMarker(
          proposalMarkersSignatures[i],
          address(_fundStorage),
          _fundProposalManager,
          proposalMarkersNames[i],
          &quot;&quot;
        );
      }
      if (bytes8(proposalMarkersNames[i]) == bytes8(&quot;multiSig&quot;)) {
        _fundStorage.addProposalMarker(
          proposalMarkersSignatures[i],
          c.fundRegistry.getMultiSigAddress(),
          _fundProposalManager,
          proposalMarkersNames[i],
          &quot;&quot;
        );
      }
    }
    _fundACL.setRole(_fundStorage.ROLE_PROPOSAL_MARKERS_MANAGER(), address(this), false);

    if (_finishFlag == true) {
      _applyFundDefaultConfigValues(_fundId);
      _finish(_fundId);
    } else {
      c.currentStep = Step.THIRD;
      emit CreateFundSecondStep(_fundId, len);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_finishFlag == true</code></p>
<hr />
<h3>Contract : KeyHolderLibrary</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x66d1a905667807f0b86734b4dee3c784e180bbe9">0x66d1a905667807f0b86734b4dee3c784e180bbe9</a></p>
<pre><code class="language-solidity">function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)
        public
        returns (bool success)
    {
        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), &quot;Sender does not have action key&quot;);
        require(!_keyHolderData.executions[_id].executed, &quot;Already executed&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            _keyHolderData.executions[_id].approved = true;
            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);
            if (success) {
                _keyHolderData.executions[_id].executed = true;
                emit Executed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            } else {
                emit ExecutionFailed(
                    _id,
                    _keyHolderData.executions[_id].to,
                    _keyHolderData.executions[_id].value,
                    _keyHolderData.executions[_id].data
                );
                return;
            }
        } else {
            _keyHolderData.executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ClaimIssuer</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcb32569cac906e4ee13ca413e058a7178fa1fc27">0xcb32569cac906e4ee13ca413e058a7178fa1fc27</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : ERC734</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcb32569cac906e4ee13ca413e058a7178fa1fc27">0xcb32569cac906e4ee13ca413e058a7178fa1fc27</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : Identity</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xcb32569cac906e4ee13ca413e058a7178fa1fc27">0xcb32569cac906e4ee13ca413e058a7178fa1fc27</a></p>
<pre><code class="language-solidity">function approve(uint256 _id, bool _approve)
    public
    returns (bool success)
    {
        require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), &quot;Sender does not have action key&quot;);

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;

            (success,) = executions[_id].to.call.value(executions[_id].value)(abi.encode(executions[_id].data, 0));

            if (success) {
                executions[_id].executed = true;

                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return true;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );

                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>_approve == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x760dad4fbb7d3157f1949963d205552ed74a9cf1">0x760dad4fbb7d3157f1949963d205552ed74a9cf1</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x760dad4fbb7d3157f1949963d205552ed74a9cf1">0x760dad4fbb7d3157f1949963d205552ed74a9cf1</a></p>
<pre><code class="language-solidity">function UnstakeTokens(uint256 _amount, bool isEmergency) external synchronized {
    require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
    require( staker[msg.sender].stakedBalance &gt;= _amount, &quot;unstake amount is bigger than you staked&quot; );

    uint256 outAmount = _amount;
    uint fee = 0;
    uint emerAmt = 0;

    if ( isEmergency == true) {
      fee = _amount.mul(9).div(100);
             emerAmt = _amount.sub(fee);
    }

    staker[msg.sender].stakedBalance = staker[msg.sender].stakedBalance.sub(_amount);
    staker[msg.sender].lastDepositTime = block.timestamp;

    if ( isEmergency == true) {
        // send token to msg.sender.
            _transfer(address(this), msg.sender, emerAmt);
            _burn(msg.sender, fee);
        return;
    }

    staker[msg.sender].unstakeStartTime = block.timestamp;
    staker[msg.sender].pendingAmount = staker[msg.sender].pendingAmount + outAmount;

  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : TokenData</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xfd61352232157815cf7b71045557192bf0ce1884">0xfd61352232157815cf7b71045557192bf0ce1884</a></p>
<pre><code class="language-solidity">function setDepositCN(uint coverId, bool flag) public onlyInternal {

        if (flag == true) {
            require(!depositedCN[coverId].isDeposited, &quot;Cover note already deposited&quot;);    
        }

        depositedCN[coverId].isDeposited = flag;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>flag == true</code></p>
<hr />
<h3>Contract : HumansVersusApplesnakes</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xd4041c5c315fd7169b0cd4c73680311a422752b0">0xd4041c5c315fd7169b0cd4c73680311a422752b0</a></p>
<pre><code class="language-solidity">function safeMint(uint256 amount, bool free) payable public {
        address user = msg.sender;
        require(Database.TokensLeft &gt;= amount, &quot;There are no tokens left!&quot;);
        require(block.timestamp &gt; Database.mintTime, &quot;Mint is not yet active!&quot;);
        uint256 cost = amount * Database.mintPrice;
        if (free == true) {
            require(whitelist[user] &gt;= amount, &quot;You do not have a whitelist for this amount of nfts&quot;);
            cost = 0;
            whitelist[user] -= amount;
        }
        require(msg.value &gt;= cost, &quot;You did not send the correct ammount of eth for this mint!&quot;);
        for (uint i = 0; i &lt; amount; i++) {
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        Database.TokensLeft--;
        _safeMint(user, tokenId);  
        }


    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>free == true</code></p>
<hr />
<h3>Contract : CoolSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3eb66d4494e8bb0a82959f1c235eb1e91f26ccd1">0x3eb66d4494e8bb0a82959f1c235eb1e91f26ccd1</a></p>
<pre><code class="language-solidity">function dealSlippageWithIn(address[] calldata path, uint256 amountIn, address to, bool ifmint) external lock returns (uint256 amountOut) {
        require(path.length == 2, &quot;CoolSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountOutReal;
        uint256 amountOutMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountOutReal = getAmountOutReal(amountIn, _reserveIn, _reserveOut);
            amountOut = amountOutReal;
            (amountOutMarket, ) = getAmountOutMarket(path[0], amountIn);
            uint256 balance = IERC20(path[0]).balanceOf(address(this));
            uint256 amount = balance.sub(_reserveIn);
            require(amount &gt;= amountIn, &quot;CoolSwap: Invalid Amount&quot;);
        }

        // arbitrager
        if (amountOutReal &gt; amountOutMarket) {
            uint256 slippageExtra = amountOutReal.sub(amountOutMarket);
            uint256 halfSlippage = slippageExtra / 2;
            amountOut = amountOutReal.sub(halfSlippage);
        }

        if (ifmint == true) {
            (uint256 amountOutPool, uint256 t0Price) = getAmountOutPool(path[0], amountIn);
            uint256 slippage = amountOutPool.sub(amountOutReal);
            uint256 mintAmount = path[1] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : CoolSwapPair</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x3eb66d4494e8bb0a82959f1c235eb1e91f26ccd1">0x3eb66d4494e8bb0a82959f1c235eb1e91f26ccd1</a></p>
<pre><code class="language-solidity">function dealSlippageWithOut(address[] calldata path, uint256 amountOut, address to, bool ifmint) external lock returns (uint256 extra) {
        require(path.length == 2, &quot;CoolSwap: INVALID_PATH&quot;);
        address _token0 = token0;
        uint256 amountInReal;
        uint256 amountInMarket;

        // avoids stack too deep errors
        {
            (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
            (uint256 _reserveIn, uint256 _reserveOut) = path[0] == _token0
                ? (_reserve0, _reserve1)
                : (_reserve1, _reserve0);
            amountInReal = getAmountInReal(amountOut, _reserveIn, _reserveOut);
            (amountInMarket, ) = getAmountInMarket(path[1], amountOut);
        }

        // arbitrager
        if (amountInReal &lt; amountInMarket) {
            uint256 slippageExtra = amountInMarket.sub(amountInReal);
            extra = slippageExtra / 2;
        }

        if (ifmint == true) {
            (uint256 amountInPool, uint256 t0Price) = getAmountInPool(path[1], amountOut);
            uint256 slippage = amountInReal.sub(amountInPool);
            uint256 mintAmount = path[0] == _token0 ? slippage.mul(t0Price) / UQ112 : slippage;
            stoken.mint(to, mintAmount);
        }
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>ifmint == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe6c7b1c79c9211391f59f685415ac71588845734">0xe6c7b1c79c9211391f59f685415ac71588845734</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            stakerStorage.getStaker(msg.sender).stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        // Calculate staking rewards
        uint256 stakingRewards = calcStakingRewards(msg.sender);

        // Only claim interest if staking rewards are less than or equal to the staking rewards pool
        if (stakingRewards &lt;= stakingRewardsPool) {
            _claimInterest();
        }

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }
        //get the current staker details
        MkongStaker.Staker memory currentStaker = stakerStorage.getStaker(
            msg.sender
        );
        currentStaker.stakedBalance = currentStaker.stakedBalance.sub(_amount);
        currentStaker.lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transferMkong(address(this), msg.sender, emerAmt);
            _burnMkong(msg.sender, fee);
            //save updated staker details
            stakerStorage.setStaker(msg.sender, currentStaker);
            totalStaked = totalStaked.sub(_amount);
            return;
        }

        currentStaker.unstakeStartTime = block.timestamp;
        currentStaker.pendingAmount = currentStaker.pendingAmount + outAmount;

        //save updated staker details
        stakerStorage.setStaker(msg.sender, currentStaker);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MEMEKONG</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xe6c7b1c79c9211391f59f685415ac71588845734">0xe6c7b1c79c9211391f59f685415ac71588845734</a></p>
<pre><code class="language-solidity">function UnstakeTokens(
        uint256 _amount,
        bool isEmergency
    ) external synchronized {
        require(_amount &gt; 0, &quot;invalid deposit amount&quot;);
        require(
            stakerStorage.getStaker(msg.sender).stakedBalance &gt;= _amount,
            &quot;unstake amount is bigger than you staked&quot;
        );

        // Calculate staking rewards
        uint256 stakingRewards = calcStakingRewards(msg.sender);

        // Only claim interest if staking rewards are less than or equal to the staking rewards pool
        if (stakingRewards &lt;= stakingRewardsPool) {
            _claimInterest();
        }

        uint256 outAmount = _amount;
        uint fee = 0;
        uint emerAmt = 0;

        if (isEmergency == true) {
            fee = _amount.mul(9).div(100);

            emerAmt = _amount.sub(fee);
        }
        //get the current staker details
        MkongStaker.Staker memory currentStaker = stakerStorage.getStaker(
            msg.sender
        );
        currentStaker.stakedBalance = currentStaker.stakedBalance.sub(_amount);
        currentStaker.lastDepositTime = block.timestamp;

        if (isEmergency == true) {
            // send token to msg.sender.
            _transferMkong(address(this), msg.sender, emerAmt);
            _burnMkong(msg.sender, fee);
            //save updated staker details
            stakerStorage.setStaker(msg.sender, currentStaker);
            totalStaked = totalStaked.sub(_amount);
            return;
        }

        currentStaker.unstakeStartTime = block.timestamp;
        currentStaker.pendingAmount = currentStaker.pendingAmount + outAmount;

        //save updated staker details
        stakerStorage.setStaker(msg.sender, currentStaker);
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>isEmergency == true</code></p>
<hr />
<h3>Contract : MSDropERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4f62308bbca4c8878fc14017234677354715177b">0x4f62308bbca4c8878fc14017234677354715177b</a></p>
<pre><code class="language-solidity">function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bool _isAuction,
    Auction calldata _auction,
    bool _isPhysic,
    ClaimCondition[] calldata _phases,
    bool _resetClaimEligibility,
    bool update
  ) external onlyRole(MINTER_ROLE) {
    uint256 startId = nextTokenIdToMint;
    uint256 index = startId + _amount;
    if (update == true) {
      index = _amount;
    } else {
      indices.push(index);
      emit TokensLazyMinted(startId, index - 1, _baseURIForTokens, royaltyRecipient);
    }

    nextTokenIdToMint = index;
    baseURI[index] = _baseURIForTokens;
    if (_isAuction) {
      Editions[index].isAuction=_isAuction;
      Editions[index].auction=_auction;
      emit AuctionsConditionsUpdated(_phases, _auction, startId, index - 1);
    } else {
      Editions[index].isPhysic = _isPhysic;
      setClaimConditions(index, _phases, _resetClaimEligibility, startId, index - 1);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>update == true</code></p>
<hr />
<h3>Contract : MSDropERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4f62308bbca4c8878fc14017234677354715177b">0x4f62308bbca4c8878fc14017234677354715177b</a></p>
<pre><code class="language-solidity">function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bool _isAuction,
    Auction calldata _auction,
    bool _isPhysic,
    ClaimCondition[] calldata _phases,
    bool _resetClaimEligibility,
    bool update
  ) external onlyRole(MINTER_ROLE) {
    uint256 startId = nextTokenIdToMint;
    uint256 index = startId + _amount;
    if (update == true) {
      index = _amount;
    } else {
      indices.push(index);
      emit TokensLazyMinted(startId, index - 1, _baseURIForTokens, royaltyRecipient);
    }

    nextTokenIdToMint = index;
    baseURI[index] = _baseURIForTokens;
    if (_isAuction) {
      Editions[index].isAuction=_isAuction;
      Editions[index].auction=_auction;
      emit AuctionsConditionsUpdated(_phases, _auction, startId, index - 1);
    } else {
      Editions[index].isPhysic = _isPhysic;
      setClaimConditions(index, _phases, _resetClaimEligibility, startId, index - 1);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>update == true</code></p>
<hr />
<h3>Contract : MSDropERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4f62308bbca4c8878fc14017234677354715177b">0x4f62308bbca4c8878fc14017234677354715177b</a></p>
<pre><code class="language-solidity">function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bool _isAuction,
    Auction calldata _auction,
    bool _isPhysic,
    ClaimCondition[] calldata _phases,
    bool _resetClaimEligibility,
    bool update
  ) external onlyRole(MINTER_ROLE) {
    uint256 startId = nextTokenIdToMint;
    uint256 index = startId + _amount;
    if (update == true) {
      index = _amount;
    } else {
      indices.push(index);
      emit TokensLazyMinted(startId, index - 1, _baseURIForTokens, royaltyRecipient);
    }

    nextTokenIdToMint = index;
    baseURI[index] = _baseURIForTokens;
    if (_isAuction) {
      Editions[index].isAuction=_isAuction;
      Editions[index].auction=_auction;
      emit AuctionsConditionsUpdated(_phases, _auction, startId, index - 1);
    } else {
      Editions[index].isPhysic = _isPhysic;
      setClaimConditions(index, _phases, _resetClaimEligibility, startId, index - 1);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>update == true</code></p>
<hr />
<h3>Contract : MSDropERC721</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0x4f62308bbca4c8878fc14017234677354715177b">0x4f62308bbca4c8878fc14017234677354715177b</a></p>
<pre><code class="language-solidity">function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bool _isAuction,
    Auction calldata _auction,
    bool _isPhysic,
    ClaimCondition[] calldata _phases,
    bool _resetClaimEligibility,
    bool update
  ) external onlyRole(MINTER_ROLE) {
    uint256 startId = nextTokenIdToMint;
    uint256 index = startId + _amount;
    if (update == true) {
      index = _amount;
    } else {
      indices.push(index);
      emit TokensLazyMinted(startId, index - 1, _baseURIForTokens, royaltyRecipient);
    }

    nextTokenIdToMint = index;
    baseURI[index] = _baseURIForTokens;
    if (_isAuction) {
      Editions[index].isAuction=_isAuction;
      Editions[index].auction=_auction;
      emit AuctionsConditionsUpdated(_phases, _auction, startId, index - 1);
    } else {
      Editions[index].isPhysic = _isPhysic;
      setClaimConditions(index, _phases, _resetClaimEligibility, startId, index - 1);
    }
  }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>update == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyREETHArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa46e86bbe84a98fca097addac41a7494da33a1ff">0xa46e86bbe84a98fca097addac41a7494da33a1ff</a></p>
<pre><code class="language-solidity">function deposit(bool nonContract) public onlyZSToken {
        // Only the ZS token can call the function

        // No trading is performed on deposit
        if(nonContract == true){ }
        lastActionBalance = balance();
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
<h3>Contract : StabilizeStrategyREETHArbV1</h3>
<p><strong>Address:</strong> <a href="https://etherscan.io/address/0xa46e86bbe84a98fca097addac41a7494da33a1ff">0xa46e86bbe84a98fca097addac41a7494da33a1ff</a></p>
<pre><code class="language-solidity">function withdraw(address _depositor, uint256 _share, uint256 _total, bool nonContract) public onlyZSToken returns (uint256) {
        require(balance() &gt; 0, &quot;There are no tokens in this strategy&quot;);
        if(nonContract == true){ }

        uint256 withdrawAmount = 0;
        uint256 _balance = balance(); // Returns the normalized balance
        if(_share &lt; _total){
            uint256 _myBalance = _balance.mul(_share).div(_total);
            withdrawPerOrderWithOracle(_depositor, _myBalance, false); // This will withdraw based on order
            withdrawAmount = _myBalance;
        }else{
            // We are all shares, transfer all
            withdrawPerOrderWithOracle(_depositor, _balance, true);
            withdrawAmount = _balance;
        }       
        lastActionBalance = balance();

        return withdrawAmount;
    }
</code></pre>
<p><strong>Vulnerable If Instruction:</strong> <code>nonContract == true</code></p>
<hr />
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Wrap instruction text in code tags
        document.querySelectorAll('.instruction').forEach(function(el) {
            var text = el.textContent;
            var match = text.match(/^Instruction:\s*(.*)/);
            if (match) {
                el.innerHTML = 'Instruction: <code>' + match[1].replace(/`/g, '') + '</code>';
            }
        });

        // Apply Prism.js highlighting
        Prism.highlightAll();
    </script>
</body>
</html>
